This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: deployments, test, abis, script
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
scripts/
  list_deployment_addresses.py
snapshots/
  IntegrationTest.json
src/
  deps/
    cowprotocol/
      GPv2Order.sol
    permit2/
      Permit2Lib.sol
      SafeCast160.sol
    uniswap-v3-periphery/
      base/
        SelfPermit.sol
      interfaces/
        external/
          IERC20PermitAllowed.sol
        ISelfPermit.sol
  interfaces/
    deps/
      permit2/
        IAllowanceTransfer.sol
        IDAIPermit.sol
        IEIP712.sol
        IPermit2.sol
        ISignatureTransfer.sol
      IChainlinkAggregatorV3Interface.sol
      IPriceOracleWithBaseAndQuote.sol
      IPyth.sol
    IAllocationResolver.sol
    IERC7540.sol
    IERC7575.sol
    IMasterRegistry.sol
  libraries/
    BasketManagerUtils.sol
    BitFlag.sol
    MathUtils.sol
  operators/
    BasicRetryOperator.sol
  oracles/
    AnchoredOracle.sol
    ChainedERC4626Oracle.sol
    CurveEMAOracleUnderlying.sol
    ERC4626Oracle.sol
  rewards/
    FarmingPluginFactory.sol
  strategies/
    AutomaticWeightStrategy.sol
    ManagedWeightStrategy.sol
    StrategyRegistry.sol
    WeightStrategy.sol
  swap_adapters/
    CoWSwapAdapter.sol
    CoWSwapClone.sol
    TokenSwapAdapter.sol
  types/
    BasketManagerStorage.sol
    Trades.sol
  AssetRegistry.sol
  BasketManager.sol
  BasketToken.sol
  FeeCollector.sol
  Rescuable.sol
.cursorignore
.cursorrules
.env.example
.npmrc
.repomixignore
deployments_tree.txt
extractAbis.py
LICENSE
package.json
process_states.py
README.md
requirements.txt
soldeer.lock
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="scripts/list_deployment_addresses.py">
#!/usr/bin/env python3
"""
List deployment addresses by environment.
Reads JSON files under deployments/1 and prints tables per environment.
Environment is
  - Production: filename starts with "Production_"
  - Staging: filename starts with "Staging_"
  - Test: anything else
"""

import json
import os
import sys
from collections import defaultdict

# Determine project root (directory containing this script and deployments folder)
ROOT_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), os.pardir))
DEPLOY_DIR = os.path.join(ROOT_DIR, "deployments", "1")

if not os.path.isdir(DEPLOY_DIR):
    sys.exit(f"Deployment directory not found: {DEPLOY_DIR}")


def classify_env(filename: str) -> str:
    """Classify environment based on filename prefix."""
    if filename.startswith("Production_"):
        return "Production"
    if filename.startswith("Staging_"):
        return "Staging"
    return "Test"


def strip_prefix(contract_filename: str, env: str) -> str:
    """Remove environment prefix from contract filename (sans extension)."""
    name = os.path.splitext(contract_filename)[0]
    prefixes = {
        "Production": "Production_",
        "Staging": "Staging_",
    }
    prefix = prefixes.get(env, "")
    if prefix and name.startswith(prefix):
        return name[len(prefix) :]
    return name


def collect_addresses() -> dict[str, list[tuple[str, str]]]:
    env_map: dict[str, list[tuple[str, str]]] = defaultdict(list)

    for entry in os.scandir(DEPLOY_DIR):
        if not entry.name.endswith(".json") or not entry.is_file():
            continue
        env = classify_env(entry.name)
        try:
            with open(entry.path, "r") as fp:
                data = json.load(fp)
                address = data.get("address")
        except (json.JSONDecodeError, OSError):
            continue
        if not address:
            continue
        contract = strip_prefix(entry.name, env)
        env_map[env].append((contract, address))
    # Sort each list by contract name for deterministic output
    for lst in env_map.values():
        lst.sort(key=lambda x: x[0].lower())
    return env_map


def format_table(rows: list[tuple[str, str]]) -> str:
    if not rows:
        return ""
    contract_width = max(len("Contract"), *(len(r[0]) for r in rows))
    address_width = max(len("Address"), *(len(r[1]) for r in rows))

    border = "+" + "-" * (contract_width + 2) + "+" + "-" * (address_width + 2) + "+"
    header = f"| {'Contract'.ljust(contract_width)} | {'Address'.ljust(address_width)} |"

    lines = [border, header, border]
    for contract, addr in rows:
        lines.append(f"| {contract.ljust(contract_width)} | {addr.ljust(address_width)} |")
    lines.append(border)
    return "\n".join(lines)


def main() -> None:
    env_map = collect_addresses()

    if not env_map:
        print("No deployment files found.")
        return

    for env in ("Production", "Staging", "Test"):
        rows = env_map.get(env)
        if not rows:
            continue
        print(f"{env}:\n")
        print(format_table(rows))
        print()


if __name__ == "__main__":
    main()
</file>

<file path="snapshots/IntegrationTest.json">
{
  "BasketManager.createNewBasket": "714824",
  "BasketToken.deposit": "35178",
  "BasketToken.proRataRedeem": "186313",
  "BasketToken.requestDeposit": "100557",
  "ManagedWeightStrategy.setTargetWeights": "41553",
  "completeRebalance w/ single basket": "669883",
  "executeTokenSwap": "901353",
  "proposeRebalance w/ single basket": "147137",
  "proposeTokenSwap w/ single basket (no internal trades)": "537125"
}
</file>

<file path="src/deps/cowprotocol/GPv2Order.sol">
// SPDX-License-Identifier: LGPL-3.0-or-later
pragma solidity ^0.8.0;

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

/// @title Gnosis Protocol v2 Order Library
/// @author Gnosis Developers
library GPv2Order {
    /// @dev The complete data for a Gnosis Protocol order. This struct contains
    /// all order parameters that are signed for submitting to GP.
    struct Data {
        IERC20 sellToken;
        IERC20 buyToken;
        address receiver;
        uint256 sellAmount;
        uint256 buyAmount;
        uint32 validTo;
        bytes32 appData;
        uint256 feeAmount;
        bytes32 kind;
        bool partiallyFillable;
        bytes32 sellTokenBalance;
        bytes32 buyTokenBalance;
    }

    /// @dev The order EIP-712 type hash for the [`GPv2Order.Data`] struct.
    ///
    /// This value is pre-computed from the following expression:
    /// ```
    /// keccak256(
    ///     "Order(" +
    ///         "address sellToken," +
    ///         "address buyToken," +
    ///         "address receiver," +
    ///         "uint256 sellAmount," +
    ///         "uint256 buyAmount," +
    ///         "uint32 validTo," +
    ///         "bytes32 appData," +
    ///         "uint256 feeAmount," +
    ///         "string kind," +
    ///         "bool partiallyFillable," +
    ///         "string sellTokenBalance," +
    ///         "string buyTokenBalance" +
    ///     ")"
    /// )
    /// ```
    bytes32 internal constant TYPE_HASH = hex"d5a25ba2e97094ad7d83dc28a6572da797d6b3e7fc6663bd93efb789fc17e489";

    /// @dev The marker value for a sell order for computing the order struct
    /// hash. This allows the EIP-712 compatible wallets to display a
    /// descriptive string for the order kind (instead of 0 or 1).
    ///
    /// This value is pre-computed from the following expression:
    /// ```
    /// keccak256("sell")
    /// ```
    bytes32 internal constant KIND_SELL = hex"f3b277728b3fee749481eb3e0b3b48980dbbab78658fc419025cb16eee346775";

    /// @dev The OrderKind marker value for a buy order for computing the order
    /// struct hash.
    ///
    /// This value is pre-computed from the following expression:
    /// ```
    /// keccak256("buy")
    /// ```
    bytes32 internal constant KIND_BUY = hex"6ed88e868af0a1983e3886d5f3e95a2fafbd6c3450bc229e27342283dc429ccc";

    /// @dev The TokenBalance marker value for using direct ERC20 balances for
    /// computing the order struct hash.
    ///
    /// This value is pre-computed from the following expression:
    /// ```
    /// keccak256("erc20")
    /// ```
    bytes32 internal constant BALANCE_ERC20 = hex"5a28e9363bb942b639270062aa6bb295f434bcdfc42c97267bf003f272060dc9";

    /// @dev The TokenBalance marker value for using Balancer Vault external
    /// balances (in order to re-use Vault ERC20 approvals) for computing the
    /// order struct hash.
    ///
    /// This value is pre-computed from the following expression:
    /// ```
    /// keccak256("external")
    /// ```
    bytes32 internal constant BALANCE_EXTERNAL = hex"abee3b73373acd583a130924aad6dc38cfdc44ba0555ba94ce2ff63980ea0632";

    /// @dev The TokenBalance marker value for using Balancer Vault internal
    /// balances for computing the order struct hash.
    ///
    /// This value is pre-computed from the following expression:
    /// ```
    /// keccak256("internal")
    /// ```
    bytes32 internal constant BALANCE_INTERNAL = hex"4ac99ace14ee0a5ef932dc609df0943ab7ac16b7583634612f8dc35a4289a6ce";

    /// @dev Marker address used to indicate that the receiver of the trade
    /// proceeds should the owner of the order.
    ///
    /// This is chosen to be `address(0)` for gas efficiency as it is expected
    /// to be the most common case.
    address internal constant RECEIVER_SAME_AS_OWNER = address(0);

    /// @dev The byte length of an order unique identifier.
    uint256 internal constant UID_LENGTH = 56;

    /// @dev Returns the actual receiver for an order. This function checks
    /// whether or not the [`receiver`] field uses the marker value to indicate
    /// it is the same as the order owner.
    ///
    /// @return receiver The actual receiver of trade proceeds.
    function actualReceiver(Data memory order, address owner) internal pure returns (address receiver) {
        if (order.receiver == RECEIVER_SAME_AS_OWNER) {
            receiver = owner;
        } else {
            receiver = order.receiver;
        }
    }

    /// @dev Return the EIP-712 signing hash for the specified order.
    ///
    /// @param order The order to compute the EIP-712 signing hash for.
    /// @param domainSeparator The EIP-712 domain separator to use.
    /// @return orderDigest The 32 byte EIP-712 struct hash.
    function hash(Data memory order, bytes32 domainSeparator) internal pure returns (bytes32 orderDigest) {
        bytes32 structHash;

        // NOTE: Compute the EIP-712 order struct hash in place. As suggested
        // in the EIP proposal, noting that the order struct has 12 fields, and
        // prefixing the type hash `(1 + 12) * 32 = 416` bytes to hash.
        // <https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md#rationale-for-encodedata>
        // solhint-disable-next-line no-inline-assembly
        assembly {
            let dataStart := sub(order, 32)
            let temp := mload(dataStart)
            mstore(dataStart, TYPE_HASH)
            structHash := keccak256(dataStart, 416)
            mstore(dataStart, temp)
        }

        // NOTE: Now that we have the struct hash, compute the EIP-712 signing
        // hash using scratch memory past the free memory pointer. The signing
        // hash is computed from `"\x19\x01" || domainSeparator || structHash`.
        // <https://docs.soliditylang.org/en/v0.7.6/internals/layout_in_memory.html#layout-in-memory>
        // <https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md#specification>
        // solhint-disable-next-line no-inline-assembly
        assembly {
            let freeMemoryPointer := mload(0x40)
            mstore(freeMemoryPointer, "\x19\x01")
            mstore(add(freeMemoryPointer, 2), domainSeparator)
            mstore(add(freeMemoryPointer, 34), structHash)
            orderDigest := keccak256(freeMemoryPointer, 66)
        }
    }

    /// @dev Packs order UID parameters into the specified memory location. The
    /// result is equivalent to `abi.encodePacked(...)` with the difference that
    /// it allows re-using the memory for packing the order UID.
    ///
    /// This function reverts if the order UID buffer is not the correct size.
    ///
    /// @param orderUid The buffer pack the order UID parameters into.
    /// @param orderDigest The EIP-712 struct digest derived from the order
    /// parameters.
    /// @param owner The address of the user who owns this order.
    /// @param validTo The epoch time at which the order will stop being valid.
    function packOrderUidParams(
        bytes memory orderUid,
        bytes32 orderDigest,
        address owner,
        uint32 validTo
    )
        internal
        pure
    {
        require(orderUid.length == UID_LENGTH, "GPv2: uid buffer overflow");

        // NOTE: Write the order UID to the allocated memory buffer. The order
        // parameters are written to memory in **reverse order** as memory
        // operations write 32-bytes at a time and we want to use a packed
        // encoding. This means, for example, that after writing the value of
        // `owner` to bytes `20:52`, writing the `orderDigest` to bytes `0:32`
        // will **overwrite** bytes `20:32`. This is desirable as addresses are
        // only 20 bytes and `20:32` should be `0`s:
        //
        //        |           1111111111222222222233333333334444444444555555
        //   byte | 01234567890123456789012345678901234567890123456789012345
        // -------+---------------------------------------------------------
        //  field | [.........orderDigest..........][......owner.......][vT]
        // -------+---------------------------------------------------------
        // mstore |                         [000000000000000000000000000.vT]
        //        |                     [00000000000.......owner.......]
        //        | [.........orderDigest..........]
        //
        // Additionally, since Solidity `bytes memory` are length prefixed,
        // 32 needs to be added to all the offsets.
        //
        // solhint-disable-next-line no-inline-assembly
        assembly {
            mstore(add(orderUid, 56), validTo)
            mstore(add(orderUid, 52), owner)
            mstore(add(orderUid, 32), orderDigest)
        }
    }

    /// @dev Extracts specific order information from the standardized unique
    /// order id of the protocol.
    ///
    /// @param orderUid The unique identifier used to represent an order in
    /// the protocol. This uid is the packed concatenation of the order digest,
    /// the validTo order parameter and the address of the user who created the
    /// order. It is used by the user to interface with the contract directly,
    /// and not by calls that are triggered by the solvers.
    /// @return orderDigest The EIP-712 signing digest derived from the order
    /// parameters.
    /// @return owner The address of the user who owns this order.
    /// @return validTo The epoch time at which the order will stop being valid.
    function extractOrderUidParams(
        bytes calldata orderUid
    )
        internal
        pure
        returns (bytes32 orderDigest, address owner, uint32 validTo)
    {
        require(orderUid.length == UID_LENGTH, "GPv2: invalid uid");

        // Use assembly to efficiently decode packed calldata.
        // solhint-disable-next-line no-inline-assembly
        assembly {
            orderDigest := calldataload(orderUid.offset)
            owner := shr(96, calldataload(add(orderUid.offset, 32)))
            validTo := shr(224, calldataload(add(orderUid.offset, 52)))
        }
    }
}
</file>

<file path="src/deps/uniswap-v3-periphery/base/SelfPermit.sol">
// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity >=0.5.0;

import { IERC20 } from '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import { IERC20Permit } from "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol";

import { ISelfPermit } from '../interfaces/ISelfPermit.sol';
import { IERC20PermitAllowed } from '../interfaces/external/IERC20PermitAllowed.sol';

/// @title Self Permit
/// @notice Functionality to call permit on any EIP-2612-compliant token for use in the route
/// @dev These functions are expected to be embedded in multicalls to allow EOAs to approve a contract and call a function
/// that requires an approval in a single transaction.
abstract contract SelfPermit is ISelfPermit {
    /// @inheritdoc ISelfPermit
    function selfPermit(
        address token,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public payable override {
        IERC20Permit(token).permit(msg.sender, address(this), value, deadline, v, r, s);
    }

    /// @inheritdoc ISelfPermit
    function selfPermitIfNecessary(
        address token,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external payable override {
        if (IERC20(token).allowance(msg.sender, address(this)) < value) selfPermit(token, value, deadline, v, r, s);
    }

    /// @inheritdoc ISelfPermit
    function selfPermitAllowed(
        address token,
        uint256 nonce,
        uint256 expiry,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public payable override {
        IERC20PermitAllowed(token).permit(msg.sender, address(this), nonce, expiry, true, v, r, s);
    }

    /// @inheritdoc ISelfPermit
    function selfPermitAllowedIfNecessary(
        address token,
        uint256 nonce,
        uint256 expiry,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external payable override {
        if (IERC20(token).allowance(msg.sender, address(this)) < type(uint256).max)
            selfPermitAllowed(token, nonce, expiry, v, r, s);
    }
}
</file>

<file path="src/deps/uniswap-v3-periphery/interfaces/external/IERC20PermitAllowed.sol">
// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity >=0.5.0;

/// @title Interface for permit
/// @notice Interface used by DAI/CHAI for permit
interface IERC20PermitAllowed {
    /// @notice Approve the spender to spend some tokens via the holder signature
    /// @dev This is the permit interface used by DAI and CHAI
    /// @param holder The address of the token holder, the token owner
    /// @param spender The address of the token spender
    /// @param nonce The holder's nonce, increases at each call to permit
    /// @param expiry The timestamp at which the permit is no longer valid
    /// @param allowed Boolean that sets approval amount, true for type(uint256).max and false for 0
    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`
    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`
    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`
    function permit(
        address holder,
        address spender,
        uint256 nonce,
        uint256 expiry,
        bool allowed,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;
}
</file>

<file path="src/deps/uniswap-v3-periphery/interfaces/ISelfPermit.sol">
// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity >=0.7.5;

/// @title Self Permit
/// @notice Functionality to call permit on any EIP-2612-compliant token for use in the route
interface ISelfPermit {
    /// @notice Permits this contract to spend a given token from `msg.sender`
    /// @dev The `owner` is always msg.sender and the `spender` is always address(this).
    /// @param token The address of the token spent
    /// @param value The amount that can be spent of token
    /// @param deadline A timestamp, the current blocktime must be less than or equal to this timestamp
    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`
    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`
    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`
    function selfPermit(
        address token,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external payable;

    /// @notice Permits this contract to spend a given token from `msg.sender`
    /// @dev The `owner` is always msg.sender and the `spender` is always address(this).
    /// Can be used instead of #selfPermit to prevent calls from failing due to a frontrun of a call to #selfPermit
    /// @param token The address of the token spent
    /// @param value The amount that can be spent of token
    /// @param deadline A timestamp, the current blocktime must be less than or equal to this timestamp
    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`
    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`
    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`
    function selfPermitIfNecessary(
        address token,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external payable;

    /// @notice Permits this contract to spend the sender's tokens for permit signatures that have the `allowed` parameter
    /// @dev The `owner` is always msg.sender and the `spender` is always address(this)
    /// @param token The address of the token spent
    /// @param nonce The current nonce of the owner
    /// @param expiry The timestamp at which the permit is no longer valid
    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`
    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`
    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`
    function selfPermitAllowed(
        address token,
        uint256 nonce,
        uint256 expiry,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external payable;

    /// @notice Permits this contract to spend the sender's tokens for permit signatures that have the `allowed` parameter
    /// @dev The `owner` is always msg.sender and the `spender` is always address(this)
    /// Can be used instead of #selfPermitAllowed to prevent calls from failing due to a frontrun of a call to #selfPermitAllowed.
    /// @param token The address of the token spent
    /// @param nonce The current nonce of the owner
    /// @param expiry The timestamp at which the permit is no longer valid
    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`
    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`
    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`
    function selfPermitAllowedIfNecessary(
        address token,
        uint256 nonce,
        uint256 expiry,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external payable;
}
</file>

<file path="src/interfaces/deps/IPyth.sol">
// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.28;

interface IPyth {
    /// @notice Update price feeds with given update messages.
    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling
    /// `getUpdateFee` with the length of the `updateData` array.
    /// Prices will be updated if they are more recent than the current stored prices.
    /// The call will succeed even if the update is not the most recent.
    /// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid.
    /// @param updateData Array of price update data.
    function updatePriceFeeds(bytes[] calldata updateData) external payable;

    /// @notice Returns the required fee to update an array of price updates.
    /// @param updateData Array of price update data.
    /// @return feeAmount The required fee in Wei.
    function getUpdateFee(bytes[] calldata updateData) external view returns (uint256 feeAmount);

    /// @notice Returns the price and confidence interval.
    /// @dev Reverts if the price has not been updated within the last `getValidTimePeriod()` seconds.
    /// @param id The Pyth Price Feed ID of which to fetch the price and confidence interval.
    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.
    function getPrice(bytes32 id) external view returns (Price memory price);

    // A price with a degree of uncertainty, represented as a price +- a confidence interval.
    //
    // The confidence interval roughly corresponds to the standard error of a normal distribution.
    // Both the price and confidence are stored in a fixed-point numeric representation,
    // `x * (10^expo)`, where `expo` is the exponent.
    //
    // Please refer to the documentation at https://docs.pyth.network/consumers/best-practices for how
    // to how this price safely.
    struct Price {
        // Price
        int64 price;
        // Confidence interval around the price
        uint64 conf;
        // Price exponent
        int32 expo;
        // Unix timestamp describing when the price was published
        uint256 publishTime;
    }

    // PriceFeed represents a current aggregate price from pyth publisher feeds.
    struct PriceFeed {
        // The price ID.
        bytes32 id;
        // Latest available price
        Price price;
        // Latest available exponentially-weighted moving average price
        Price emaPrice;
    }
}
</file>

<file path="src/interfaces/IAllocationResolver.sol">
// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.28;

interface IAllocationResolver {
    function setAllocation(address basket, bytes32[] calldata newAllocation) external;
    function getTargetWeight(address basket) external view returns (bytes32[] memory);
    function getAllocationLength(address basket) external view returns (uint256);
    function getAllocationElement(address basket, uint256 index) external view returns (bytes32);
    function setBasketResolver(address basket, address resolver) external;
    function enroll(address basket, address resolver, uint256 selectionsLength) external;
    function isEnrolled(address basket) external view returns (bool);
    function isSubscribed(address basket, address proposer) external view returns (bool);
}
</file>

<file path="src/interfaces/IERC7540.sol">
// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.28;

interface IERC7540Operator {
    /**
     * @dev The event emitted when an operator is set.
     *
     * @param controller The address of the controller.
     * @param operator The address of the operator.
     * @param approved The approval status.
     */
    event OperatorSet(address indexed controller, address indexed operator, bool approved);

    /**
     * @dev Sets or removes an operator for the caller.
     *
     * @param operator The address of the operator.
     * @param approved The approval status.
     * @return Whether the call was executed successfully or not
     */
    function setOperator(address operator, bool approved) external returns (bool);

    /**
     * @dev Returns `true` if the `operator` is approved as an operator for an `controller`.
     *
     * @param controller The address of the controller.
     * @param operator The address of the operator.
     * @return status The approval status
     */
    function isOperator(address controller, address operator) external view returns (bool status);
}

interface IERC7540Deposit {
    event DepositRequest(
        address indexed controller, address indexed owner, uint256 indexed requestId, address sender, uint256 assets
    );
    /**
     * @dev Transfers assets from sender into the Vault and submits a Request for asynchronous deposit.
     *
     * - MUST support ERC-20 approve / transferFrom on asset as a deposit Request flow.
     * - MUST revert if all of assets cannot be requested for deposit.
     * - owner MUST be msg.sender unless some unspecified explicit approval is given by the caller,
     *    approval of ERC-20 tokens from owner to sender is NOT enough.
     *
     * @param assets the amount of deposit assets to transfer from owner
     * @param controller the controller of the request who will be able to operate the request
     * @param owner the source of the deposit assets
     *
     * NOTE: most implementations will require pre-approval of the Vault with the Vault's underlying asset token.
     */

    function requestDeposit(uint256 assets, address controller, address owner) external returns (uint256 requestId);

    /**
     * @dev Returns the amount of requested assets in Pending state.
     *
     * - MUST NOT include any assets in Claimable state for deposit or mint.
     * - MUST NOT show any variations depending on the caller.
     * - MUST NOT revert unless due to integer overflow caused by an unreasonably large input.
     */
    function pendingDepositRequest(
        uint256 requestId,
        address controller
    )
        external
        view
        returns (uint256 pendingAssets);

    /**
     * @dev Returns the amount of requested assets in Claimable state for the controller to deposit or mint.
     *
     * - MUST NOT include any assets in Pending state.
     * - MUST NOT show any variations depending on the caller.
     * - MUST NOT revert unless due to integer overflow caused by an unreasonably large input.
     */
    function claimableDepositRequest(
        uint256 requestId,
        address controller
    )
        external
        view
        returns (uint256 claimableAssets);

    /**
     * @dev Mints shares Vault shares to receiver by claiming the Request of the controller.
     *
     * - MUST emit the Deposit event.
     * - controller MUST equal msg.sender unless the controller has approved the msg.sender as an operator.
     */
    function deposit(uint256 assets, address receiver, address controller) external returns (uint256 shares);

    /**
     * @dev Mints exactly shares Vault shares to receiver by claiming the Request of the controller.
     *
     * - MUST emit the Deposit event.
     * - controller MUST equal msg.sender unless the controller has approved the msg.sender as an operator.
     */
    function mint(uint256 shares, address receiver, address controller) external returns (uint256 assets);
}

interface IERC7540Redeem {
    event RedeemRequest(
        address indexed controller, address indexed owner, uint256 indexed requestId, address sender, uint256 assets
    );

    /**
     * @dev Assumes control of shares from sender into the Vault and submits a Request for asynchronous redeem.
     *
     * - MUST support a redeem Request flow where the control of shares is taken from sender directly
     *   where msg.sender has ERC-20 approval over the shares of owner.
     * - MUST revert if all of shares cannot be requested for redeem.
     *
     * @param shares the amount of shares to be redeemed to transfer from owner
     * @param controller the controller of the request who will be able to operate the request
     * @param owner the source of the shares to be redeemed
     *
     * NOTE: most implementations will require pre-approval of the Vault with the Vault's share token.
     */
    function requestRedeem(uint256 shares, address controller, address owner) external returns (uint256 requestId);

    /**
     * @dev Returns the amount of requested shares in Pending state.
     *
     * - MUST NOT include any shares in Claimable state for redeem or withdraw.
     * - MUST NOT show any variations depending on the caller.
     * - MUST NOT revert unless due to integer overflow caused by an unreasonably large input.
     */
    function pendingRedeemRequest(
        uint256 requestId,
        address controller
    )
        external
        view
        returns (uint256 pendingShares);

    /**
     * @dev Returns the amount of requested shares in Claimable state for the controller to redeem or withdraw.
     *
     * - MUST NOT include any shares in Pending state for redeem or withdraw.
     * - MUST NOT show any variations depending on the caller.
     * - MUST NOT revert unless due to integer overflow caused by an unreasonably large input.
     */
    function claimableRedeemRequest(
        uint256 requestId,
        address controller
    )
        external
        view
        returns (uint256 claimableShares);
}
</file>

<file path="src/interfaces/IERC7575.sol">
// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.28;

import { IERC165 } from "@openzeppelin/contracts/utils/introspection/IERC165.sol";

interface IERC7575 is IERC165 {
    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);
    event Withdraw(
        address indexed sender, address indexed receiver, address indexed owner, uint256 assets, uint256 shares
    );

    /**
     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.
     *
     * - MUST be an ERC-20 token contract.
     * - MUST NOT revert.
     */
    function asset() external view returns (address assetTokenAddress);

    /**
     * @dev Returns the address of the share token
     *
     * - MUST be an ERC-20 token contract.
     * - MUST NOT revert.
     */
    function share() external view returns (address shareTokenAddress);

    /**
     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal
     * scenario where all the conditions are met.
     *
     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.
     * - MUST NOT show any variations depending on the caller.
     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.
     * - MUST NOT revert.
     *
     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the
     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and
     * from.
     */
    function convertToShares(uint256 assets) external view returns (uint256 shares);

    /**
     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal
     * scenario where all the conditions are met.
     *
     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.
     * - MUST NOT show any variations depending on the caller.
     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.
     * - MUST NOT revert.
     *
     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the
     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and
     * from.
     */
    function convertToAssets(uint256 shares) external view returns (uint256 assets);

    /**
     * @dev Returns the total amount of the underlying asset that is “managed” by Vault.
     *
     * - SHOULD include any compounding that occurs from yield.
     * - MUST be inclusive of any fees that are charged against assets in the Vault.
     * - MUST NOT revert.
     */
    function totalAssets() external view returns (uint256 totalManagedAssets);

    /**
     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,
     * through a deposit call.
     *
     * - MUST return a limited value if receiver is subject to some deposit limit.
     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.
     * - MUST NOT revert.
     */
    function maxDeposit(address receiver) external view returns (uint256 maxAssets);

    /**
     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given
     * current on-chain conditions.
     *
     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit
     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called
     *   in the same transaction.
     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the
     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.
     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.
     * - MUST NOT revert.
     *
     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in
     * share price or some other type of condition, meaning the depositor will lose assets by depositing.
     */
    function previewDeposit(uint256 assets) external view returns (uint256 shares);

    /**
     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.
     *
     * - MUST emit the Deposit event.
     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the
     *   deposit execution, and are accounted for during deposit.
     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not
     *   approving enough underlying tokens to the Vault contract, etc).
     *
     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.
     */
    function deposit(uint256 assets, address receiver) external returns (uint256 shares);

    /**
     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.
     * - MUST return a limited value if receiver is subject to some mint limit.
     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.
     * - MUST NOT revert.
     */
    function maxMint(address receiver) external view returns (uint256 maxShares);

    /**
     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given
     * current on-chain conditions.
     *
     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call
     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the
     *   same transaction.
     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint
     *   would be accepted, regardless if the user has enough tokens approved, etc.
     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.
     * - MUST NOT revert.
     *
     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in
     * share price or some other type of condition, meaning the depositor will lose assets by minting.
     */
    function previewMint(uint256 shares) external view returns (uint256 assets);

    /**
     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.
     *
     * - MUST emit the Deposit event.
     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint
     *   execution, and are accounted for during mint.
     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not
     *   approving enough underlying tokens to the Vault contract, etc).
     *
     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.
     */
    function mint(uint256 shares, address receiver) external returns (uint256 assets);

    /**
     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the
     * Vault, through a withdraw call.
     *
     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.
     * - MUST NOT revert.
     */
    function maxWithdraw(address owner) external view returns (uint256 maxAssets);

    /**
     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,
     * given current on-chain conditions.
     *
     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw
     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if
     *   called
     *   in the same transaction.
     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though
     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.
     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.
     * - MUST NOT revert.
     *
     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in
     * share price or some other type of condition, meaning the depositor will lose assets by depositing.
     */
    function previewWithdraw(uint256 assets) external view returns (uint256 shares);

    /**
     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.
     *
     * - MUST emit the Withdraw event.
     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the
     *   withdraw execution, and are accounted for during withdraw.
     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner
     *   not having enough shares, etc).
     *
     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.
     * Those methods should be performed separately.
     */
    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);

    /**
     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,
     * through a redeem call.
     *
     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.
     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.
     * - MUST NOT revert.
     */
    function maxRedeem(address owner) external view returns (uint256 maxShares);

    /**
     * @dev Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,
     * given current on-chain conditions.
     *
     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call
     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the
     *   same transaction.
     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the
     *   redemption would be accepted, regardless if the user has enough shares, etc.
     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.
     * - MUST NOT revert.
     *
     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in
     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.
     */
    function previewRedeem(uint256 shares) external view returns (uint256 assets);

    /**
     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.
     *
     * - MUST emit the Withdraw event.
     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the
     *   redeem execution, and are accounted for during redeem.
     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner
     *   not having enough shares, etc).
     *
     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.
     * Those methods should be performed separately.
     */
    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);
}
</file>

<file path="src/libraries/BitFlag.sol">
// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.28;

library BitFlag {
    // Bit masks used in the popCount algorithm
    // Binary: ...0101 0101 0101 0101
    uint256 private constant MASK_ODD_BITS = 0x5555555555555555555555555555555555555555555555555555555555555555;
    // Binary: ...0011 0011 0011 0011
    uint256 private constant MASK_EVEN_PAIRS = 0x3333333333333333333333333333333333333333333333333333333333333333;
    // Binary: ...0000 1111 0000 1111
    uint256 private constant MASK_NIBBLES = 0x0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F;
    // Binary: ...0000 0001 0000 0001
    uint256 private constant BYTE_MULTIPLIER = 0x0101010101010101010101010101010101010101010101010101010101010101;

    /// @dev Counts the number of set bits in a bit flag using parallel counting.
    /// This algorithm is based on the "Counting bits set, in parallel" technique from:
    /// https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetParallel
    /// @param bitFlag The bit flag to count the number of set bits.
    /// @return count The number of set bits in the bit flag.
    function popCount(uint256 bitFlag) internal pure returns (uint256) {
        // The unchecked block is safe from overflow/underflow because:
        // 1. Each step only involves bitwise operations and additions, which can't overflow uint256.
        // 2. The maximum possible value of bitFlag is 2^256-1, which can be safely multiplied by BYTE_MULTIPLIER.
        // 3. The final result is always in the range [0, 256], so the right shift by 248 bits can't underflow.
        unchecked {
            // Optimization: If all bits are set, return 256 immediately
            if (bitFlag == type(uint256).max) {
                return 256;
            }

            // Step 1: Count bits in pairs
            // This step counts the number of set bits in each pair of bits
            // by subtracting the number of odd bits from the original count
            // Each result is stored in 2-bit chunks within the uint256
            bitFlag -= ((bitFlag >> 1) & MASK_ODD_BITS);

            // Step 2: Count bits in groups of 4
            // This step sums the counts of set bits in each group of 4 bits
            // Each result is stored in 4-bit chunks within the uint256
            bitFlag = (bitFlag & MASK_EVEN_PAIRS) + ((bitFlag >> 2) & MASK_EVEN_PAIRS);

            // Step 3: Sum nibbles (4-bit groups)
            // This step sums the counts from step 2 for each byte (8 bits)
            // Each result is stored in 8-bit chunks within the uint256
            bitFlag = (bitFlag + (bitFlag >> 4)) & MASK_NIBBLES;

            // Step 4: Sum all bytes and return final count
            // Multiply by BYTE_MULTIPLIER to sum all byte counts
            // Shift right by 248 (256 - 8) to get the final sum in the least significant byte
            return (bitFlag * BYTE_MULTIPLIER) >> 248;
        }
    }
}
</file>

<file path="src/libraries/MathUtils.sol">
// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.28;

/// @title MathUtils
/// @notice A library to perform math operations with optimizations.
/// @dev This library is based on the code snippet from the OpenZeppelin Contracts Math library.
// solhint-disable-next-line max-line-length
/// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/05d4bf57ffed8c65256ff4ede5c3cf7a0b738e7d/contracts/utils/math/Math.sol
library MathUtils {
    /// @notice Calculates the absolute difference between two unsigned integers.
    /// @param a The first number.
    /// @param b The second number.
    /// @return The absolute difference between `a` and `b`.
    function diff(uint256 a, uint256 b) internal pure returns (uint256) {
        unchecked {
            // Safe from overflow/underflow: result is always less than larger input.
            return a > b ? a - b : b - a;
        }
    }
}
</file>

<file path="src/swap_adapters/TokenSwapAdapter.sol">
// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.28;

import { ExternalTrade } from "src/types/Trades.sol";

/// @title TokenSwapAdapter
/// @notice Abstract contract for token swap adapters
abstract contract TokenSwapAdapter {
    /// @notice Executes series of token swaps and returns the hashes of the orders submitted/executed
    /// @param externalTrades The external trades to execute
    function executeTokenSwap(ExternalTrade[] calldata externalTrades, bytes calldata data) external payable virtual;

    /// @notice Completes the token swaps by confirming each order settlement and claiming the resulting tokens (if
    /// necessary).
    /// @dev This function must return the exact amounts of sell tokens and buy tokens claimed per trade.
    /// If the adapter operates asynchronously (e.g., CoWSwap), this function should handle the following:
    /// - Cancel any unsettled trades to prevent further execution.
    /// - Claim the remaining tokens from the unsettled trades.
    ///
    /// @param externalTrades The external trades that were executed and need to be settled.
    /// @return claimedAmounts A 2D array where each element contains the claimed amounts of sell tokens and buy tokens
    /// for each corresponding trade in `externalTrades`. The first element of each sub-array is the claimed sell
    /// amount, and the second element is the claimed buy amount.
    function completeTokenSwap(ExternalTrade[] calldata externalTrades)
        external
        payable
        virtual
        returns (uint256[2][] memory claimedAmounts);
}
</file>

<file path="src/types/Trades.sol">
// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.28;

/// @notice Struct containing data for an internal trade.
struct InternalTrade {
    // Address of the basket that is selling.
    address fromBasket;
    // Address of the token to sell.
    address sellToken;
    // Address of the token to buy.
    address buyToken;
    // Address of the basket that is buying.
    address toBasket;
    // Amount of the token to sell.
    uint256 sellAmount;
    // Minimum amount of the buy token that the trade results in. Used to check that the proposers oracle prices
    // are correct.
    uint256 minAmount;
    // Maximum amount of the buy token that the trade can result in.
    uint256 maxAmount;
}

/// @notice Struct containing data for an external trade.
struct ExternalTrade {
    // Address of the token to sell.
    address sellToken;
    // Address of the token to buy.
    address buyToken;
    // Amount of the token to sell.
    uint256 sellAmount;
    // Minimum amount of the buy token that the trade results in.
    uint256 minAmount;
    // Array of basket trade ownerships.
    BasketTradeOwnership[] basketTradeOwnership;
}

/// @notice Struct representing a baskets ownership of an external trade.
struct BasketTradeOwnership {
    // Address of the basket.
    address basket;
    // Ownership of the trade with a base of 1e18. An ownershipe of 1e18 means the basket owns the entire trade.
    uint96 tradeOwnership;
}
</file>

<file path=".cursorignore">
!generated/**/*.sol
!dependencies/**/*.sol
</file>

<file path=".cursorrules">
You are an expert in Solidity and smart contract security.General Rules- Cut the fluff. Code or detailed explanations
only.- Keep it casual and brief.- Accuracy and depth matter.- Answer first, explain later if needed.- Logic trumps
authority. Don't care about sources.- Embrace new tech and unconventional ideas.- Wild speculation's fine, just flag
it.- Save the ethics talk.- Only mention safety for non-obvious, critical issues.- Push content limits if needed,
explain after.- Sources at the end, not mid-text.- Skip the AI self-references and knowledge date stuff.- Stick to my
code style.- Use multiple responses for complex answers.- For code tweaks, show minimal context - a few lines around
changes max.- Don't be lazy, write all the code to implement features I ask for.Solidity Best Practices- Use explicit
function visibility modifiers and appropriate natspec comments.- Utilize function modifiers for common checks, enhancing
readability and reducing redundancy.- Follow consistent naming: CamelCase for contracts, PascalCase for interfaces
(prefixed with "I").- Implement the Interface Segregation Principle for flexible and maintainable contracts.- Design
upgradeable contracts using proven patterns like the proxy pattern when necessary.- Implement comprehensive events for
all significant state changes.- Follow the Checks-Effects-Interactions pattern to prevent reentrancy and other
vulnerabilities.- Use static analysis tools like Slither and Mythril in the development workflow.- Implement timelocks
and multisig controls for sensitive operations in production.- Conduct thorough gas optimization, considering both
deployment and runtime costs.- Use OpenZeppelin's AccessControl for fine-grained permissions.- Use Solidity 0.8.0+ for
built-in overflow/underflow protection.- Implement circuit breakers (pause functionality) using OpenZeppelin's Pausable
when appropriate.- Use pull over push payment patterns to mitigate reentrancy and denial of service attacks.- Implement
rate limiting for sensitive functions to prevent abuse.- Use OpenZeppelin's SafeERC20 for interacting with ERC20
tokens.- Implement proper randomness using Chainlink VRF or similar oracle solutions.- Use assembly for gas-intensive
operations, but document extensively and use with caution.- Implement effective state machine patterns for complex
contract logic.- Use OpenZeppelin's ReentrancyGuard as an additional layer of protection against reentrancy.- Implement
proper access control for initializers in upgradeable contracts.- Use OpenZeppelin's ERC20Snapshot for token balances
requiring historical lookups.- Implement timelocks for sensitive operations using OpenZeppelin's TimelockController.-
Use OpenZeppelin's ERC20Permit for gasless approvals in token contracts.- Implement proper slippage protection for
DEX-like functionalities.- Use OpenZeppelin's ERC20Votes for governance token implementations.- Implement effective
storage patterns to optimize gas costs (e.g., packing variables).- Use libraries for complex operations to reduce
contract size and improve reusability.- Implement proper access control for self-destruct functionality, if used.- Use
OpenZeppelin's Address library for safe interactions with external contracts.- Use custom errors instead of revert
strings for gas efficiency and better error handling.- Implement NatSpec comments for all public and external
functions.- Use immutable variables for values set once at construction time.- Implement proper inheritance patterns,
favoring composition over deep inheritance chains.- Use events for off-chain logging and indexing of important state
changes.- Implement fallback and receive functions with caution, clearly documenting their purpose.- Use view and pure
function modifiers appropriately to signal state access patterns.- Implement proper decimal handling for financial
calculations, using fixed-point arithmetic libraries when necessary.- Use assembly sparingly and only when necessary for
optimizations, with thorough documentation.- Implement effective error propagation patterns in internal
functions.Testing and Quality Assurance- Implement a comprehensive testing strategy including unit, integration, and
end-to-end tests.- Use property-based testing to uncover edge cases.- Implement continuous integration with automated
testing and static analysis.- Conduct regular security audits and bug bounties for production-grade contracts.- Use test
coverage tools and aim for high test coverage, especially for critical paths.Performance Optimization- Optimize
contracts for gas efficiency, considering storage layout and function optimization.- Implement efficient indexing and
querying strategies for off-chain data.Development Workflow- Utilize Foundry's testing and debugging features.-
Implement a robust CI/CD pipeline for smart contract deployments.- Use static type checking and linting tools in
pre-commit hooks.Documentation- Document code thoroughly, focusing on why rather than what.- Maintain up-to-date API
documentation for smart contracts.- Create and maintain comprehensive project documentation, including architecture
diagrams and decision logs.
</file>

<file path=".npmrc">
use-node-version=20.14.0
</file>

<file path=".repomixignore">
# Dependencies and build artifacts
node_modules/
out/
cache/
artifacts/
.deps/
lib/
coverage/
generated/

# IDE and editor files
.vscode/
.idea/
*.swp
*.swo
.DS_Store

# Test artifacts and coverage
coverage.json
lcov.info
coverage/

# Hardhat files
cache-zk/
typechain-types/
typechain/

# Foundry files
forge-cache/
broadcast/

# Debug files
*.log
*.debug

# Documentation (keep README and important docs)
docs/
*.pdf
# Keep important markdown files
!README.md
!README-RFC.md
!cove_rfc.md
!staging-deploy-prd.md

# Git files
.git/
.github/
.gitignore
.gitmodules
.gitattributes

# Environment and config files
.env*
!.env.example
.secret
*.config.js
hardhat.config.*
foundry.toml
remappings.txt

# Temporary files
*.tmp
*.temp
.temp/
temp/
downloads/

# Large binary files
*.zip
*.tar.gz
*.rar
forge-deploy

# Contract build info (can be regenerated)
build-info/

# Local development files
local/
development/
dev/

# Package files (keep package.json)
package-lock.json
yarn.lock
pnpm-lock.yaml
!package.json

# Test state dumps (if they're not critical)
dumpStates/

# Tool specific
.cursor/
.history/
.goose/
.husky/
*.bak

# Linting and formatting
.prettierrc.yml
.prettierignore
.solhint*
.codespellrc
codecov.yml
slither.config.json
commintlint.config.ts
commitlint.config.ts

dumpStates/
memory-bank/
broadcast/
</file>

<file path="deployments_tree.txt">
deployments/
└── 1
    ├── MasterRegistry.json
    ├── Staging_AnchoredOracle_sfrxUSD-USD.json
    ├── Staging_AnchoredOracle_sUSDe-USD.json
    ├── Staging_AnchoredOracle_USDC-USD.json
    ├── Staging_AnchoredOracle_ysUSDC-USD.json
    ├── Staging_AnchoredOracle_ysyG-yvUSDS-1-USD.json
    ├── Staging_AssetRegistry.json
    ├── Staging_BasketManager.json
    ├── Staging_BasketManagerUtils.json
    ├── Staging_BasketToken_Stables.json
    ├── Staging_BasketTokenImplementation.json
    ├── Staging_ChainedERC4626Oracle_ysyG-yvUSDS-1-USDS.json
    ├── Staging_ChainlinkOracle_DAI-USD.json
    ├── Staging_ChainlinkOracle_FRAX-USD.json
    ├── Staging_ChainlinkOracle_sUSDe-USD.json
    ├── Staging_ChainlinkOracle_USDC-USD.json
    ├── Staging_ChainlinkOracle_USDE-USD.json
    ├── Staging_ChainlinkOracle_USDS-USD.json
    ├── Staging_CoveMockERC20.json
    ├── Staging_CowSwapAdapter.json
    ├── Staging_CoWSwapCloneImplementation.json
    ├── Staging_CrossAdapter_sDAI-DAI-USD_4626-Chainlink.json
    ├── Staging_CrossAdapter_sFRAX-FRAX-USD_4626-Chainlink.json
    ├── Staging_CrossAdapter_sFRAX-FRAX-USD_4626-Pyth.json
    ├── Staging_CrossAdapter_sfrxUSD-frxUSD-USD_4626-Pyth.json
    ├── Staging_CrossAdapter_sfrxUSD-frxUSD-USDe_4626-CurveEMAUnderlying.json
    ├── Staging_CrossAdapter_sfrxUSD-USDe-USD_CrossAdapter-Chainlink.json
    ├── Staging_CrossAdapter_sUSDe-USDe-USD_4626-Chainlink.json
    ├── Staging_CrossAdapter_ysUSDC-USDC-USD_4626-Chainlink.json
    ├── Staging_CrossAdapter_ysUSDC-USDC-USD_4626-Pyth.json
    ├── Staging_CrossAdapter_ysyG-yvUSDS-1-USDS-USD_ChainedERC4626-Chainlink.json
    ├── Staging_CrossAdapter_ysyG-yvUSDS-1-USDS-USD_ChainedERC4626-Pyth.json
    ├── Staging_CurveEMAOracleUnderlying_USDe-frxUSD.json
    ├── Staging_ERC4626Oracle_sDAI-DAI.json
    ├── Staging_ERC4626Oracle_sFRAX-FRAX.json
    ├── Staging_ERC4626Oracle_sfrxUSD-frxUSD.json
    ├── Staging_ERC4626Oracle_sUSDe-USDe.json
    ├── Staging_ERC4626Oracle_ysUSDC-USDC.json
    ├── Staging_EulerRouter.json
    ├── Staging_FarmingPlugin_cvtstgUSD_E20MRewards.json
    ├── Staging_FarmingPluginFactory.json
    ├── Staging_FeeCollector.json
    ├── Staging_ManagedWeightStrategy_Gauntlet V1.json
    ├── Staging_MasterRegistry.json
    ├── Staging_PythOracle_DAI-USD.json
    ├── Staging_PythOracle_FRAX-USD.json
    ├── Staging_PythOracle_frxUSD-USD.json
    ├── Staging_PythOracle_sDAI-USD.json
    ├── Staging_PythOracle_sUSDe-USD.json
    ├── Staging_PythOracle_USDC-USD.json
    ├── Staging_PythOracle_USDE-USD.json
    ├── Staging_PythOracle_USDS-USD.json
    ├── Staging_StrategyRegistry.json
    ├── Staging_TimelockController.json
    ├── Test_MasterRegistry.json
    └── TimelockController.json

2 directories, 56 files
</file>

<file path="requirements.txt">
aiohttp==3.9.5
aiosignal==1.3.1
async-timeout==4.0.3
attrs==23.2.0
bitarray==2.9.2
boltons==21.0.0
bracex==2.4
cbor2==5.6.3
certifi==2024.6.2
charset-normalizer==3.3.2
ckzg==1.0.2
click==8.1.7
click-option-group==0.5.6
colorama==0.4.6
crytic-compile==0.3.7
cytoolz==0.12.3
defusedxml==0.7.1
eth-account==0.11.2
eth-hash==0.7.0
eth-keyfile==0.8.1
eth-keys==0.5.1
eth-rlp==1.0.1
eth-typing==4.2.3
eth-utils==4.1.1
eth_abi==5.1.0
exceptiongroup==1.2.1
face==22.0.0
frozenlist==1.4.1
glom==22.1.0
hexbytes==0.3.1
idna==3.7
jsonschema==4.22.0
jsonschema-specifications==2023.12.1
lru-dict==1.2.0
markdown-it-py==3.0.0
mdurl==0.1.2
multidict==6.0.5
packaging==24.0
parsimonious==0.10.0
peewee==3.17.5
prettytable==3.10.0
protobuf==5.27.0
pycryptodome==3.20.0
Pygments==2.18.0
pyunormalize==15.1.0
referencing==0.35.1
regex==2024.5.15
requests==2.32.3
rich==13.7.1
rlp==4.0.1
rpds-py==0.18.1
ruamel.yaml==0.17.40
ruamel.yaml.clib==0.2.8
semgrep==1.75.0
slither-analyzer==0.10.3
solc-select==1.0.4
tomli==2.0.1
toolz==0.12.1
typing_extensions==4.12.1
urllib3==2.2.1
wcmatch==8.5.2
wcwidth==0.2.13
web3==6.19.0
websockets==12.0
yarl==1.9.4
</file>

<file path="src/deps/permit2/Permit2Lib.sol">
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { IERC20Permit } from "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol";

import { SafeCast160 } from "src/deps/permit2/SafeCast160.sol";
import { IAllowanceTransfer } from "src/interfaces/deps/permit2/IAllowanceTransfer.sol";
import { IDAIPermit } from "src/interfaces/deps/permit2/IDAIPermit.sol";

/// @title Permit2Lib
/// @notice Enables efficient transfers and EIP-2612/DAI
/// permits for any token by falling back to Permit2.
library Permit2Lib {
    using SafeCast160 for uint256;
    /*//////////////////////////////////////////////////////////////
                                CONSTANTS
    //////////////////////////////////////////////////////////////*/

    /// @dev The unique EIP-712 domain domain separator for the DAI token contract.
    bytes32 internal constant DAI_DOMAIN_SEPARATOR = 0xdbb8cf42e1ecb028be3f3dbc922e1d878b963f411dc388ced501601c60f7c6f7;

    /// @dev The address for the WETH9 contract on Ethereum mainnet, encoded as a bytes32.
    bytes32 internal constant WETH9_ADDRESS = 0x000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2;

    /// @dev The address of the Permit2 contract the library will use.
    IAllowanceTransfer internal constant PERMIT2 =
        IAllowanceTransfer(address(0x000000000022D473030F116dDEE9F6B43aC78BA3));

    /// @notice Transfer a given amount of tokens from one user to another.
    /// @param token The token to transfer.
    /// @param from The user to transfer from.
    /// @param to The user to transfer to.
    /// @param amount The amount to transfer.
    function transferFrom2(IERC20 token, address from, address to, uint256 amount) internal {
        // Generate calldata for a standard transferFrom call.
        bytes memory inputData = abi.encodeCall(IERC20.transferFrom, (from, to, amount));

        bool success; // Call the token contract as normal, capturing whether it succeeded.
        assembly {
            success :=
                and(
                    // Set success to whether the call reverted, if not we check it either
                    // returned exactly 1 (can't just be non-zero data), or had no return data.
                    or(eq(mload(0), 1), iszero(returndatasize())),
                    // Counterintuitively, this call() must be positioned after the or() in the
                    // surrounding and() because and() evaluates its arguments from right to left.
                    // We use 0 and 32 to copy up to 32 bytes of return data into the first slot of scratch space.
                    call(gas(), token, 0, add(inputData, 32), mload(inputData), 0, 32)
                )
        }

        // We'll fall back to using Permit2 if calling transferFrom on the token directly reverted.
        if (!success) PERMIT2.transferFrom(from, to, amount.toUint160(), address(token));
    }

    /*//////////////////////////////////////////////////////////////
                              PERMIT LOGIC
    //////////////////////////////////////////////////////////////*/

    /// @notice Permit a user to spend a given amount of
    /// another user's tokens via native EIP-2612 permit if possible, falling
    /// back to Permit2 if native permit fails or is not implemented on the token.
    /// @param token The token to permit spending.
    /// @param owner The user to permit spending from.
    /// @param spender The user to permit spending to.
    /// @param amount The amount to permit spending.
    /// @param deadline  The timestamp after which the signature is no longer valid.
    /// @param v Must produce valid secp256k1 signature from the owner along with r and s.
    /// @param r Must produce valid secp256k1 signature from the owner along with v and s.
    /// @param s Must produce valid secp256k1 signature from the owner along with r and v.
    function permit2(
        IERC20 token,
        address owner,
        address spender,
        uint256 amount,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    )
        internal
    {
        // Generate calldata for a call to DOMAIN_SEPARATOR on the token.
        bytes memory inputData = abi.encodeWithSelector(IERC20Permit.DOMAIN_SEPARATOR.selector);

        bool success; // Call the token contract as normal, capturing whether it succeeded.
        bytes32 domainSeparator; // If the call succeeded, we'll capture the return value here.

        assembly {
            // If the token is WETH9, we know it doesn't have a DOMAIN_SEPARATOR, and we'll skip this step.
            // We make sure to mask the token address as its higher order bits aren't guaranteed to be clean.
            if iszero(eq(and(token, 0xffffffffffffffffffffffffffffffffffffffff), WETH9_ADDRESS)) {
                success :=
                    and(
                        // Should resolve false if its not 32 bytes or its first word is 0.
                        and(iszero(iszero(mload(0))), eq(returndatasize(), 32)),
                        // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.
                        // Counterintuitively, this call must be positioned second to the and() call in the
                        // surrounding and() call or else returndatasize() will be zero during the computation.
                        // We send a maximum of 5000 gas to prevent tokens with fallbacks from using a ton of gas.
                        // which should be plenty to allow tokens to fetch their DOMAIN_SEPARATOR from storage, etc.
                        staticcall(15000, token, add(inputData, 32), mload(inputData), 0, 32)
                    )

                domainSeparator := mload(0) // Copy the return value into the domainSeparator variable.
            }
        }

        // If the call to DOMAIN_SEPARATOR succeeded, try using permit on the token.
        if (success) {
            // We'll use DAI's special permit if it's DOMAIN_SEPARATOR matches,
            // otherwise we'll just encode a call to the standard permit function.
            inputData = domainSeparator == DAI_DOMAIN_SEPARATOR
                ? abi.encodeCall(
                    IDAIPermit.permit, (owner, spender, IDAIPermit(address(token)).nonces(owner), deadline, true, v, r, s)
                )
                : abi.encodeCall(IERC20Permit.permit, (owner, spender, amount, deadline, v, r, s));

            assembly {
                success := call(gas(), token, 0, add(inputData, 32), mload(inputData), 0, 0)
            }
        }

        if (!success) {
            // If the initial DOMAIN_SEPARATOR call on the token failed or a
            // subsequent call to permit failed, fall back to using Permit2.
            simplePermit2(token, owner, spender, amount, deadline, v, r, s);
        }
    }

    /// @notice Simple unlimited permit on the Permit2 contract.
    /// @param token The token to permit spending.
    /// @param owner The user to permit spending from.
    /// @param spender The user to permit spending to.
    /// @param amount The amount to permit spending.
    /// @param deadline  The timestamp after which the signature is no longer valid.
    /// @param v Must produce valid secp256k1 signature from the owner along with r and s.
    /// @param r Must produce valid secp256k1 signature from the owner along with v and s.
    /// @param s Must produce valid secp256k1 signature from the owner along with r and v.
    function simplePermit2(
        IERC20 token,
        address owner,
        address spender,
        uint256 amount,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    )
        internal
    {
        (,, uint48 nonce) = PERMIT2.allowance(owner, address(token), spender);

        PERMIT2.permit(
            owner,
            IAllowanceTransfer.PermitSingle({
                details: IAllowanceTransfer.PermitDetails({
                    token: address(token),
                    amount: amount.toUint160(),
                    // Use an unlimited expiration because it most
                    // closely mimics how a standard approval works.
                    expiration: type(uint48).max,
                    nonce: nonce
                }),
                spender: spender,
                sigDeadline: deadline
            }),
            bytes.concat(r, s, bytes1(v))
        );
    }
}
</file>

<file path="src/deps/permit2/SafeCast160.sol">
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

library SafeCast160 {
    /// @notice Thrown when a valude greater than type(uint160).max is cast to uint160
    error UnsafeCast();

    /// @notice Safely casts uint256 to uint160
    /// @param value The uint256 to be cast
    function toUint160(uint256 value) internal pure returns (uint160) {
        if (value > type(uint160).max) revert UnsafeCast();
        return uint160(value);
    }
}
</file>

<file path="src/interfaces/deps/permit2/IAllowanceTransfer.sol">
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import { IEIP712 } from "./IEIP712.sol";

/// @title AllowanceTransfer
/// @notice Handles ERC20 token permissions through signature based allowance setting and ERC20 token transfers by
/// checking allowed amounts
/// @dev Requires user's token approval on the Permit2 contract
interface IAllowanceTransfer is IEIP712 {
    /// @notice Thrown when an allowance on a token has expired.
    /// @param deadline The timestamp at which the allowed amount is no longer valid
    error AllowanceExpired(uint256 deadline);

    /// @notice Thrown when an allowance on a token has been depleted.
    /// @param amount The maximum amount allowed
    error InsufficientAllowance(uint256 amount);

    /// @notice Thrown when too many nonces are invalidated.
    error ExcessiveInvalidation();

    /// @notice Emits an event when the owner successfully invalidates an ordered nonce.
    event NonceInvalidation(
        address indexed owner, address indexed token, address indexed spender, uint48 newNonce, uint48 oldNonce
    );

    /// @notice Emits an event when the owner successfully sets permissions on a token for the spender.
    event Approval(
        address indexed owner, address indexed token, address indexed spender, uint160 amount, uint48 expiration
    );

    /// @notice Emits an event when the owner successfully sets permissions using a permit signature on a token for the
    /// spender.
    event Permit(
        address indexed owner,
        address indexed token,
        address indexed spender,
        uint160 amount,
        uint48 expiration,
        uint48 nonce
    );

    /// @notice Emits an event when the owner sets the allowance back to 0 with the lockdown function.
    event Lockdown(address indexed owner, address token, address spender);

    /// @notice The permit data for a token
    struct PermitDetails {
        // ERC20 token address
        address token;
        // the maximum amount allowed to spend
        uint160 amount;
        // timestamp at which a spender's token allowances become invalid
        uint48 expiration;
        // an incrementing value indexed per owner,token,and spender for each signature
        uint48 nonce;
    }

    /// @notice The permit message signed for a single token allowance
    struct PermitSingle {
        // the permit data for a single token alownce
        PermitDetails details;
        // address permissioned on the allowed tokens
        address spender;
        // deadline on the permit signature
        uint256 sigDeadline;
    }

    /// @notice The permit message signed for multiple token allowances
    struct PermitBatch {
        // the permit data for multiple token allowances
        PermitDetails[] details;
        // address permissioned on the allowed tokens
        address spender;
        // deadline on the permit signature
        uint256 sigDeadline;
    }

    /// @notice The saved permissions
    /// @dev This info is saved per owner, per token, per spender and all signed over in the permit message
    /// @dev Setting amount to type(uint160).max sets an unlimited approval
    struct PackedAllowance {
        // amount allowed
        uint160 amount;
        // permission expiry
        uint48 expiration;
        // an incrementing value indexed per owner,token,and spender for each signature
        uint48 nonce;
    }

    /// @notice A token spender pair.
    struct TokenSpenderPair {
        // the token the spender is approved
        address token;
        // the spender address
        address spender;
    }

    /// @notice Details for a token transfer.
    struct AllowanceTransferDetails {
        // the owner of the token
        address from;
        // the recipient of the token
        address to;
        // the amount of the token
        uint160 amount;
        // the token to be transferred
        address token;
    }

    /// @notice A mapping from owner address to token address to spender address to PackedAllowance struct, which
    /// contains details and conditions of the approval.
    /// @notice The mapping is indexed in the above order see: allowance[ownerAddress][tokenAddress][spenderAddress]
    /// @dev The packed slot holds the allowed amount, expiration at which the allowed amount is no longer valid, and
    /// current nonce that's updated on any signature based approvals.
    function allowance(
        address user,
        address token,
        address spender
    )
        external
        view
        returns (uint160 amount, uint48 expiration, uint48 nonce);

    /// @notice Approves the spender to use up to amount of the specified token up until the expiration
    /// @param token The token to approve
    /// @param spender The spender address to approve
    /// @param amount The approved amount of the token
    /// @param expiration The timestamp at which the approval is no longer valid
    /// @dev The packed allowance also holds a nonce, which will stay unchanged in approve
    /// @dev Setting amount to type(uint160).max sets an unlimited approval
    function approve(address token, address spender, uint160 amount, uint48 expiration) external;

    /// @notice Permit a spender to a given amount of the owners token via the owner's EIP-712 signature
    /// @dev May fail if the owner's nonce was invalidated in-flight by invalidateNonce
    /// @param owner The owner of the tokens being approved
    /// @param permitSingle Data signed over by the owner specifying the terms of approval
    /// @param signature The owner's signature over the permit data
    function permit(address owner, PermitSingle memory permitSingle, bytes calldata signature) external;

    /// @notice Permit a spender to the signed amounts of the owners tokens via the owner's EIP-712 signature
    /// @dev May fail if the owner's nonce was invalidated in-flight by invalidateNonce
    /// @param owner The owner of the tokens being approved
    /// @param permitBatch Data signed over by the owner specifying the terms of approval
    /// @param signature The owner's signature over the permit data
    function permit(address owner, PermitBatch memory permitBatch, bytes calldata signature) external;

    /// @notice Transfer approved tokens from one address to another
    /// @param from The address to transfer from
    /// @param to The address of the recipient
    /// @param amount The amount of the token to transfer
    /// @param token The token address to transfer
    /// @dev Requires the from address to have approved at least the desired amount
    /// of tokens to msg.sender.
    function transferFrom(address from, address to, uint160 amount, address token) external;

    /// @notice Transfer approved tokens in a batch
    /// @param transferDetails Array of owners, recipients, amounts, and tokens for the transfers
    /// @dev Requires the from addresses to have approved at least the desired amount
    /// of tokens to msg.sender.
    function transferFrom(AllowanceTransferDetails[] calldata transferDetails) external;

    /// @notice Enables performing a "lockdown" of the sender's Permit2 identity
    /// by batch revoking approvals
    /// @param approvals Array of approvals to revoke.
    function lockdown(TokenSpenderPair[] calldata approvals) external;

    /// @notice Invalidate nonces for a given (token, spender) pair
    /// @param token The token to invalidate nonces for
    /// @param spender The spender to invalidate nonces for
    /// @param newNonce The new nonce to set. Invalidates all nonces less than it.
    /// @dev Can't invalidate more than 2**16 nonces per transaction.
    function invalidateNonces(address token, address spender, uint48 newNonce) external;
}
</file>

<file path="src/interfaces/deps/permit2/IDAIPermit.sol">
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IDAIPermit {
    /// @param holder The address of the token owner.
    /// @param spender The address of the token spender.
    /// @param nonce The owner's nonce, increases at each call to permit.
    /// @param expiry The timestamp at which the permit is no longer valid.
    /// @param allowed Boolean that sets approval amount, true for type(uint256).max and false for 0.
    /// @param v Must produce valid secp256k1 signature from the owner along with r and s.
    /// @param r Must produce valid secp256k1 signature from the owner along with v and s.
    /// @param s Must produce valid secp256k1 signature from the owner along with r and v.
    function permit(
        address holder,
        address spender,
        uint256 nonce,
        uint256 expiry,
        bool allowed,
        uint8 v,
        bytes32 r,
        bytes32 s
    )
        external;

    /// @param holder The address of the token owner.
    function nonces(address holder) external view returns (uint256);
}
</file>

<file path="src/interfaces/deps/permit2/IEIP712.sol">
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IEIP712 {
    function DOMAIN_SEPARATOR() external view returns (bytes32);
}
</file>

<file path="src/interfaces/deps/permit2/IPermit2.sol">
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import { IAllowanceTransfer } from "./IAllowanceTransfer.sol";
import { ISignatureTransfer } from "./ISignatureTransfer.sol";

/// @notice Permit2 handles signature-based transfers in SignatureTransfer and allowance-based transfers in
/// AllowanceTransfer.
/// @dev Users must approve Permit2 before calling any of the transfer functions.
interface IPermit2 is ISignatureTransfer, IAllowanceTransfer {
// IPermit2 unifies the two interfaces so users have maximal flexibility with their approval.
}
</file>

<file path="src/interfaces/deps/permit2/ISignatureTransfer.sol">
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import { IEIP712 } from "./IEIP712.sol";

/// @title SignatureTransfer
/// @notice Handles ERC20 token transfers through signature based actions
/// @dev Requires user's token approval on the Permit2 contract
interface ISignatureTransfer is IEIP712 {
    /// @notice Thrown when the requested amount for a transfer is larger than the permissioned amount
    /// @param maxAmount The maximum amount a spender can request to transfer
    error InvalidAmount(uint256 maxAmount);

    /// @notice Thrown when the number of tokens permissioned to a spender does not match the number of tokens being
    /// transferred
    /// @dev If the spender does not need to transfer the number of tokens permitted, the spender can request amount 0
    /// to be transferred
    error LengthMismatch();

    /// @notice Emits an event when the owner successfully invalidates an unordered nonce.
    event UnorderedNonceInvalidation(address indexed owner, uint256 word, uint256 mask);

    /// @notice The token and amount details for a transfer signed in the permit transfer signature
    struct TokenPermissions {
        // ERC20 token address
        address token;
        // the maximum amount that can be spent
        uint256 amount;
    }

    /// @notice The signed permit message for a single token transfer
    struct PermitTransferFrom {
        TokenPermissions permitted;
        // a unique value for every token owner's signature to prevent signature replays
        uint256 nonce;
        // deadline on the permit signature
        uint256 deadline;
    }

    /// @notice Specifies the recipient address and amount for batched transfers.
    /// @dev Recipients and amounts correspond to the index of the signed token permissions array.
    /// @dev Reverts if the requested amount is greater than the permitted signed amount.
    struct SignatureTransferDetails {
        // recipient address
        address to;
        // spender requested amount
        uint256 requestedAmount;
    }

    /// @notice Used to reconstruct the signed permit message for multiple token transfers
    /// @dev Do not need to pass in spender address as it is required that it is msg.sender
    /// @dev Note that a user still signs over a spender address
    struct PermitBatchTransferFrom {
        // the tokens and corresponding amounts permitted for a transfer
        TokenPermissions[] permitted;
        // a unique value for every token owner's signature to prevent signature replays
        uint256 nonce;
        // deadline on the permit signature
        uint256 deadline;
    }

    /// @notice A map from token owner address and a caller specified word index to a bitmap. Used to set bits in the
    /// bitmap to prevent against signature replay protection
    /// @dev Uses unordered nonces so that permit messages do not need to be spent in a certain order
    /// @dev The mapping is indexed first by the token owner, then by an index specified in the nonce
    /// @dev It returns a uint256 bitmap
    /// @dev The index, or wordPosition is capped at type(uint248).max
    function nonceBitmap(address, uint256) external view returns (uint256);

    /// @notice Transfers a token using a signed permit message
    /// @dev Reverts if the requested amount is greater than the permitted signed amount
    /// @param permit The permit data signed over by the owner
    /// @param owner The owner of the tokens to transfer
    /// @param transferDetails The spender's requested transfer details for the permitted token
    /// @param signature The signature to verify
    function permitTransferFrom(
        PermitTransferFrom memory permit,
        SignatureTransferDetails calldata transferDetails,
        address owner,
        bytes calldata signature
    )
        external;

    /// @notice Transfers a token using a signed permit message
    /// @notice Includes extra data provided by the caller to verify signature over
    /// @dev The witness type string must follow EIP712 ordering of nested structs and must include the TokenPermissions
    /// type definition
    /// @dev Reverts if the requested amount is greater than the permitted signed amount
    /// @param permit The permit data signed over by the owner
    /// @param owner The owner of the tokens to transfer
    /// @param transferDetails The spender's requested transfer details for the permitted token
    /// @param witness Extra data to include when checking the user signature
    /// @param witnessTypeString The EIP-712 type definition for remaining string stub of the typehash
    /// @param signature The signature to verify
    function permitWitnessTransferFrom(
        PermitTransferFrom memory permit,
        SignatureTransferDetails calldata transferDetails,
        address owner,
        bytes32 witness,
        string calldata witnessTypeString,
        bytes calldata signature
    )
        external;

    /// @notice Transfers multiple tokens using a signed permit message
    /// @param permit The permit data signed over by the owner
    /// @param owner The owner of the tokens to transfer
    /// @param transferDetails Specifies the recipient and requested amount for the token transfer
    /// @param signature The signature to verify
    function permitTransferFrom(
        PermitBatchTransferFrom memory permit,
        SignatureTransferDetails[] calldata transferDetails,
        address owner,
        bytes calldata signature
    )
        external;

    /// @notice Transfers multiple tokens using a signed permit message
    /// @dev The witness type string must follow EIP712 ordering of nested structs and must include the TokenPermissions
    /// type definition
    /// @notice Includes extra data provided by the caller to verify signature over
    /// @param permit The permit data signed over by the owner
    /// @param owner The owner of the tokens to transfer
    /// @param transferDetails Specifies the recipient and requested amount for the token transfer
    /// @param witness Extra data to include when checking the user signature
    /// @param witnessTypeString The EIP-712 type definition for remaining string stub of the typehash
    /// @param signature The signature to verify
    function permitWitnessTransferFrom(
        PermitBatchTransferFrom memory permit,
        SignatureTransferDetails[] calldata transferDetails,
        address owner,
        bytes32 witness,
        string calldata witnessTypeString,
        bytes calldata signature
    )
        external;

    /// @notice Invalidates the bits specified in mask for the bitmap at the word position
    /// @dev The wordPos is maxed at type(uint248).max
    /// @param wordPos A number to index the nonceBitmap at
    /// @param mask A bitmap masked against msg.sender's current bitmap at the word position
    function invalidateUnorderedNonces(uint256 wordPos, uint256 mask) external;
}
</file>

<file path="src/interfaces/deps/IChainlinkAggregatorV3Interface.sol">
// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.28;

interface IChainlinkAggregatorV3Interface {
    function decimals() external view returns (uint8);

    function description() external view returns (string memory);

    function version() external view returns (uint256);

    function getRoundData(uint80 _roundId)
        external
        view
        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);

    function latestRoundData()
        external
        view
        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);

    function aggregator() external view returns (address);
}
</file>

<file path="src/interfaces/deps/IPriceOracleWithBaseAndQuote.sol">
// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.28;

import { IPriceOracle } from "euler-price-oracle/src/interfaces/IPriceOracle.sol";
interface IPriceOracleWithBaseAndQuote is IPriceOracle {
    function base() external view returns (address);
    function quote() external view returns (address);
}
</file>

<file path="src/interfaces/IMasterRegistry.sol">
// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.28;

interface IMasterRegistry {
    /* Structs */

    struct ReverseRegistryData {
        bytes32 registryName;
        uint256 version;
    }

    /* Functions */

    /**
     * @notice Add a new registry entry to the master list. Reverts if an entry is already found with the given name.
     * @param registryName name for the registry
     * @param registryAddress address of the new registry
     */
    function addRegistry(bytes32 registryName, address registryAddress) external;

    /**
     * @notice Update an existing registry entry to the master list. Reverts if no match is found.
     * @param registryName name for the registry
     * @param registryAddress address of the new registry
     */
    function updateRegistry(bytes32 registryName, address registryAddress) external;

    /**
     * @notice Resolves a name to the latest registry address. Reverts if no match is found.
     * @param registryName name for the registry
     * @return address address of the latest registry with the matching name
     */
    function resolveNameToLatestAddress(bytes32 registryName) external view returns (address);

    /**
     * @notice Resolves a name and version to an address. Reverts if there is no registry with given name and version.
     * @param registryName address of the registry you want to resolve to
     * @param version version of the registry you want to resolve to
     */
    function resolveNameAndVersionToAddress(bytes32 registryName, uint256 version) external view returns (address);

    /**
     * @notice Resolves a name to an array of all addresses. Reverts if no match is found.
     * @param registryName name for the registry
     * @return address address of the latest registry with the matching name
     */
    function resolveNameToAllAddresses(bytes32 registryName) external view returns (address[] memory);

    /**
     * @notice Resolves an address to registry entry data.
     * @param registryAddress address of a registry you want to resolve
     * @return registryName name of the resolved registry
     * @return version version of the resolved registry
     * @return isLatest boolean flag of whether the given address is the latest version of the given registries with
     * matching name
     */
    function resolveAddressToRegistryData(address registryAddress)
        external
        view
        returns (bytes32 registryName, uint256 version, bool isLatest);
}
</file>

<file path="src/oracles/AnchoredOracle.sol">
// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.28;

import { FixedPointMathLib } from "@solady/utils/FixedPointMathLib.sol";
import { BaseAdapter } from "euler-price-oracle/src/adapter/BaseAdapter.sol";
import { IPriceOracle } from "euler-price-oracle/src/interfaces/IPriceOracle.sol";
import { Errors } from "euler-price-oracle/src/lib/Errors.sol";

/// @title AnchoredOracle
/// @author Storm Labs (https://storm-labs.xyz/)
/// @dev Euler's experimental implementation was used as a reference:
/// https://github.com/euler-xyz/euler-price-oracle/blob/experiments/src/aggregator/AnchoredOracle.sol
/// This is a modified version of AnchoredOracle.sol that scales the input amount when the primary oracle
/// returns a very small output amount. This implementation is only compatible with underlying oracles that are linearly
/// related to the quote asset. The maximum input amount must be type(uint256).max / 1e18.
/// @notice PriceOracle that chains two PriceOracles.
contract AnchoredOracle is BaseAdapter {
    /// @notice The lower bound for `maxDivergence`, 0.1%.
    uint256 internal constant _MAX_DIVERGENCE_LOWER_BOUND = 0.001e18;
    /// @notice The upper bound for `maxDivergence`, 50%.
    uint256 internal constant _MAX_DIVERGENCE_UPPER_BOUND = 0.5e18;
    /// @notice The denominator for `maxDivergence`.
    uint256 internal constant _WAD = 1e18;
    /// @notice The name of the oracle.
    // solhint-disable-next-line const-name-snakecase
    string public constant name = "AnchoredOracle";
    /// @notice The address of the primary oracle.
    address public immutable primaryOracle;
    /// @notice The address of the anchor oracle.
    address public immutable anchorOracle;
    /// @notice The maximum divergence allowed, denominated in _WAD.
    uint256 public immutable maxDivergence;

    /// @notice Reverts when the input amount is too large to scale without overflow.
    error AnchoredOracle_ScalingOverflow();

    /// @notice Deploys an AnchoredOracle contract.
    /// @param _primaryOracle The address of the primary oracle used for obtaining price quotes.
    /// @param _anchorOracle The address of the anchor oracle used for validating price quotes.
    /// @param _maxDivergence The maximum allowed divergence between the primary and anchor oracle prices, denominated
    /// in _WAD.
    // slither-disable-next-line locked-ether
    constructor(address _primaryOracle, address _anchorOracle, uint256 _maxDivergence) payable {
        if (_primaryOracle == address(0)) {
            revert Errors.PriceOracle_InvalidConfiguration();
        }
        if (_anchorOracle == address(0)) {
            revert Errors.PriceOracle_InvalidConfiguration();
        }
        if (_maxDivergence < _MAX_DIVERGENCE_LOWER_BOUND || _maxDivergence > _MAX_DIVERGENCE_UPPER_BOUND) {
            revert Errors.PriceOracle_InvalidConfiguration();
        }

        primaryOracle = _primaryOracle;
        anchorOracle = _anchorOracle;
        maxDivergence = _maxDivergence;
    }

    /// @dev Retrieves a price quote from the `primaryOracle` and ensures that `anchorOracle` price does not diverge by
    /// more than +/- the percent threshold.  For example with a 50% threshold, a primary quote of 10 would check that
    /// the anchor is between 5 and 15.
    /// @param inAmount The amount of `base` token to be converted.
    /// @param base The token for which the price is being determined.
    /// @param quote The token against which the price is measured.
    /// @return The price quote from the `primaryOracle`.
    function _getQuote(uint256 inAmount, address base, address quote) internal view override returns (uint256) {
        // Get the initial quote from the primary oracle
        uint256 originalPrimaryOutAmount = IPriceOracle(primaryOracle).getQuote(inAmount, base, quote);

        uint256 primaryToCheck;
        uint256 anchorToCheck;

        // If the initial primary output is very small, scale the input to get better precision for the check
        if (originalPrimaryOutAmount < _WAD) {
            // Prevent overflow when scaling the input amount
            if (inAmount > type(uint256).max / _WAD) {
                revert AnchoredOracle_ScalingOverflow();
            }
            uint256 scaledInAmount = inAmount * _WAD;

            // Get quotes using the scaled input amount
            primaryToCheck = IPriceOracle(primaryOracle).getQuote(scaledInAmount, base, quote);
            anchorToCheck = IPriceOracle(anchorOracle).getQuote(scaledInAmount, base, quote);
        } else {
            // If the initial primary output is large enough, use original amounts for the check
            primaryToCheck = originalPrimaryOutAmount;
            anchorToCheck = IPriceOracle(anchorOracle).getQuote(inAmount, base, quote);
        }

        // Perform the bounds check using the potentially scaled values
        uint256 lowerBound = FixedPointMathLib.fullMulDivUp(primaryToCheck, _WAD - maxDivergence, _WAD);
        uint256 upperBound = FixedPointMathLib.fullMulDiv(primaryToCheck, _WAD + maxDivergence, _WAD);

        if (anchorToCheck < lowerBound || anchorToCheck > upperBound) {
            revert Errors.PriceOracle_InvalidAnswer();
        }

        // Return the original output amount
        return originalPrimaryOutAmount;
    }
}
</file>

<file path="src/oracles/ERC4626Oracle.sol">
// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.28;

import { IERC4626 } from "@openzeppelin/contracts/interfaces/IERC4626.sol";

import { BaseAdapter } from "euler-price-oracle/src/adapter/BaseAdapter.sol";
import { ScaleUtils } from "euler-price-oracle/src/lib/ScaleUtils.sol";

/// @title ERC4626Oracle
/// @author Storm Labs (https://storm-labs.xyz/)
/// @notice A price oracle adapter for ERC4626 vault tokens
/// @dev Handles price conversions between ERC4626 vault shares and their underlying assets.
/// When the vault token is used as the base or quote, the oracle automatically converts between share and asset prices
/// using the vault's convertToAssets/convertToShares functions. The oracle follows the behavior of
/// the ERC4626 vault's implementation of its functions, typically ignoring the maximum amount of shares that can be
/// redeemed or minted.
///
/// This oracle relies on the convertToAssets/convertToShares functions of the underlying ERC4626 vault.
/// If the dependent ERC4626 contract does not implement sufficient protection against donation attacks,
/// sudden price jumps may occur when large amounts of assets are donated to the vault without a proportional
/// increase in shares. Users should verify the security measures implemented by the underlying vault.
/// Due to this risk, this oracle should only be used when there is no direct price feed available for the vault token.
contract ERC4626Oracle is BaseAdapter {
    /// @notice The name of the oracle.
    // solhint-disable-next-line const-name-snakecase
    string public constant override name = "ERC4626Oracle";
    /// @notice The address of the base asset.
    address public immutable base;
    /// @notice The address of the quote asset.
    address public immutable quote;

    /// @notice Constructor for the ERC4626Oracle contract.
    /// @param _vault The ERC4626 vault that should be used as the base asset.
    // slither-disable-next-line locked-ether
    constructor(IERC4626 _vault) payable {
        // Assume the vault is IERC4626 compliant token
        base = address(_vault);
        quote = _vault.asset();
    }

    function _getQuote(
        uint256 inAmount,
        address _base,
        address _quote
    )
        internal
        view
        virtual
        override
        returns (uint256)
    {
        bool inverse = ScaleUtils.getDirectionOrRevert(_base, base, _quote, quote);
        if (inAmount == 0) {
            return 0;
        }
        if (!inverse) {
            return IERC4626(_base).convertToAssets(inAmount);
        } else {
            return IERC4626(_quote).convertToShares(inAmount);
        }
    }
}
</file>

<file path="src/strategies/StrategyRegistry.sol">
// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.28;

import { AccessControlEnumerable } from "@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol";

import { WeightStrategy } from "src/strategies/WeightStrategy.sol";

/// @title StrategyRegistry
/// @notice A registry for weight strategies that allows checking if a strategy supports a specific bit flag.
/// @dev Inherits from AccessControlEnumerable for role-based access control.
/// Roles:
/// - DEFAULT_ADMIN_ROLE: The default role given to an address at creation. Can grant and revoke roles.
/// - WEIGHT_STRATEGY_ROLE: Role given to approved weight strategys.
contract StrategyRegistry is AccessControlEnumerable {
    /// @dev Role identifier for weight strategys
    bytes32 private constant _WEIGHT_STRATEGY_ROLE = keccak256("WEIGHT_STRATEGY_ROLE");

    /// @notice Error thrown when an unsupported strategy is used
    error StrategyNotSupported();

    /// @notice Constructs the StrategyRegistry contract
    /// @param admin The address that will be granted the DEFAULT_ADMIN_ROLE
    // slither-disable-next-line locked-ether
    constructor(address admin) payable {
        _grantRole(DEFAULT_ADMIN_ROLE, admin);
    }

    /// @notice Checks if a given weight strategy supports a specific bit flag
    /// @param bitFlag The bit flag to check support for
    /// @param weightStrategy The address of the weight strategy to check
    /// @return bool True if the strategy supports the bit flag, false otherwise
    function supportsBitFlag(uint256 bitFlag, address weightStrategy) external view returns (bool) {
        if (!hasRole(_WEIGHT_STRATEGY_ROLE, weightStrategy)) {
            revert StrategyNotSupported();
        }
        return WeightStrategy(weightStrategy).supportsBitFlag(bitFlag);
    }
}
</file>

<file path="src/strategies/WeightStrategy.sol">
// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.28;

/// @title WeightStrategy
/// @notice Abstract contract for weight strategies that determine the target weights of assets in a basket.
/// @dev This contract should be implemented by strategies that provide specific logic for calculating target weights.
/// Use cases include:
/// - `AutomaticWeightStrategy.sol`: Calculates weights based on external market data or other on-chain data sources.
/// - `ManagedWeightStrategy.sol`: Allows manual setting of target weights by an authorized manager.
/// The sum of the weights returned by `getTargetWeights` should be 1e18.
abstract contract WeightStrategy {
    /// @notice Returns the target weights for the assets in the basket that the rebalancing process aims to achieve.
    /// @param bitFlag The bit flag representing a list of assets.
    /// @return targetWeights The target weights of the assets in the basket. The weights should sum to 1e18.
    function getTargetWeights(uint256 bitFlag) public view virtual returns (uint64[] memory targetWeights);

    /// @notice Checks whether the strategy supports the given bit flag, representing a list of assets.
    /// @param bitFlag The bit flag representing a list of assets.
    /// @return supported A boolean indicating whether the strategy supports the given bit flag.
    function supportsBitFlag(uint256 bitFlag) public view virtual returns (bool supported);
}
</file>

<file path="src/Rescuable.sol">
// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.28;

import { IERC20, SafeERC20 } from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import { Math } from "@openzeppelin/contracts/utils/math/Math.sol";

/// @title Rescuable
/// @notice Allows the inheriting contract to rescue ERC20 tokens that are sent to it by mistake.
contract Rescuable {
    // Libraries
    using SafeERC20 for IERC20;

    // Errors
    /// @notice Error for when an ETH transfer of zero is attempted.
    error ZeroEthTransfer();
    /// @notice Error for when an ETH transfer fails.
    error EthTransferFailed();
    /// @notice Error for when a token transfer of zero is attempted.
    error ZeroTokenTransfer();

    /// @dev Rescue any ERC20 tokens that are stuck in this contract.
    /// The inheriting contract that calls this function should specify required access controls
    /// @param token address of the ERC20 token to rescue. Use zero address for ETH
    /// @param to address to send the tokens to
    /// @param balance amount of tokens to rescue. Use zero to rescue all
    function _rescue(IERC20 token, address to, uint256 balance) internal {
        if (address(token) == address(0)) {
            // for ether
            uint256 totalBalance = address(this).balance;
            balance = balance != 0 ? Math.min(totalBalance, balance) : totalBalance;
            if (balance != 0) {
                // slither-disable-next-line arbitrary-send
                // slither-disable-next-line low-level-calls
                (bool success,) = to.call{ value: balance }("");
                if (!success) revert EthTransferFailed();
                return;
            }
            revert ZeroEthTransfer();
        } else {
            // for any other erc20
            uint256 totalBalance = token.balanceOf(address(this));
            balance = balance != 0 ? Math.min(totalBalance, balance) : totalBalance;
            if (balance != 0) {
                token.safeTransfer(to, balance);
                return;
            }
            revert ZeroTokenTransfer();
        }
    }
}
</file>

<file path="extractAbis.py">
import json
import os
from pathlib import Path


def convert_to_ts_format(abi_data):
    """Convert JSON ABI to TypeScript format string."""
    # Convert the ABI to a string with proper formatting
    abi_str = json.dumps(abi_data, indent=2)

    # Remove quotes from property names
    abi_str = abi_str.replace('"name":', "name:")
    abi_str = abi_str.replace('"type":', "type:")
    abi_str = abi_str.replace('"inputs":', "inputs:")
    abi_str = abi_str.replace('"outputs":', "outputs:")
    abi_str = abi_str.replace('"stateMutability":', "stateMutability:")
    abi_str = abi_str.replace('"internalType":', "internalType:")
    abi_str = abi_str.replace('"anonymous":', "anonymous:")
    abi_str = abi_str.replace('"indexed":', "indexed:")

    # Add export statement
    return f"export const abi = {abi_str};"


def is_src_contract(data):
    """Check if the contract is from src/ directory using metadata."""
    try:
        raw_metadata = json.loads(data.get("rawMetadata", "{}"))
        compilation_target = raw_metadata.get("settings", {}).get(
            "compilationTarget", {}
        )
        return any(key.startswith("src/") for key in compilation_target.keys())
    except:
        return False


def extract_abis():
    # Get the out directory path
    out_dir = Path("out")

    # Create abis directory if it doesn't exist
    abis_dir = Path("abis")
    abis_dir.mkdir(exist_ok=True)

    # Walk through all directories in out/
    for root, dirs, files in os.walk(out_dir):
        for file in files:
            if not file.endswith(".json"):
                continue

            file_path = Path(root) / file

            try:
                with open(file_path) as f:
                    data = json.load(f)

                if not is_src_contract(data):
                    continue

                if "abi" not in data:
                    continue

                if not data["abi"]:
                    continue

                contract_name = file.replace(".json", "")

                # Save JSON ABI
                json_path = abis_dir / f"{contract_name}.abi.json"
                with open(json_path, "w") as f:
                    json.dump(data["abi"], f, indent=2)

                # Save TypeScript ABI
                ts_path = abis_dir / f"{contract_name}.abi.ts"
                with open(ts_path, "w") as f:
                    f.write(convert_to_ts_format(data["abi"]))

                print(f"Processed {contract_name}")

            except Exception as e:
                print(f"Error processing {file}: {e}")


if __name__ == "__main__":
    extract_abis()
</file>

<file path="LICENSE">
Parameters

Licensor:             Storm Labs Inc.

Licensed Work:        The Cove Protocol
                      The Licensed Work is (c) 2025 Storm Labs Inc.

Additional Use Grant: None

Change Date:          One year from May 28, 2025

Change License:       MIT License

-----------------------------------------------------------------------------

Notice

The Business Source License (this document, or the “License”) is not an Open
Source license. However, the Licensed Work will eventually be made available
under an Open Source License, as stated in this License. License text copyright
(c) 2020 MariaDB Corporation Ab, All Rights Reserved. “Business Source License”
is a trademark of MariaDB Corporation Ab.

Business Source License 1.1

-----------------------------------------------------------------------------

Terms

The Licensor hereby grants you the right to copy, modify, create derivative
works, redistribute, and make non-production use of the Licensed Work. The
Licensor may make an Additional Use Grant, above, permitting limited production
use.

Effective on the Change Date, or the fourth anniversary of the first publicly
available distribution of a specific version of the Licensed Work under this
License, whichever comes first, the Licensor hereby grants you rights under the
terms of the Change License, and the rights granted in the paragraph above
terminate.

If your use of the Licensed Work does not comply with the requirements
currently in effect as described in this License, you must purchase a
commercial license from the Licensor, its affiliated entities, or authorized
resellers, or you must refrain from using the Licensed Work.

All copies of the original and modified Licensed Work, and derivative works of
the Licensed Work, are subject to this License. This License applies separately
for each version of the Licensed Work and the Change Date may vary for each
version of the Licensed Work released by Licensor.

You must conspicuously display this License on each original or modified copy
of the Licensed Work. If you receive the Licensed Work in original or modified
form from a third party, the terms and conditions set forth in this License
apply to your use of that work.

Any use of the Licensed Work in violation of this License will automatically
terminate your rights under this License for the current and all other versions
of the Licensed Work.

This License does not grant you any right in any trademark or logo of Licensor
or its affiliates (provided that you may use a trademark or logo of Licensor as
expressly required by this License).

TO THE EXTENT PERMITTED BY APPLICABLE LAW, THE LICENSED WORK IS PROVIDED ON AN
“AS IS” BASIS. LICENSOR HEREBY DISCLAIMS ALL WARRANTIES AND CONDITIONS, EXPRESS
OR IMPLIED, INCLUDING (WITHOUT LIMITATION) WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT, AND TITLE.

MariaDB hereby grants you permission to use this License’s text to license your
works, and to refer to it using the trademark “Business Source License”, as
long as you comply with the Covenants of Licensor below.

-----------------------------------------------------------------------------

Covenants of Licensor

In consideration of the right to use this License’s text and the “Business
Source License” name and trademark, Licensor covenants to MariaDB, and to all
other recipients of the licensed work to be provided by Licensor:

1. To specify as the Change License the GPL Version 2.0 or any later version,
or a license that is compatible with GPL Version 2.0 or a later version, where
“compatible” means that software provided under the Change License can be
included in a program with software provided under GPL Version 2.0 or a later
version. Licensor may specify additional Change Licenses without limitation.

2. To either: (a) specify an additional grant of rights to use that does not
impose any additional restriction on the right granted in this License, as the
Additional Use Grant; or (b) insert the text “None” to specify a Change Date.

3. Not to modify this License in any other way.
</file>

<file path="src/oracles/ChainedERC4626Oracle.sol">
// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.28;

import { IERC4626 } from "@openzeppelin/contracts/interfaces/IERC4626.sol";

import { BaseAdapter } from "euler-price-oracle/src/adapter/BaseAdapter.sol";
import { ScaleUtils } from "euler-price-oracle/src/lib/ScaleUtils.sol";

/// @title ChainedERC4626Oracle
/// @author Storm Labs (https://storm-labs.xyz/)
/// @notice A price oracle adapter for chained ERC4626 vault tokens
/// @dev Handles price conversions between ERC4626 vault shares through multiple levels until reaching
/// the target underlying asset. The oracle automatically converts between share and asset prices
/// through the entire chain using each vault's convertToAssets/convertToShares functions.
///
/// This oracle relies on the convertToAssets/convertToShares functions of the underlying ERC4626 vaults.
/// If the dependent ERC4626 contracts do not implement sufficient protection against donation attacks,
/// sudden price jumps may occur when large amounts of assets are donated to the vaults without a proportional
/// increase in shares. Users should verify the security measures implemented by the underlying vaults.
/// Due to this risk, this oracle should only be used when there is no direct price feed available for the vault tokens.
contract ChainedERC4626Oracle is BaseAdapter {
    /// @notice The name of the oracle
    // solhint-disable-next-line const-name-snakecase
    string public constant override name = "ChainedERC4626Oracle";
    /// @notice The address of the base asset (first vault in chain)
    address public immutable base;
    /// @notice The address of the quote asset (final underlying asset)
    address public immutable quote;
    /// @notice The array of vaults in the chain
    address[] public vaults;

    /// @notice Thrown when a vault in the chain is invalid (zero address)
    error InvalidVaultChain();
    /// @notice Thrown when the vault chain is either empty or exceeds the maximum allowed length
    error ChainTooLong();
    /// @notice Thrown when the chain cannot reach the target asset (e.g., invalid vault sequence)
    error TargetAssetNotReached();

    /// @notice Maximum allowed length for the vault chain
    uint256 private constant _MAX_CHAIN_LENGTH = 10;

    /// @notice Constructor for the ChainedERC4626Oracle contract
    /// @param _initialVault The starting ERC4626 vault in the chain
    /// @param _targetAsset The final underlying asset to reach
    // slither-disable-next-line locked-ether
    constructor(IERC4626 _initialVault, address _targetAsset) payable {
        uint256 chainLength = 0;

        // Start with the initial vault
        address currentVault = address(_initialVault);
        address currentAsset;

        // slither-disable-start calls-loop
        // Build the chain
        while (chainLength < _MAX_CHAIN_LENGTH) {
            if (currentVault == address(0)) revert InvalidVaultChain();
            // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop
            vaults.push(currentVault);

            try IERC4626(currentVault).asset() returns (address asset) {
                currentAsset = asset;
                // Safe to use unchecked as chainLength is bounded by _MAX_CHAIN_LENGTH (10)
                unchecked {
                    ++chainLength;
                }

                // Check if we've reached the target asset
                if (currentAsset == _targetAsset) {
                    break;
                }

                // Try to treat the asset as another vault
                currentVault = currentAsset;
            } catch {
                revert TargetAssetNotReached();
            }
        }
        // slither-disable-end calls-loop
        if (chainLength == 0 || chainLength == _MAX_CHAIN_LENGTH) {
            revert ChainTooLong();
        }

        // Set the base and quote for the BaseAdapter
        base = address(_initialVault);
        quote = _targetAsset;
    }

    /// @notice Internal function to get quote through the vault chain
    /// @param inAmount The input amount to convert
    /// @param _base The base asset address
    /// @param _quote The quote asset address
    /// @return The converted amount
    function _getQuote(
        uint256 inAmount,
        address _base,
        address _quote
    )
        internal
        view
        virtual
        override
        returns (uint256)
    {
        bool inverse = ScaleUtils.getDirectionOrRevert(_base, base, _quote, quote);

        if (inAmount == 0) return 0;
        uint256 length = vaults.length;

        // slither-disable-start calls-loop
        if (!inverse) {
            // Convert from vault shares to final asset
            uint256 amount = inAmount;
            for (uint256 i = 0; i < length;) {
                // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop
                amount = IERC4626(vaults[i]).convertToAssets(amount);
                // Safe to use unchecked as i is bounded by length (which is bounded by _MAX_CHAIN_LENGTH)
                unchecked {
                    ++i;
                }
            }
            return amount;
        } else {
            // Convert from final asset to vault shares
            uint256 amount = inAmount;
            for (uint256 i = length; i > 0;) {
                // Safe to use unchecked as i is always > 0 in the loop condition
                unchecked {
                    --i;
                }
                // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop
                amount = IERC4626(vaults[i]).convertToShares(amount);
            }
            return amount;
        }
        // slither-disable-end calls-loop
    }
}
</file>

<file path="src/rewards/FarmingPluginFactory.sol">
// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.28;

import { IERC20Plugins } from "@1inch/token-plugins/contracts/interfaces/IERC20Plugins.sol";
import { AccessControlEnumerable } from "@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { CREATE3Factory } from "create3-factory/src/CREATE3Factory.sol";

import { FarmingPlugin } from "@1inch/farming/contracts/FarmingPlugin.sol";

/**
 * @title FarmingPluginFactory
 * @notice Deploys new `FarmingPlugin`s and acts as a registry.
 *
 * Roles
 * -----
 * - DEFAULT_ADMIN_ROLE — can grant/revoke all roles and set default plugin owner
 * - MANAGER_ROLE       — allowed to deploy new farming plugins
 *
 * @dev This factory uses CREATE2 to deploy the farming plugin, therefore there cannot be two plugins with the same
 * staking token and rewards token.
 */
contract FarmingPluginFactory is AccessControlEnumerable {
    /// @notice Role for managing the factory.
    bytes32 public constant MANAGER_ROLE = keccak256("MANAGER_ROLE");
    /// @notice Default plugin owner.
    address public defaultPluginOwner;

    /// @dev CREATE3Factory address
    CREATE3Factory private constant _CREATE3_FACTORY = CREATE3Factory(0x93FEC2C00BfE902F733B57c5a6CeeD7CD1384AE1);
    /// @dev staking token => list of all farming plugins created for that token
    mapping(address => address[]) private _plugins;
    /// @dev flat list of every plugin ever deployed (useful for iteration off-chain)
    address[] private _allPlugins;

    /// @notice Emitted when a new farming plugin is created.
    /// @param stakingToken  ERC-20 token users deposit (must support plugins).
    /// @param rewardsToken  ERC-20 token distributed as rewards.
    /// @param plugin        Address of the new farming plugin.
    /// @param pluginOwner   Address that will own the plugin (controls start/stop farming & rescue).
    event FarmingPluginCreated(
        address indexed stakingToken, address indexed rewardsToken, address indexed plugin, address pluginOwner
    );
    /// @notice Emitted when the default plugin owner is set.
    /// @param previousOwner Address that was the previous default plugin owner.
    /// @param newOwner      Address that will be the new default plugin owner.
    event DefaultPluginOwnerSet(address indexed previousOwner, address indexed newOwner);

    /// @notice Emitted when a zero address is used.
    error ZeroAddress();

    /// @notice Constructor.
    /// @param admin  Address that receives DEFAULT_ADMIN_ROLE.
    /// @param manager  Address that receives MANAGER_ROLE.
    /// @param _defaultPluginOwner  Address that will be the default plugin owner.
    // slither-disable-next-line locked-ether
    constructor(address admin, address manager, address _defaultPluginOwner) payable {
        if (admin == address(0) || manager == address(0)) revert ZeroAddress();
        _grantRole(DEFAULT_ADMIN_ROLE, admin);
        _grantRole(MANAGER_ROLE, manager);
        _setDefaultPluginOwner(_defaultPluginOwner);
    }

    /*═════════════════════════════════════  VIEW FUNCTIONS  ═════════════════════════════════════*/

    /// @notice All plugins ever created.
    /// @return allPlugins Array of all farming plugins.
    function allPlugins() external view returns (address[] memory) {
        return _allPlugins;
    }

    /// @notice Plugins for a given staking token.
    /// @param stakingToken Address of the staking token.
    /// @return plugins Array of farming plugins for the given staking token.
    function plugins(address stakingToken) external view returns (address[] memory) {
        return _plugins[stakingToken];
    }

    /// @notice Compute the address of a plugin for a given staking token and rewards token.
    /// @dev The corresponding contract may not have been deployed yet, so the address may be empty.
    /// For existence, either check for the code size or compare against the allPlugins array.
    /// @param stakingToken Address of the staking token.
    /// @param rewardsToken Address of the rewards token.
    /// @return plugin Address of the plugin.
    function computePluginAddress(IERC20Plugins stakingToken, IERC20 rewardsToken) external view returns (address) {
        bytes32 salt = keccak256(abi.encodePacked(stakingToken, rewardsToken));
        return _CREATE3_FACTORY.getDeployed(address(this), salt);
    }

    /*════════════════════════════════  ADMIN FUNCTIONS  ════════════════════════════════*/

    /// @notice Set the default plugin owner.
    /// @param pluginOwner Address that will own the plugin (controls start/stop farming & rescue).
    function setDefaultPluginOwner(address pluginOwner) external onlyRole(DEFAULT_ADMIN_ROLE) {
        _setDefaultPluginOwner(pluginOwner);
    }

    /*══════════════════════════════════  DEPLOYMENT FUNCTION  ═══════════════════════════════════*/

    /// @notice Deploy a new farming plugin with the default plugin owner.
    /// @param stakingToken  ERC-20 token users deposit (must support plugins).
    /// @param rewardsToken  ERC-20 token distributed as rewards.
    /// @dev Access: only accounts with MANAGER_ROLE. Default plugin owner must be set.
    function deployFarmingPluginWithDefaultOwner(
        IERC20Plugins stakingToken,
        IERC20 rewardsToken
    )
        external
        onlyRole(MANAGER_ROLE)
        returns (address plugin)
    {
        return _deployFarmingPlugin(stakingToken, rewardsToken, defaultPluginOwner);
    }

    /// @notice Deploy a new farming plugin.
    /// @param stakingToken  ERC-20 token users deposit (must support plugins).
    /// @param rewardsToken  ERC-20 token distributed as rewards.
    /// @param pluginOwner   Address that will own the plugin (controls start/stop farming & rescue).
    /// @dev Access: only accounts with MANAGER_ROLE.
    function deployFarmingPlugin(
        IERC20Plugins stakingToken,
        IERC20 rewardsToken,
        address pluginOwner
    )
        external
        onlyRole(MANAGER_ROLE)
        returns (address plugin)
    {
        return _deployFarmingPlugin(stakingToken, rewardsToken, pluginOwner);
    }

    /*════════════════════════════════════  INTERNAL FUNCTIONS  ════════════════════════════════════*/

    /// @notice Set the default plugin owner.
    /// @param pluginOwner Address that will own the plugin (controls start/stop farming & rescue).
    function _setDefaultPluginOwner(address pluginOwner) internal {
        if (pluginOwner == address(0)) revert ZeroAddress();
        address previousOwner = defaultPluginOwner;
        defaultPluginOwner = pluginOwner;
        emit DefaultPluginOwnerSet(previousOwner, pluginOwner);
    }

    /// @notice Deploy a new farming plugin with a unique salt to avoid collisions.
    /// @param stakingToken  ERC-20 token users deposit (must support plugins).
    /// @param rewardsToken  ERC-20 token distributed as rewards.
    /// @param pluginOwner   Address that will own the plugin (controls start/stop farming & rescue).
    function _deployFarmingPlugin(
        IERC20Plugins stakingToken,
        IERC20 rewardsToken,
        address pluginOwner
    )
        internal
        returns (address plugin)
    {
        if (pluginOwner == address(0) || address(stakingToken) == address(0) || address(rewardsToken) == address(0)) {
            revert ZeroAddress();
        }
        bytes32 salt = keccak256(abi.encodePacked(stakingToken, rewardsToken));
        // slither-disable-next-line too-many-digits,reentrancy-benign
        plugin = _CREATE3_FACTORY.deploy(
            salt,
            abi.encodePacked(type(FarmingPlugin).creationCode, abi.encode(stakingToken, rewardsToken, pluginOwner))
        );

        _plugins[address(stakingToken)].push(plugin);
        _allPlugins.push(plugin);

        // slither-disable-next-line reentrancy-events
        emit FarmingPluginCreated(address(stakingToken), address(rewardsToken), plugin, pluginOwner);
    }
}
</file>

<file path="src/strategies/AutomaticWeightStrategy.sol">
// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.28;

import { AccessControlEnumerable } from "@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol";
import { Multicall } from "@openzeppelin/contracts/utils/Multicall.sol";

import { WeightStrategy } from "src/strategies/WeightStrategy.sol";

/// @title AutomaticWeightStrategy
/// @notice A strategy that returns the target weights based on external market cap data. This could be used for
/// other purposes as well such as volume, liquidity, etc as long as the data is available on chain.
/// Setters should not be implemented in this contract as the data is expected to be external and read-only.
// solhint-disable no-empty-blocks
contract AutomaticWeightStrategy is WeightStrategy, AccessControlEnumerable, Multicall {
    // slither-disable-next-line locked-ether
    constructor(address admin) payable {
        _grantRole(DEFAULT_ADMIN_ROLE, admin);
    }

    function getTargetWeights(uint256 bitFlag) public view virtual override returns (uint64[] memory targetWeights) { }

    function supportsBitFlag(uint256 bitFlag) public view virtual override returns (bool) { }
}
</file>

<file path="src/swap_adapters/CoWSwapClone.sol">
// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.28;

import { IERC1271 } from "@openzeppelin/contracts/interfaces/IERC1271.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { SafeERC20 } from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import { Clone } from "clones-with-immutable-args/Clone.sol";
import { GPv2Order } from "src/deps/cowprotocol/GPv2Order.sol";

// slither-disable-start locked-ether
/// @title CoWSwapClone
/// @notice A contract that implements the ERC1271 interface for signature validation and manages token trades. This
/// contract is designed to be used as a clone with immutable arguments, leveraging the `ClonesWithImmutableArgs`
/// library.
/// The clone should be initialized with the following packed bytes, in this exact order:
/// - `sellToken` (address): The address of the token to be sold.
/// - `buyToken` (address): The address of the token to be bought.
/// - `sellAmount` (uint256): The amount of the sell token.
/// - `buyAmount` (uint256): The minimum amount of the buy token.
/// - `validTo` (uint64): The timestamp until which the order is valid.
/// - `operator` (address): The address of the operator allowed to manage the trade.
/// - `receiver` (address): The address that will receive the bought tokens.
///
/// To use this contract, deploy it as a clone using the `ClonesWithImmutableArgs` library with the above immutable
/// arguments packed into a single bytes array. After deployment, call `initialize()` to set up the necessary token
/// approvals for the trade.
/// @dev The `isValidSignature` function can be used to validate the signature of an order against the stored order
/// digest.
contract CoWSwapClone is IERC1271, Clone {
    using GPv2Order for GPv2Order.Data;
    using SafeERC20 for IERC20;

    /// CONSTANTS ///
    // Constants for ERC1271 signature validation
    bytes4 internal constant _ERC1271_MAGIC_VALUE = 0x1626ba7e;
    bytes4 internal constant _ERC1271_NON_MAGIC_VALUE = 0xffffffff;

    /// @dev The domain separator of GPv2Settlement contract used for orderDigest calculation.
    bytes32 internal constant _COW_SETTLEMENT_DOMAIN_SEPARATOR =
        0xc078f884a2676e1345748b1feace7b0abee5d00ecadb6e574dcdd109a63e8943;
    /// @dev Address of the GPv2VaultRelayer.
    /// https://docs.cow.fi/cow-protocol/reference/contracts/core
    address internal constant _VAULT_RELAYER = 0xC92E8bdf79f0507f65a392b0ab4667716BFE0110;

    /// EVENTS ///
    /// @notice Emitted when a new order is created.
    /// @param sellToken The address of the token to be sold.
    /// @param buyToken The address of the token to be bought.
    /// @param sellAmount The amount of the sell token.
    /// @param minBuyAmount The minimum amount of the buy token.
    /// @param validTo The timestamp until which the order is valid.
    /// @param receiver The address that will receive the bought tokens.
    /// @param operator The address of the operator allowed to manage the trade.
    event CoWSwapCloneCreated(
        address indexed sellToken,
        address indexed buyToken,
        uint256 sellAmount,
        uint256 minBuyAmount,
        uint32 validTo,
        address indexed receiver,
        address operator
    );
    /// @notice Emitted when an order is claimed.
    /// @param operator The address of the operator who claimed the order.
    /// @param claimedSellAmount The amount of sell tokens claimed.
    /// @param claimedBuyAmount The amount of buy tokens claimed.
    event OrderClaimed(address indexed operator, uint256 claimedSellAmount, uint256 claimedBuyAmount);

    /// ERRORS ///
    /// @notice Thrown when the caller is not the operator or receiver of the order.
    error CallerIsNotOperatorOrReceiver();

    /// @notice Initializes the CoWSwapClone contract by approving the vault relayer to spend the maximum amount of the
    /// sell token.
    /// @dev This function should be called after the clone is deployed to set up the necessary token approvals.
    function initialize() external payable {
        IERC20(sellToken()).forceApprove(_VAULT_RELAYER, type(uint256).max);
        emit CoWSwapCloneCreated(
            sellToken(), buyToken(), sellAmount(), minBuyAmount(), validTo(), receiver(), operator()
        );
    }

    /// @notice Validates the signature of an order. The order is considered valid if the order digest matches the
    /// stored order digest. Second parameter is not used.
    /// @param orderDigest The digest of the order to validate.
    /// @return A magic value if the signature is valid, otherwise a non-magic value.
    // solhint-disable-next-line code-complexity
    function isValidSignature(
        bytes32 orderDigest,
        bytes calldata encodedOrder
    )
        external
        view
        override
        returns (bytes4)
    {
        GPv2Order.Data memory order = abi.decode(encodedOrder, (GPv2Order.Data));

        if (orderDigest != order.hash(_COW_SETTLEMENT_DOMAIN_SEPARATOR)) {
            return _ERC1271_NON_MAGIC_VALUE;
        }

        if (address(order.sellToken) != sellToken()) {
            return _ERC1271_NON_MAGIC_VALUE;
        }

        if (address(order.buyToken) != buyToken()) {
            return _ERC1271_NON_MAGIC_VALUE;
        }

        if (order.sellAmount != sellAmount()) {
            return _ERC1271_NON_MAGIC_VALUE;
        }

        if (order.buyAmount < minBuyAmount()) {
            return _ERC1271_NON_MAGIC_VALUE;
        }

        if (order.validTo != validTo()) {
            return _ERC1271_NON_MAGIC_VALUE;
        }

        if (order.appData != bytes32(0)) {
            return _ERC1271_NON_MAGIC_VALUE;
        }

        if (order.feeAmount != 0) {
            return _ERC1271_NON_MAGIC_VALUE;
        }

        if (order.kind != GPv2Order.KIND_SELL) {
            return _ERC1271_NON_MAGIC_VALUE;
        }

        if (order.partiallyFillable) {
            return _ERC1271_NON_MAGIC_VALUE;
        }

        if (order.sellTokenBalance != GPv2Order.BALANCE_ERC20) {
            return _ERC1271_NON_MAGIC_VALUE;
        }

        if (order.buyTokenBalance != GPv2Order.BALANCE_ERC20) {
            return _ERC1271_NON_MAGIC_VALUE;
        }

        if (order.receiver != address(this)) {
            return _ERC1271_NON_MAGIC_VALUE;
        }

        return _ERC1271_MAGIC_VALUE;
    }

    /// @notice Claims the sell and buy tokens. Calling this function before the trade has settled will cancel the
    /// trade. Only the operator or the receiver can claim the tokens.
    /// @return claimedSellAmount The amount of sell tokens claimed.
    /// @return claimedBuyAmount The amount of buy tokens claimed.
    function claim() external payable returns (uint256 claimedSellAmount, uint256 claimedBuyAmount) {
        if (msg.sender != operator()) {
            if (msg.sender != receiver()) {
                revert CallerIsNotOperatorOrReceiver();
            }
        }
        claimedSellAmount = IERC20(sellToken()).balanceOf(address(this));
        if (claimedSellAmount > 0) {
            IERC20(sellToken()).safeTransfer(receiver(), claimedSellAmount);
        }
        claimedBuyAmount = IERC20(buyToken()).balanceOf(address(this));
        if (claimedBuyAmount > 0) {
            IERC20(buyToken()).safeTransfer(receiver(), claimedBuyAmount);
        }

        emit OrderClaimed(msg.sender, claimedSellAmount, claimedBuyAmount);
    }

    // Immutable fields stored in the contract's bytecode
    // 0: sellToken (address)
    // 20: buyToken (address)
    // 40: sellAmount (uint256)
    // 72: minBuyAmount (uint256)
    // 104: validTo (uint32)
    // 112: receiver (address)
    // 132: operator (address)

    /// @notice Returns the address of the sell token.
    /// @return The address of the sell token.
    function sellToken() public pure returns (address) {
        return _getArgAddress(0);
    }

    /// @notice Returns the address of the buy token.
    /// @return The address of the buy token.
    function buyToken() public pure returns (address) {
        return _getArgAddress(20);
    }

    /// @notice Returns the amount of sell tokens.
    /// @return The amount of sell tokens.
    function sellAmount() public pure returns (uint256) {
        return _getArgUint256(40);
    }

    /// @notice Returns the amount of buy tokens.
    /// @return The amount of buy tokens.
    function minBuyAmount() public pure returns (uint256) {
        return _getArgUint256(72);
    }

    /// @notice Returns the timestamp until which the order is valid.
    /// @return The timestamp until which the order is valid.
    function validTo() public pure returns (uint32) {
        return uint32(_getArgUint64(104));
    }

    /// @notice Returns the address of the receiver.
    /// @return The address of the receiver.
    function receiver() public pure returns (address) {
        return _getArgAddress(112);
    }

    /// @notice Returns the address of the operator who can claim the tokens after the trade has settled. The operator
    /// can also cancel the trade before it has settled by calling the claim function before the trade has settled.
    /// @return The address of the operator.
    function operator() public pure returns (address) {
        return _getArgAddress(132);
    }
}
// slither-disable-end locked-ether
</file>

<file path="src/AssetRegistry.sol">
// SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.28;

import { AccessControlEnumerable } from "@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol";
import { BitFlag } from "src/libraries/BitFlag.sol";

/// @title AssetRegistry
/// @dev Manages the registration and status of assets in the system.
/// @notice This contract provides functionality to add, enable, pause, and manage assets, with role-based access
/// control.
/// @dev Utilizes OpenZeppelin's AccessControlEnumerable for granular permission management.
/// @dev Supports three asset states: DISABLED -> ENABLED <-> PAUSED.
contract AssetRegistry is AccessControlEnumerable {
    /// ENUMS ///
    enum AssetStatus {
        /// @notice Asset is disabled and cannot be used in the system
        DISABLED,
        /// @notice Asset is enabled and can be used normally in the system
        ENABLED,
        /// @notice Asset is paused and cannot be used until unpaused
        PAUSED
    }

    /// STRUCTS ///
    /// @notice Contains the index and status of an asset in the registry.
    struct AssetData {
        uint32 indexPlusOne;
        AssetStatus status;
    }

    /// CONSTANTS ///
    /// @notice Role responsible for managing assets in the registry.
    bytes32 private constant _MANAGER_ROLE = keccak256("MANAGER_ROLE");
    /// @dev Maximum number of assets that can be registered in the system.
    uint256 private constant _MAX_ASSETS = 255;

    /// STATE VARIABLES ///
    /// @dev Array of assets registered in the system.
    address[] private _assetList;
    /// @dev Mapping from asset address to AssetData struct containing the asset's index and status.
    mapping(address asset => AssetData) private _assetRegistry;
    /// @notice Bit flag representing the enabled assets in the registry.
    uint256 public enabledAssets;

    /// EVENTS ///
    /// @dev Emitted when a new asset is added to the registry.
    event AddAsset(address indexed asset);
    /// @dev Emitted when an asset's status is updated.
    event SetAssetStatus(address indexed asset, AssetStatus status);

    /// ERRORS ///
    /// @notice Thrown when the asset address is zero.
    error ZeroAddress();
    /// @notice Thrown when attempting to add an asset that is already enabled in the registry.
    error AssetAlreadyEnabled();
    /// @notice Thrown when attempting to perform an operation on an asset that is not enabled in the registry.
    error AssetNotEnabled();
    /// @notice Thrown when attempting to set the asset status to an invalid status.
    error AssetInvalidStatusUpdate();
    /// @notice Thrown when attempting to add an asset when the maximum number of assets has been reached.
    error MaxAssetsReached();
    /// @notice Thrown when length of the requested assets exceeds the maximum number of assets.
    error AssetExceedsMaximum();

    /// @notice Initializes the AssetRegistry contract
    /// @dev Sets up initial roles for admin and manager
    /// @param admin The address to be granted the DEFAULT_ADMIN_ROLE
    /// @dev Reverts if:
    ///      - The admin address is zero (ZeroAddress)
    // slither-disable-next-line locked-ether
    constructor(address admin) payable {
        if (admin == address(0)) revert ZeroAddress();
        _grantRole(DEFAULT_ADMIN_ROLE, admin);
        _grantRole(_MANAGER_ROLE, admin);
    }

    /// @notice Adds a new asset to the registry
    /// @dev Only callable by accounts with the MANAGER_ROLE
    /// @param asset The address of the asset to be added
    /// @dev Reverts if:
    ///      - The caller doesn't have the MANAGER_ROLE (OpenZeppelin's AccessControl)
    ///      - The asset address is zero (ZeroAddress)
    ///      - The asset is already enabled (AssetAlreadyEnabled)
    ///      - The maximum number of assets has been reached (MaxAssetsReached)
    function addAsset(address asset) external onlyRole(_MANAGER_ROLE) {
        if (asset == address(0)) revert ZeroAddress();
        AssetData storage assetData = _assetRegistry[asset];
        if (assetData.indexPlusOne > 0) revert AssetAlreadyEnabled();
        uint256 assetLength = _assetList.length;
        if (assetLength == _MAX_ASSETS) revert MaxAssetsReached();

        _assetList.push(asset);
        assetData.indexPlusOne = uint32(assetLength + 1);
        assetData.status = AssetStatus.ENABLED;
        enabledAssets = enabledAssets | (1 << assetLength);
        emit AddAsset(asset);
    }

    /// @notice Sets the status of an asset in the registry
    /// @dev Only callable by accounts with the MANAGER_ROLE
    /// @param asset The address of the asset to update
    /// @param newStatus The new status to set (ENABLED or PAUSED)
    /// @dev Reverts if:
    ///      - The caller doesn't have the MANAGER_ROLE (OpenZeppelin's AccessControl)
    ///      - The asset address is zero (ZeroAddress)
    ///      - The asset is not enabled in the registry (AssetNotEnabled)
    ///      - The new status is invalid (AssetInvalidStatusUpdate)
    function setAssetStatus(address asset, AssetStatus newStatus) external onlyRole(_MANAGER_ROLE) {
        if (asset == address(0)) revert ZeroAddress();
        AssetData storage assetData = _assetRegistry[asset];
        uint256 indexPlusOne = assetData.indexPlusOne;
        if (indexPlusOne == 0) revert AssetNotEnabled();
        if (newStatus == AssetStatus.DISABLED || assetData.status == newStatus) revert AssetInvalidStatusUpdate();
        // Based on the index of the asset in the registry, update the enabledAssets bit flag
        // If the new status is ENABLED, set the bit to 1, otherwise set it to 0
        if (newStatus == AssetStatus.ENABLED) {
            enabledAssets = enabledAssets | (1 << (indexPlusOne - 1));
        } else {
            // case: newStatus == AssetStatus.PAUSED
            enabledAssets = enabledAssets & ~(1 << (indexPlusOne - 1));
        }

        assetData.status = newStatus;
        emit SetAssetStatus(asset, newStatus);
    }

    /// @notice Retrieves the status of an asset
    /// @dev Returns the status of the asset. For non-existent assets, returns status as DISABLED
    /// @param asset The address of the asset to query
    /// @return AssetStatus The status of the asset
    function getAssetStatus(address asset) external view returns (AssetStatus) {
        AssetData storage assetData = _assetRegistry[asset];
        return assetData.status;
    }

    /// @notice Retrieves the list of assets in the registry. Parameter bitFlag is used to filter the assets.
    /// @param bitFlag The bit flag to filter the assets.
    /// @return assets The list of assets in the registry.
    function getAssets(uint256 bitFlag) external view returns (address[] memory assets) {
        uint256 maxLength = _assetList.length;

        // If the bit flag is greater than the bit flag for the latest asset, revert
        // This is to prevent accessing assets that are not present in the registry
        if (bitFlag > (1 << maxLength) - 1) {
            revert AssetExceedsMaximum();
        }

        // Initialize the return array
        assets = new address[](BitFlag.popCount(bitFlag));
        uint256 index = 0;

        // Iterate through the assets and populate the return array
        for (uint256 i; i < maxLength && bitFlag != 0;) {
            if (bitFlag & 1 != 0) {
                // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop
                assets[index++] = _assetList[i];
            }
            bitFlag >>= 1;
            unchecked {
                // Overflow not possible: i is bounded by maxLength which is less than 2^256 - 1
                ++i;
            }
        }
    }

    /// @notice Retrieves the addresses of all assets in the registry without any filtering.
    /// @return assets The list of addresses of all assets in the registry.
    function getAllAssets() external view returns (address[] memory) {
        return _assetList;
    }

    /// @notice Checks if any assets in the given bit flag are paused.
    /// @param bitFlag The bit flag representing a set of assets.
    /// @return bool True if any of the assets are paused, false otherwise.
    function hasPausedAssets(uint256 bitFlag) external view returns (bool) {
        return (enabledAssets & bitFlag) != bitFlag;
    }

    /// @notice Retrieves the bit flag for a given list of assets.
    /// @param assets The list of assets to get the bit flag for.
    /// @return bitFlag The bit flag representing the list of assets.
    /// @dev This function is for off-chain usage to get the bit flag for a list of assets.
    ///    Reverts if:
    ///     - the number of assets exceeds the maximum number of assets
    ///     - an asset is not enabled in the registry
    function getAssetsBitFlag(address[] memory assets) external view returns (uint256) {
        uint256 bitFlag = 0;
        uint256 assetsLength = assets.length;

        if (assetsLength > _assetList.length) {
            revert AssetExceedsMaximum();
        }

        for (uint256 i; i < assetsLength;) {
            // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop
            uint256 indexPlusOne = _assetRegistry[assets[i]].indexPlusOne;
            if (indexPlusOne == 0) {
                revert AssetNotEnabled();
            }

            unchecked {
                // Overflow not possible: indexPlusOne is bounded by _assetList.length which is less than 2^256 - 1
                // Underflow not possible: indexPlusOne is checked to be non-zero
                bitFlag |= 1 << (indexPlusOne - 1);
                // Overflow not possible: i is bounded by assetsLength which is less than 2^256 - 1
                ++i;
            }
        }

        return bitFlag;
    }
}
</file>

<file path=".env.example">
MAINNET_RPC_URL=
API_KEY_ETHERSCAN=
</file>

<file path="README.md">
# cove-contracts-core

![cove](./assets/cove.png)

<div align="center">

[![codecov](https://codecov.io/gh/Storm-Labs-Inc/cove-contracts-core/branch/master/graph/badge.svg?token=PSFDZ17DDG)](https://codecov.io/gh/Storm-Labs-Inc/cove-contracts-core)
[![CI](https://github.com/Storm-Labs-Inc/cove-contracts-core/actions/workflows/ci.yml/badge.svg)](https://github.com/Storm-Labs-Inc/cove-contracts-core/actions/workflows/ci.yml)
[![Discord](https://img.shields.io/discord/1162443184681533470?logo=discord&label=discord)](https://discord.gg/xdhvEFVsE9)
[![X (formerly Twitter) Follow](https://img.shields.io/twitter/follow/cove_fi)](https://twitter.com/intent/user?screen_name=cove_fi)

</div>

This repository contains the core smart contracts for the Cove Protocol.

The testing suite includes unit, integration, fork, and invariant tests.

For more detailed information, visit the [documentation](https://docs.cove.finance/) or the
[technical RFC](https://docs.cove.finance/technical/cove/rfc).

> [!IMPORTANT]
> You acknowledge that there are potential uses of the [Licensed Work] that
> could be deemed illegal or noncompliant under U.S. law. You agree that you
> will not use the [Licensed Work] for any activities that are or may
> reasonably be expected to be deemed illegal or noncompliant under U.S. law.
> You also agree that you, and not [Storm Labs], are responsible for any
> illegal or noncompliant uses of the [Licensed Work] that you facilitate,
> enable, engage in, support, promote, or are otherwise involved with.

## Prerequisites

Ensure you have the following installed:

- [Node.js](https://nodejs.org/) (v20.15.0)
- [Python](https://www.python.org/) (v3.9.17)

## Installation

Setup [pyenv](https://github.com/pyenv/pyenv?tab=readme-ov-file#installation) and install the python dependencies:

```sh
pyenv install 3.9.17
pyenv virtualenv 3.9.17 cove-contracts-core
pyenv local cove-contracts-core
pip install -r requirements.txt
```

Install node and build dependencies:

```sh
# Install node dependencies
pnpm install
# Install submodules as soldeer dependencies
forge soldeer install
```

## Usage

Build the contracts:

```sh
pnpm build
```

Run the tests:

```sh
pnpm test
```

### Run slither static analysis

[Install slither](https://github.com/crytic/slither?tab=readme-ov-file#how-to-install) and run the tool:

```sh
pnpm slither
```

To run the [upgradeability checks](https://github.com/crytic/slither/wiki/Upgradeability-Checks) with
`slither-check-upgradeability`:

```sh
pnpm slither-upgradeability
```

### Run semgrep static analysis

[Install semgrep](https://github.com/semgrep/semgrep?tab=readme-ov-file#option-2-getting-started-from-the-cli) and run
the tool:

```sh
pnpm semgrep
```

## Deploying contracts to live network

### Local mainnet fork

```sh
# Run a fork network using anvil
anvil --fork-url <rpc_url> --fork-block-number <block_num> --auto-impersonate
```

Keep this terminal session going to keep the fork network alive.

Then in another terminal session:

```sh
# Deploy contracts to local fork network
pnpm deployLocal
```

This command uses the `deployLocal` script defined in `package.json`. It sets the `DEPLOYMENT_CONTEXT` to `1-fork` and runs the `forge` script `script/Deployments.s.sol` with the specified RPC URL, broadcasting the transactions, and syncing the deployment using `forge-deploy`. The sender address set to COVE_DEPLOYER and is unlocked for local deployment.

- Deployments will be in `deployments/<chainId>-fork`.
- Make sure not to commit `broadcast/`.
- If trying to deploy a new contract, either use the default deployer functions or generate them with:
  `$ ./forge-deploy gen-deployer`.

## Contract Architecture

![architecture](./assets/architecture.png)

## Audits

Smart contract audits of the Cove Protocol are available [here](https://github.com/Storm-Labs-Inc/cove-audits).
</file>

<file path="src/strategies/ManagedWeightStrategy.sol">
// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.28;

import { AccessControlEnumerable } from "@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol";
import { Multicall } from "@openzeppelin/contracts/utils/Multicall.sol";

import { BasketManager } from "src/BasketManager.sol";
import { BitFlag } from "src/libraries/BitFlag.sol";
import { WeightStrategy } from "src/strategies/WeightStrategy.sol";
import { RebalanceStatus, Status } from "src/types/BasketManagerStorage.sol";

/// @title ManagedWeightStrategy
/// @notice A custom weight strategy that allows manual setting of target weights for a basket.
/// @dev Inherits from WeightStrategy and AccessControlEnumerable for role-based access control.
contract ManagedWeightStrategy is WeightStrategy, AccessControlEnumerable, Multicall {
    /// @notice Struct to store the last updated epoch and timestamp for a bit flag.
    struct LastUpdated {
        uint40 epoch;
        uint40 timestamp;
    }

    /// @notice Maps each rebalance bit flag to the corresponding target weights.
    mapping(uint256 bitFlag => uint64[] weights) public targetWeights;
    /// @notice Maps each bit flag to the last updated epoch and timestamp.
    mapping(uint256 bitFlag => LastUpdated) public lastUpdated;

    /// @dev Role identifier for the manager role.
    bytes32 internal constant _MANAGER_ROLE = keccak256("MANAGER_ROLE");
    /// @dev Precision for weights. All results from getTargetWeights() should sum to _WEIGHT_PRECISION.
    uint64 internal constant _WEIGHT_PRECISION = 1e18;
    /// @dev Address of the BasketManager contract associated with this strategy.
    address internal immutable _basketManager;

    /// ERRORS ///
    /// @notice Error thrown when the address is zero.
    error ZeroAddress();
    /// @notice Error thrown when an unsupported bit flag is provided.
    error UnsupportedBitFlag();
    /// @notice Error thrown when the length of the weights array does not match the number of assets.
    error InvalidWeightsLength();
    /// @notice Error thrown when the sum of the weights does not equal _WEIGHT_PRECISION (100%).
    error WeightsSumMismatch();
    /// @notice Error thrown when no target weights are set for the given epoch and bit flag.
    error NoTargetWeights();

    /// @notice Emitted when target weights are updated.
    /// @param bitFlag The bit flag representing the assets.
    /// @param epoch The epoch for which the weights are updated for.
    /// @param timestamp The timestamp of the update.
    /// @param newWeights The new target weights.
    event TargetWeightsUpdated(uint256 indexed bitFlag, uint256 indexed epoch, uint256 timestamp, uint64[] newWeights);

    /// @notice Constructor for the ManagedWeightStrategy contract.
    /// @param admin The address of the admin who will have DEFAULT_ADMIN_ROLE and MANAGER_ROLE.
    /// @param basketManager The address of the BasketManager contract associated with this strategy.
    // slither-disable-next-line locked-ether
    constructor(address admin, address basketManager) payable {
        if (admin == address(0)) {
            revert ZeroAddress();
        }
        if (basketManager == address(0)) {
            revert ZeroAddress();
        }
        _grantRole(DEFAULT_ADMIN_ROLE, admin);
        _grantRole(_MANAGER_ROLE, admin);
        _basketManager = basketManager;
    }

    /// @notice Sets the target weights for the assets for the next epoch. If a rebalance is in progress, the weights
    /// will apply to the next epoch.
    /// @param bitFlag The bit flag representing the assets.
    /// @param newTargetWeights The array of target weights for each asset.
    /// @dev Only callable by accounts with the MANAGER_ROLE.
    function setTargetWeights(uint256 bitFlag, uint64[] calldata newTargetWeights) external onlyRole(_MANAGER_ROLE) {
        // Validate the number of assets matches the length of the weights array.
        uint256 assetCount = BitFlag.popCount(bitFlag);
        if (assetCount < 2) {
            revert UnsupportedBitFlag();
        }
        if (newTargetWeights.length != assetCount) {
            revert InvalidWeightsLength();
        }

        // Ensure the sum of the weights equals the required precision.
        uint256 sum = 0;
        for (uint256 i = 0; i < assetCount;) {
            sum += newTargetWeights[i];
            unchecked {
                // Overflow not possible: i is bounded by assetCount
                ++i;
            }
        }
        if (sum != _WEIGHT_PRECISION) {
            revert WeightsSumMismatch();
        }

        // Read the current epoch from the BasketManager contract.
        // Determine the epoch that the weights will apply to.
        RebalanceStatus memory status = BasketManager(_basketManager).rebalanceStatus();
        uint40 epoch = status.epoch;
        if (status.status != Status.NOT_STARTED) {
            epoch += 1;
        }
        LastUpdated memory lastUpdated_ = LastUpdated(epoch, uint40(block.timestamp));

        // Update the target weights and emit the event.
        targetWeights[bitFlag] = newTargetWeights;
        lastUpdated[bitFlag] = lastUpdated_;
        emit TargetWeightsUpdated(bitFlag, lastUpdated_.epoch, lastUpdated_.timestamp, newTargetWeights);
    }

    /// @notice Retrieves the target weights for the assets in the basket for a given epoch and bit flag.
    /// @param bitFlag The bit flag representing the assets.
    /// @return weights The target weights for the assets.
    function getTargetWeights(uint256 bitFlag) public view override returns (uint64[] memory weights) {
        uint256 assetCount = BitFlag.popCount(bitFlag);
        if (assetCount < 2) {
            revert UnsupportedBitFlag();
        }
        weights = targetWeights[bitFlag];
        if (weights.length != assetCount) {
            revert NoTargetWeights();
        }
    }

    /// @notice Checks if the strategy supports the given bit flag, representing a list of assets.
    /// @param bitFlag The bit flag representing the assets.
    /// @return A boolean indicating whether the strategy supports the given bit flag.
    function supportsBitFlag(uint256 bitFlag) public view virtual override returns (bool) {
        // slither-disable-next-line timestamp
        return lastUpdated[bitFlag].timestamp != 0;
    }
}
</file>

<file path="src/swap_adapters/CoWSwapAdapter.sol">
// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.28;

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { SafeERC20 } from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import { ClonesWithImmutableArgs } from "clones-with-immutable-args/ClonesWithImmutableArgs.sol";
import { GPv2Order } from "src/deps/cowprotocol/GPv2Order.sol";

import { CoWSwapClone } from "src/swap_adapters/CoWSwapClone.sol";
import { TokenSwapAdapter } from "src/swap_adapters/TokenSwapAdapter.sol";
import { ExternalTrade } from "src/types/Trades.sol";

/// @title CoWSwapAdapter
/// @notice Adapter for executing and completing token swaps using CoWSwap protocol.
contract CoWSwapAdapter is TokenSwapAdapter {
    using GPv2Order for GPv2Order.Data;
    using SafeERC20 for IERC20;

    /// CONSTANTS ///
    /// @dev Storage slot for CoWSwapAdapter specific data.
    bytes32 internal constant _COWSWAP_ADAPTER_STORAGE =
        bytes32(uint256(keccak256("cove.basketmanager.cowswapadapter.storage")) - 1);

    /// @notice Address of the clone implementation used for creating CoWSwapClone contracts.
    address public immutable cloneImplementation;

    /// STRUCTS ///
    /// @dev Structure to store adapter-specific data.
    struct CoWSwapAdapterStorage {
        uint32 orderValidTo;
    }

    /// EVENTS ///
    /// @notice Emitted when a new order is created.
    /// @param sellToken The address of the token to be sold.
    /// @param buyToken The address of the token to be bought.
    /// @param sellAmount The amount of the sell token.
    /// @param buyAmount The amount of the buy token.
    /// @param validTo The timestamp until which the order is valid.
    /// @param swapContract The address of the swap contract.
    event OrderCreated(
        address indexed sellToken,
        address indexed buyToken,
        uint256 sellAmount,
        uint256 buyAmount,
        uint32 validTo,
        address swapContract
    );

    /// @notice Emitted when a token swap is completed.
    /// @param sellToken The address of the token sold.
    /// @param buyToken The address of the token bought.
    /// @param claimedSellAmount The amount of sell tokens claimed.
    /// @param claimedBuyAmount The amount of buy tokens claimed.
    /// @param swapContract The address of the swap contract.
    event TokenSwapCompleted(
        address indexed sellToken,
        address indexed buyToken,
        uint256 claimedSellAmount,
        uint256 claimedBuyAmount,
        address swapContract
    );

    /// ERRORS ///
    /// @notice Thrown when the address is zero.
    error ZeroAddress();

    /// @notice Constructor to initialize the CoWSwapAdapter with the clone implementation address.
    /// @param cloneImplementation_ The address of the clone implementation contract.
    constructor(address cloneImplementation_) payable {
        if (cloneImplementation_ == address(0)) {
            revert ZeroAddress();
        }
        cloneImplementation = cloneImplementation_;
    }

    /// @notice Executes a series of token swaps by creating orders on the CoWSwap protocol.
    /// @param externalTrades The external trades to execute.
    function executeTokenSwap(ExternalTrade[] calldata externalTrades, bytes calldata) external payable override {
        uint32 validTo = uint32(block.timestamp + 60 minutes);
        _cowswapAdapterStorage().orderValidTo = validTo;
        for (uint256 i = 0; i < externalTrades.length;) {
            _createOrder(
                externalTrades[i].sellToken,
                externalTrades[i].buyToken,
                externalTrades[i].sellAmount,
                externalTrades[i].minAmount,
                validTo
            );
            unchecked {
                // Overflow not possible: i is bounded by externalTrades.length
                ++i;
            }
        }
    }

    /// @notice Completes the token swaps by claiming the tokens from the CoWSwapClone contracts.
    /// @param externalTrades The external trades that were executed and need to be settled.
    /// @return claimedAmounts A 2D array containing the claimed amounts of sell and buy tokens for each trade.
    function completeTokenSwap(ExternalTrade[] calldata externalTrades)
        external
        payable
        override
        returns (uint256[2][] memory claimedAmounts)
    {
        uint256 length = externalTrades.length;
        claimedAmounts = new uint256[2][](length);
        uint32 validTo = _cowswapAdapterStorage().orderValidTo;

        for (uint256 i = 0; i < length;) {
            // Call claim on each CoWSwapClone contract
            bytes32 salt = keccak256(
                abi.encodePacked(
                    externalTrades[i].sellToken,
                    externalTrades[i].buyToken,
                    externalTrades[i].sellAmount,
                    externalTrades[i].minAmount,
                    validTo
                )
            );
            address swapContract = ClonesWithImmutableArgs.addressOfClone3(salt);
            // slither-disable-next-line calls-loop
            (uint256 claimedSellAmount, uint256 claimedBuyAmount) = CoWSwapClone(swapContract).claim();
            claimedAmounts[i] = [claimedSellAmount, claimedBuyAmount];
            // slither-disable-next-line reentrancy-events
            emit TokenSwapCompleted(
                externalTrades[i].sellToken,
                externalTrades[i].buyToken,
                claimedSellAmount,
                claimedBuyAmount,
                swapContract
            );
            unchecked {
                // Overflow not possible: i is bounded by externalTrades.length
                ++i;
            }
        }
    }

    /// @dev Internal function to create an order on the CoWSwap protocol.
    /// @param sellToken The address of the token to sell.
    /// @param buyToken The address of the token to buy.
    /// @param sellAmount The amount of the sell token.
    /// @param buyAmount The minimum amount of the buy token.
    /// @param validTo The timestamp until which the order is valid.
    function _createOrder(
        address sellToken,
        address buyToken,
        uint256 sellAmount,
        uint256 buyAmount,
        uint32 validTo
    )
        internal
    {
        // Create the order with the receiver being the cloned contract
        bytes32 salt = keccak256(abi.encodePacked(sellToken, buyToken, sellAmount, buyAmount, validTo));
        address swapContract = ClonesWithImmutableArgs.clone3(
            cloneImplementation,
            abi.encodePacked(sellToken, buyToken, sellAmount, buyAmount, uint64(validTo), address(this), address(this)),
            salt
        );
        emit OrderCreated(sellToken, buyToken, sellAmount, buyAmount, validTo, swapContract);
        // slither-disable-start calls-loop
        IERC20(sellToken).safeTransfer(swapContract, sellAmount);
        CoWSwapClone(swapContract).initialize();
        // slither-disable-end calls-loop
    }

    /// @dev Internal function to retrieve the storage for the CoWSwapAdapter.
    /// @return s The storage struct for the CoWSwapAdapter.
    function _cowswapAdapterStorage() internal pure returns (CoWSwapAdapterStorage storage s) {
        bytes32 slot = _COWSWAP_ADAPTER_STORAGE;
        // slither-disable-start assembly
        // solhint-disable-next-line no-inline-assembly
        assembly {
            s.slot := slot
        }
        // slither-disable-end assembly
    }
}
</file>

<file path="package.json">
{
  "name": "cove-contracts-core",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "prepare": "husky && pnpm run forge-deploy:build",
    "clean": "rm -rf cache out crytic-export generated && forge clean",
    "build": "./forge-deploy gen-deployer && forge build --sizes",
    "build:slither": "forge clean && forge build --skip */test/** */script/** */generated/** --build-info",
    "test": "forge test -vvv --gas-report",
    "coverage": "forge coverage --ir-minimum --report lcov",
    "slither": "pnpm run build:slither && slither . --ignore-compile",
    "slither-upgradeability": "for f in $(grep -l -r \"openzeppelin-upgradeable\" src); do c=$(echo \"${f##*/}\" | cut -f 1 -d \".\"); echo \"$c\"; slither-check-upgradeability $f $c; echo; done",
    "semgrep": "semgrep --config p/smart-contracts --exclude deps/ src/",
    "deployLocal": "DEPLOYMENT_CONTEXT=1-fork forge script script/Deployments_Staging.s.sol --rpc-url http://localhost:8545 --broadcast --sender 0x8842fe65A7Db9BB5De6d50e49aF19496da09F9b5 -vvv --unlocked && ./forge-deploy sync;",
    "forge-deploy:clean": "rm -rf deployments/1-fork/*",
    "forge-deploy:build": "cd dependencies/forge-deploy-1 && cargo build --release && cp target/release/forge-deploy ../../forge-deploy",
    "lint": "pnpm run lint:sol && pnpm run prettier:check",
    "lint:fix": "pnpm lint:fix:sol && pnpm run prettier:write",
    "lint:fix:sol": "forge fmt && pnpm run solhint:src --fix && pnpm run solhint:script --fix && pnpm run solhint:test --fix",
    "lint:sol": "forge fmt --check && pnpm run solhint:src && pnpm run solhint:script && pnpm run solhint:test",
    "solhint:src": "npx solhint --noPrompt --config .solhint.json --ignore-path .solhintignore \"src/**/*.sol\"",
    "solhint:script": "npx solhint --noPrompt --config .solhint.script.json --ignore-path .solhintignore \"script/**/*.sol\"",
    "solhint:test": "npx solhint --noPrompt --config .solhint.test.json --ignore-path .solhintignore \"test/**/*.sol\"",
    "prettier:check": "npx prettier --check \"**/*.{json,md,yml,yaml}\"",
    "prettier:write": "npx prettier --write \"**/*.{json,md,yml,yaml}\""
  },
  "lint-staged": {
    "src/!(deps/**/*|interfaces/deps/**/*)/**/*.sol": [
      "forge fmt",
      "npx solhint --fix --noPrompt --config .solhint.json --ignore-path .solhintignore"
    ],
    "script/**/*.sol": [
      "forge fmt",
      "npx solhint --fix --noPrompt --config .solhint.script.json --ignore-path .solhintignore"
    ],
    "test/**/*.sol": [
      "forge fmt",
      "npx solhint --fix --noPrompt --config .solhint.test.json --ignore-path .solhintignore"
    ],
    "**/*.{json,md,yml,yaml}": [
      "prettier --write"
    ]
  },
  "keywords": [],
  "author": "",
  "license": "BUSL-1.1",
  "devDependencies": {
    "@commitlint/cli": "^18.6.0",
    "@commitlint/config-conventional": "^18.6.0",
    "@types/node": "^20.11.14",
    "husky": "^9.0.7",
    "lint-staged": "^15.2.1",
    "prettier": "^3.2.4",
    "solhint": "^5.1.0"
  }
}
</file>

<file path="src/oracles/CurveEMAOracleUnderlying.sol">
// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.28;

import { IERC4626 } from "@openzeppelin/contracts/interfaces/IERC4626.sol";
import { BaseAdapter, Errors, IPriceOracle } from "euler-price-oracle-1/src/adapter/BaseAdapter.sol";
import { ICurvePool } from "euler-price-oracle-1/src/adapter/curve/ICurvePool.sol";
import { Scale, ScaleUtils } from "euler-price-oracle-1/src/lib/ScaleUtils.sol";

/// @title CurveEMAOracleUnderlying
/// @custom:security-contact security@euler.xyz
/// @author Euler Labs (https://www.eulerlabs.com/)
/// @notice Adapter utilizing the EMA price oracle in Curve pools.
contract CurveEMAOracleUnderlying is BaseAdapter {
    /// @inheritdoc IPriceOracle
    // solhint-disable-next-line const-name-snakecase
    string public constant name = "CurveEMAOracleUnderlying";
    /// @notice The address of the Curve pool.
    address public immutable pool;
    /// @notice The address of the base asset.
    address public immutable base;
    /// @notice The address of the quote asset, must be `pool.coins[0]`.
    address public immutable quote;
    /// @notice The index in `price_oracle` corresponding to the base asset.
    /// @dev Note that indices in `price_oracle` are shifted by 1, i.e. `0` corresponds to `coins[1]`.
    uint256 public immutable priceOracleIndex;
    /// @notice The scale factors used for decimal conversions.
    Scale internal immutable _scale;

    error BaseAssetMismatch();
    error QuoteAssetMismatch();

    /// @notice Deploy a CurveEMAOracleUnderlying for a Curve pool.
    /// @param _pool The address of the Curve pool.
    /// @param _base The address of the base asset.
    /// @param _quote The address of the quote asset, must match `pool.coins[0]`.
    /// @param _priceOracleIndex The index in `price_oracle` corresponding to the base asset. If `type(uint256).max`,
    /// then the adapter will call the non-indexed price method `price_oracle()`.
    /// @param isBaseUnderlying Whether the price oracle returns the price of the base asset in the underlying asset.
    /// @param isQuoteUnderlying Whether the price oracle returns the price of the quote asset in the underlying asset.
    /// @dev
    /// IMPORTANT: The isBaseUnderlying and isQuoteUnderlying flags must match the pool's actual asset types.
    /// For example, in the sUSDE/sfrxUSD pool (0x3bd1017929b43c1414be2aca39892590fba4d6e2),
    /// both tokens are ERC4626-compatible, and the pool returns USDE/frxUSD prices.
    ///
    /// Curve pools with ERC4626-compatible tokens (like sUSDE/sfrxUSD) internally handle underlying asset conversions.
    /// The price_oracle() function returns the price in terms of the underlying assets (e.g., USDE/frxUSD).
    /// This behavior is pool-specific and depends on the pool's initialization parameters.
    ///
    /// WARNING: Incorrect configuration of isBaseUnderlying and isQuoteUnderlying will result in
    /// incorrect price calculations. Always verify the pool's asset types off-chain before deployment.
    ///
    /// WARNING: Some StableSwap-NG pools deployed before Dec-12-2023 have a known oracle vulnerability.
    /// See (https://docs.curve.fi/stableswap-exchange/stableswap-ng/pools/oracles/#price-oracles) for more details.
    /// Additionally, verify that the pool has enough liquidity before deploying this adapter.
    // solhint-disable code-complexity
    // slither-disable-next-line locked-ether
    constructor(
        address _pool,
        address _base,
        address _quote,
        uint256 _priceOracleIndex,
        bool isBaseUnderlying,
        bool isQuoteUnderlying
    )
        payable
    {
        if (_pool == address(0)) {
            revert Errors.PriceOracle_InvalidConfiguration();
        }
        if (_base == address(0)) {
            revert Errors.PriceOracle_InvalidConfiguration();
        }
        if (_quote == address(0)) {
            revert Errors.PriceOracle_InvalidConfiguration();
        }
        // The EMA oracle returns a price quoted in `coins[0]`.
        uint256 baseIndex = 0;
        if (_priceOracleIndex == type(uint256).max) {
            baseIndex = 1;
        } else {
            baseIndex = _priceOracleIndex + 1;
        }
        address baseCoin = ICurvePool(_pool).coins(baseIndex);
        address quoteCoin = ICurvePool(_pool).coins(0);

        if (isBaseUnderlying) {
            if (IERC4626(baseCoin).asset() != _base) revert BaseAssetMismatch();
        } else if (baseCoin != _base) {
            revert BaseAssetMismatch();
        }

        if (isQuoteUnderlying) {
            if (IERC4626(quoteCoin).asset() != _quote) revert QuoteAssetMismatch();
        } else if (quoteCoin != _quote) {
            revert QuoteAssetMismatch();
        }

        uint8 baseDecimals = _getDecimals(_base);
        uint8 quoteDecimals = _getDecimals(_quote);
        pool = _pool;
        base = _base;
        quote = _quote;
        priceOracleIndex = _priceOracleIndex;
        _scale = ScaleUtils.calcScale(baseDecimals, quoteDecimals, 18);
    }
    // solhint-enable code-complexity

    /// @notice Get a quote by calling the Curve oracle.
    /// @param inAmount The amount of `base` to convert.
    /// @param _base The token that is being priced.
    /// @param _quote The token that is the unit of account.
    /// @return The converted amount using the Curve EMA oracle.
    function _getQuote(uint256 inAmount, address _base, address _quote) internal view override returns (uint256) {
        bool inverse = ScaleUtils.getDirectionOrRevert(_base, base, _quote, quote);

        uint256 unitPrice;
        if (priceOracleIndex == type(uint256).max) {
            unitPrice = ICurvePool(pool).price_oracle();
        } else {
            unitPrice = ICurvePool(pool).price_oracle(priceOracleIndex);
        }

        return ScaleUtils.calcOutAmount(inAmount, unitPrice, _scale, inverse);
    }
}
</file>

<file path="src/types/BasketManagerStorage.sol">
// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.28;

import { EulerRouter } from "euler-price-oracle/src/EulerRouter.sol";

import { StrategyRegistry } from "src/strategies/StrategyRegistry.sol";

/// @notice Enum representing the status of a rebalance.
enum Status {
    // Rebalance has not started.
    NOT_STARTED,
    // Rebalance has been proposed.
    REBALANCE_PROPOSED,
    // Token swap has been proposed.
    TOKEN_SWAP_PROPOSED,
    // Token swap has been executed.
    TOKEN_SWAP_EXECUTED
}

/// @notice Struct representing the rebalance status.
struct RebalanceStatus {
    // Hash of the baskets and the target weights of them proposed for rebalance.
    bytes32 basketHash;
    // Bitmask representing baskets currently being rebalanced.
    uint256 basketMask;
    // Epoch of the rebalance.
    uint40 epoch;
    // Timestamp of the rebalance proposal.
    uint40 proposalTimestamp;
    // Timestamp of the last action.
    uint40 timestamp;
    // The number of retries for the current rebalance epoch.
    uint8 retryCount;
    // Status of the rebalance.
    Status status;
}

/// @notice Struct representing the storage of the BasketManager contract.
struct BasketManagerStorage {
    /// @notice Address of the StrategyRegistry contract used to resolve and verify basket target weights.
    StrategyRegistry strategyRegistry;
    /// @notice Address of the EulerRouter contract used to fetch oracle quotes for swaps.
    EulerRouter eulerRouter;
    /// @notice Asset registry contract.
    address assetRegistry;
    /// @notice Address of the FeeCollector contract responsible for receiving management fees.
    /// Swap fees are directed to the protocol treasury via feeCollector.protocolTreasury().
    address feeCollector;
    /// @notice The current management fee, expressed in basis points, applied to the total value of each basket token
    /// for a given basket  address.
    mapping(address => uint16) managementFees;
    /// @notice The current swap fee, expressed in basis points, applied to the value of internal swaps.
    uint16 swapFee;
    /// @notice Maximum slippage multiplier for token swaps, denominated in 1e18.
    uint256 slippageLimit;
    /// @notice Maximum deviation multiplier to determine if a set of balances has reached the desired target weights,
    /// denominated in 1e18.
    uint256 weightDeviationLimit;
    /// @notice Address of the BasketToken implementation.
    address basketTokenImplementation;
    /// @notice Array of all basket tokens.
    address[] basketTokens;
    /// @notice Mapping of basket token to asset to balance.
    mapping(address basketToken => mapping(address asset => uint256 balance)) basketBalanceOf;
    /// @notice Mapping of basketId to basket address.
    mapping(bytes32 basketId => address basketToken) basketIdToAddress;
    /// @notice Mapping of basket token to assets.
    mapping(address basketToken => address[] basketAssets) basketAssets;
    /// @notice Mapping of basket token to basket asset to index plus one. 0 means the basket asset does not exist.
    mapping(address basketToken => mapping(address basketAsset => uint256 indexPlusOne)) basketAssetToIndexPlusOne;
    /// @notice Mapping of basket token to index plus one. 0 means the basket token does not exist.
    mapping(address basketToken => uint256 indexPlusOne) basketTokenToIndexPlusOne;
    /// @notice Mapping of basket token to pending redeeming shares.
    mapping(address basketToken => uint256 pendingRedeems) pendingRedeems;
    /// @notice Mapping of asset to collected swap fees.
    mapping(address asset => uint256 fees) collectedSwapFees;
    /// @notice Mapping of basket token to base asset index plus one. 0 means the base asset does not exist.
    mapping(address basket => uint256 indexPlusOne) basketTokenToBaseAssetIndexPlusOne;
    /// @notice Rebalance status.
    RebalanceStatus rebalanceStatus;
    /// @notice A hash of the latest external trades stored during proposeTokenSwap
    bytes32 externalTradesHash;
    /// @notice Address of the token swap adapter.
    address tokenSwapAdapter;
    /// @notice The maximum number of retries for a rebalance epoch.
    uint8 retryLimit;
    /// @notice The minimum time between rebalances.
    uint40 stepDelay;
}
</file>

<file path="process_states.py">
import json
import os
import logging
import copy

# Configure logging
logging.basicConfig(
    level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s"
)

BASE_STATE_FILE = "00_InitialState_1746749783.json"


def load_json_file(file_path):
    with open(file_path, "r") as file:
        return json.load(file)


def save_json_file(data, file_path):
    with open(file_path, "w") as file:
        json.dump(data, file, indent=2)
        file.write("\n")


def convert_hex_nonces(data):
    """Convert hex nonces to decimal in the data"""
    if isinstance(data, dict):
        for key, value in data.items():
            if key == "nonce" and isinstance(value, str) and value.startswith("0x"):
                data[key] = int(value, 16)
            elif isinstance(value, (dict, list)):
                convert_hex_nonces(value)
    elif isinstance(data, list):
        for item in data:
            convert_hex_nonces(item)
    return data


def merge_states(base_state, other_state):
    """Deep merge other_state into base_state"""
    if not isinstance(base_state, dict) or not isinstance(other_state, dict):
        return other_state

    merged = copy.deepcopy(base_state)

    for key, value in other_state.items():
        if key in merged and isinstance(merged[key], dict) and isinstance(value, dict):
            merged[key] = merge_states(merged[key], value)
        else:
            merged[key] = copy.deepcopy(value)

    return merged


def process_folder(folder_path):
    base_file = BASE_STATE_FILE
    base_file_path = os.path.join(folder_path, base_file)

    if not os.path.exists(base_file_path):
        logging.error(f"Base file {base_file} not found in {folder_path}")
        return

    # Load and process base state
    logging.info(f"Loading base state from {base_file}")
    base_state = load_json_file(base_file_path)
    base_state = convert_hex_nonces(base_state)

    # Ensure base state has 'accounts' structure
    if "accounts" not in base_state:
        base_state = {"accounts": base_state}

    # Save the formatted base state back
    save_json_file(base_state, base_file_path)
    logging.info(f"Updated base file {base_file} with formatted JSON")

    # Process all other JSON files
    for filename in os.listdir(folder_path):
        if not filename.endswith(".json") or filename == base_file:
            continue

        file_path = os.path.join(folder_path, filename)
        logging.info(f"Processing {filename}")

        # Load and process current state
        current_state = load_json_file(file_path)
        current_state = convert_hex_nonces(current_state)

        # Ensure current state has 'accounts' structure
        if "accounts" not in current_state:
            current_state = {"accounts": current_state}

        # Merge states
        merged_state = merge_states(base_state, current_state)

        # Save merged state back to original file
        save_json_file(merged_state, file_path)
        logging.info(f"Updated {filename} with merged state")

    logging.info("Finished processing all files")


# Process files in dumpStates directory
process_folder("./dumpStates")
</file>

<file path="soldeer.lock">
[[dependencies]]
name = "@openzeppelin-contracts"
version = "5.1.0"
url = "https://soldeer-revisions.s3.amazonaws.com/@openzeppelin-contracts/5_1_0_19-10-2024_10:28:52_contracts.zip"
checksum = "fd3d1ea561cb27897008aee18ada6e85f248eb161c86e4435272fc2b5777574f"
integrity = "cb6cf6e878f2943b2291d5636a9d72ac51d43d8135896ceb6cf88d36c386f212"

[[dependencies]]
name = "@openzeppelin-contracts-upgradeable"
version = "5.1.0"
url = "https://soldeer-revisions.s3.amazonaws.com/@openzeppelin-contracts-upgradeable/5_1_0_19-10-2024_10:28:58_contracts-upgradeable.zip"
checksum = "87854223d14941d6fda3d78d900217e79e25755ea5bc48beca035766fa6a4e7e"
integrity = "826fb621339dcee4261f848b283ec86364743d3c289d61f621747d95e315215a"

[[dependencies]]
name = "clones-with-immutable-args"
version = "1.1.1"
git = "https://github.com/wighawag/clones-with-immutable-args.git"
rev = "196f1ecc6485c1bf2d41677fa01d3df4927ff9ce"

[[dependencies]]
name = "euler-price-oracle"
version = "1"
git = "https://github.com/Storm-Labs-Inc/euler-price-oracle.git"
rev = "511ee550b082870d248a4e50491a6a9042cb011d"

[[dependencies]]
name = "farming"
version = "3.2.0"
git = "https://github.com/1inch/farming.git"
rev = "b4e59e415352d3233ccd3c339d845a1eb2e1139b"

[[dependencies]]
name = "forge-deploy"
version = "1"
git = "https://github.com/Storm-Labs-Inc/forge-deploy.git"
rev = "2a0c1987ca8a619fd41a0cc546706ebf38a2d4af"

[[dependencies]]
name = "forge-safe"
version = "1"
git = "https://github.com/Storm-Labs-Inc/forge-safe.git"
rev = "8175a6a60844b86d36b3089fe08c584121c7658d"

[[dependencies]]
name = "forge-std"
version = "1.9.6"
url = "https://soldeer-revisions.s3.amazonaws.com/forge-std/1_9_6_01-02-2025_20:49:10_forge-std-1.9.zip"
checksum = "55f341818321b3f925161a72fd0dcd62e4a0a4b66785a7a932bf2bfaf96fb9d1"
integrity = "e9ecdc364d152157431e5df5aa041ffddbe9bb1c1ad81634b1e72df9e23814e8"

[[dependencies]]
name = "lifinance/create3-factory"
version = "0"
git = "https://github.com/lifinance/create3-factory.git"
rev = "93b667acda0dafcafb6e193610b421ea003f46a9"

[[dependencies]]
name = "solady"
version = "0.1.17"
url = "https://soldeer-revisions.s3.amazonaws.com/solady/0_1_17_30-04-2025_11:52:21_solady.zip"
checksum = "e4b8bb231bd4c1625749beb2159a46314ca84df00476da895a287543ffb69c99"
integrity = "71f93f254f7653d8e0ccc3e7405c0b71746c03ee4bf43ad04967301e0977d301"

[[dependencies]]
name = "solidity-utils"
version = "5.3.0"
git = "https://github.com/1inch/solidity-utils.git"
rev = "2a69e2ea6c7551cfae4731752a579de9564b263e"

[[dependencies]]
name = "token-plugins-upgradeable"
version = "1"
git = "https://github.com/Storm-Labs-Inc/token-plugins-upgradeable.git"
rev = "439806ce46954563a921059b6d44f792f4375312"
</file>

<file path="src/FeeCollector.sol">
// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.28;

import { AccessControlEnumerable } from "@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { FixedPointMathLib } from "@solady/utils/FixedPointMathLib.sol";

import { BasketManager } from "src/BasketManager.sol";
import { BasketToken } from "src/BasketToken.sol";
import { Rescuable } from "src/Rescuable.sol";

/// @title FeeCollector
/// @notice Contract to collect fees from the BasketManager and distribute them to sponsors and the protocol treasury
// slither-disable-next-line locked-ether
contract FeeCollector is AccessControlEnumerable, Rescuable {
    /// CONSTANTS ///
    bytes32 private constant _BASKET_TOKEN_ROLE = keccak256("BASKET_TOKEN_ROLE");
    /// @dev Fee split is denominated in 1e4. Also used as maximum fee split for the sponsor.
    uint16 private constant _FEE_SPLIT_DECIMALS = 1e4;

    /// STATE VARIABLES ///
    /// @notice The address of the protocol treasury
    address public protocolTreasury;
    /// @notice The BasketManager contract
    BasketManager internal immutable _basketManager;
    /// @notice Mapping of basket tokens to their sponsor addresses
    mapping(address basketToken => address sponsor) public basketTokenSponsors;
    /// @notice Mapping of basket tokens to their sponsor split percentages
    mapping(address basketToken => uint16 sponsorSplit) public basketTokenSponsorSplits;
    /// @notice Mapping of basket tokens to current claimable treasury fees
    mapping(address basketToken => uint256 claimableFees) public claimableTreasuryFees;
    /// @notice Mapping of basket tokens to the current claimable sponsor fees
    mapping(address basketToken => uint256 claimableFees) public claimableSponsorFees;

    /// EVENTS ///
    /// @notice Emitted when the sponsor for a basket token is set.
    /// @param basketToken The address of the basket token.
    /// @param sponsor The address of the sponsor that was set.
    event SponsorSet(address indexed basketToken, address indexed sponsor);
    /// @notice Emitted when the sponsor fee split for a basket token is set.
    /// @param basketToken The address of the basket token.
    /// @param sponsorSplit The percentage of fees allocated to the sponsor, denominated in _FEE_SPLIT_DECIMALS.
    event SponsorSplitSet(address indexed basketToken, uint16 sponsorSplit);
    /// @notice Emitted when the protocol treasury address is set.
    /// @param treasury The address of the new protocol treasury.
    event TreasurySet(address indexed treasury);

    /// ERRORS ///
    /// @notice Thrown when the address is zero.
    error ZeroAddress();
    /// @notice Thrown when attempting to set a sponsor fee split higher than _MAX_FEE.
    error SponsorSplitTooHigh();
    /// @notice Thrown when attempting to set a sponsor fee split for a basket token with no sponsor.
    error NoSponsor();
    /// @notice Thrown when an unauthorized address attempts to call a restricted function.
    error Unauthorized();
    /// @notice Thrown when attempting to perform an action on an address that is not a basket token.
    error NotBasketToken();
    /// @notice Thrown when attempting to claim treasury fees from an address that is not the protocol treasury.
    error NotTreasury();
    /// @notice Thrown funds attempted to be rescued exceed the available balance.
    error InsufficientFundsToRescue();

    /// @notice Constructor to set the admin, basket manager, and protocol treasury
    /// @param admin The address of the admin
    /// @param basketManager The address of the BasketManager
    /// @param treasury The address of the protocol treasury
    constructor(address admin, address basketManager, address treasury) payable {
        if (admin == address(0)) {
            revert ZeroAddress();
        }
        if (basketManager == address(0)) {
            revert ZeroAddress();
        }
        if (treasury == address(0)) {
            revert ZeroAddress();
        }
        _grantRole(DEFAULT_ADMIN_ROLE, admin);
        _basketManager = BasketManager(basketManager);
        protocolTreasury = treasury;
    }

    /// @notice Set the protocol treasury address
    /// @param treasury The address of the new protocol treasury
    function setProtocolTreasury(address treasury) external onlyRole(DEFAULT_ADMIN_ROLE) {
        if (treasury == address(0)) {
            revert ZeroAddress();
        }
        protocolTreasury = treasury;
        emit TreasurySet(treasury);
    }

    /// @notice Set the sponsor for a given basket token
    /// @param basketToken The address of the basket token
    /// @param sponsor The address of the sponsor
    function setSponsor(address basketToken, address sponsor) external onlyRole(DEFAULT_ADMIN_ROLE) {
        _checkIfBasketToken(basketToken);
        // claim any outstanding fees for previous sponsor
        address currentSponsor = basketTokenSponsors[basketToken];
        basketTokenSponsors[basketToken] = sponsor;
        emit SponsorSet(basketToken, sponsor);
        _claimSponsorFee(basketToken, currentSponsor);
    }

    /// @notice Set the split of management fees given to the sponsor for a given basket token
    /// @param basketToken The address of the basket token
    /// @param sponsorSplit The percentage of fees to give to the sponsor denominated in _FEE_SPLIT_DECIMALS
    function setSponsorSplit(address basketToken, uint16 sponsorSplit) external onlyRole(DEFAULT_ADMIN_ROLE) {
        _checkIfBasketToken(basketToken);
        if (sponsorSplit > _FEE_SPLIT_DECIMALS) {
            revert SponsorSplitTooHigh();
        }
        if (basketTokenSponsors[basketToken] == address(0)) {
            revert NoSponsor();
        }
        basketTokenSponsorSplits[basketToken] = sponsorSplit;
        emit SponsorSplitSet(basketToken, sponsorSplit);
    }

    /// @notice Notify the FeeCollector of the fees collected from the basket token
    /// @param shares The amount of shares collected
    function notifyHarvestFee(uint256 shares) external {
        address basketToken = msg.sender;
        _checkIfBasketToken(basketToken);
        uint16 sponsorFeeSplit = basketTokenSponsorSplits[basketToken];
        if (basketTokenSponsors[basketToken] != address(0)) {
            if (sponsorFeeSplit > 0) {
                uint256 sponsorFee = FixedPointMathLib.mulDiv(shares, sponsorFeeSplit, _FEE_SPLIT_DECIMALS);
                claimableSponsorFees[basketToken] += sponsorFee;
                shares = shares - sponsorFee;
            }
        }
        claimableTreasuryFees[basketToken] += shares;
    }

    /// @notice Claim the sponsor fee for a given basket token, only callable by the sponsor
    /// @param basketToken The address of the basket token
    function claimSponsorFee(address basketToken) external {
        _checkIfBasketToken(basketToken);
        address sponsor = basketTokenSponsors[basketToken];
        if (msg.sender != sponsor) {
            if (!hasRole(DEFAULT_ADMIN_ROLE, msg.sender)) {
                revert Unauthorized();
            }
        }
        // Call harvestManagementFee to ensure that the fee is up to date
        BasketToken(basketToken).harvestManagementFee();
        _claimSponsorFee(basketToken, sponsor);
    }

    /// @notice Claim the treasury fee for a given basket token, only callable by the protocol treasury or admin
    /// @param basketToken The address of the basket token
    function claimTreasuryFee(address basketToken) external {
        _checkIfBasketToken(basketToken);
        address protocolTreasury_ = protocolTreasury;
        if (msg.sender != protocolTreasury_) {
            if (!hasRole(DEFAULT_ADMIN_ROLE, msg.sender)) {
                revert Unauthorized();
            }
        }
        // Call harvestManagementFee to ensure that the fee is up to date
        // slither-disable-next-line reentrancy-no-eth,reentrancy-benign
        BasketToken(basketToken).harvestManagementFee();
        uint256 fee = claimableTreasuryFees[basketToken];
        if (fee > 0) {
            claimableTreasuryFees[basketToken] = 0;
            BasketToken(basketToken).proRataRedeem(fee, protocolTreasury, address(this));
        }
    }

    /// @notice Internal function to claim the sponsor fee for a given basket token. Will immediately redeem the shares
    /// through a proRataRedeem.
    /// @param basketToken The address of the basket token
    /// @param sponsor The address of the sponsor
    function _claimSponsorFee(address basketToken, address sponsor) internal {
        uint256 fee = claimableSponsorFees[basketToken];
        if (fee > 0) {
            if (sponsor != address(0)) {
                claimableSponsorFees[basketToken] = 0;
                BasketToken(basketToken).proRataRedeem(fee, sponsor, address(this));
            }
        }
    }

    /// @notice Rescue ERC20 tokens or ETH from the contract. Reverts if the balance trying to rescue exceeds the
    /// available balance minus claimable fees.
    /// @param token address of the token to rescue. Use zero address for ETH.
    /// @param to address to send the rescued tokens to
    /// @param amount amount of tokens to rescue
    function rescue(IERC20 token, address to, uint256 amount) external onlyRole(DEFAULT_ADMIN_ROLE) {
        address rescueToken = address(token);
        if (
            amount
                > token.balanceOf(address(this)) - claimableTreasuryFees[rescueToken] - claimableSponsorFees[rescueToken]
        ) {
            revert InsufficientFundsToRescue();
        }
        _rescue(token, to, amount);
    }

    /// @notice Internal function to check if a given address is a basket token
    /// @param token The address to check
    function _checkIfBasketToken(address token) internal view {
        if (!_basketManager.hasRole(_BASKET_TOKEN_ROLE, token)) {
            revert NotBasketToken();
        }
    }
}
</file>

<file path="src/operators/BasicRetryOperator.sol">
// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.28;

import { AccessControlEnumerable } from "@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { SafeERC20 } from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { BasketToken } from "src/BasketToken.sol";

/// @title BasicRetryOperator
/// @notice A minimal operator contract compatible with Cove's BasketToken. Once approved via
///         BasketToken.setOperator, anyone can call the handler functions to automatically claim
///         a user's fulfilled deposits/redeems (or their fall-backs) and route the resulting
///         assets/shares back to the original user.
contract BasicRetryOperator is ReentrancyGuard, AccessControlEnumerable {
    using SafeERC20 for IERC20;

    // Errors
    /// @notice Reverts when a provided address is the zero address.
    error ZeroAddress();
    /// @notice Reverts when there is no fulfilled deposit, no fulfilled redeem,
    /// and no fallback amount available to claim.
    error NothingToClaim();

    // Events
    /// @notice Emitted after successfully claiming a user's fulfilled deposit.
    /// @param user        The controller whose fulfilled deposit is being claimed.
    /// @param basketToken The address of the basket token contract the deposit pertains to.
    /// @param assets      The amount of base assets returned to the user.
    /// @param shares      The number of basket shares minted to the user.
    event DepositClaimedForUser(address indexed user, address indexed basketToken, uint256 assets, uint256 shares);
    /// @notice Emitted after successfully claiming a user's fulfilled redemption.
    /// @param user        The controller whose fulfilled redeem is being claimed.
    /// @param basketToken The address of the basket token contract the redeem pertains to.
    /// @param shares      The number of basket shares burned from the user.
    /// @param assets      The amount of base assets returned to the user.
    event RedeemClaimedForUser(address indexed user, address indexed basketToken, uint256 shares, uint256 assets);
    /// @notice Emitted when fallback assets are claimed for a user without retrying the deposit.
    /// @param user        The controller receiving the fallback assets.
    /// @param basketToken The address of the basket token contract the fallback pertains to.
    /// @param assets      The amount of base assets sent to the user.
    event FallbackAssetsClaimedForUser(address indexed user, address indexed basketToken, uint256 assets);
    /// @notice Emitted when fallback assets are claimed and immediately retried
    /// as a new deposit request on behalf of the user.
    /// @param user        The controller whose fallback assets are being retried.
    /// @param basketToken The address of the basket token contract the fallback pertains to.
    /// @param assets      The amount of base assets retried for deposit.
    event FallbackAssetsRetriedForUser(address indexed user, address indexed basketToken, uint256 assets);
    /// @notice Emitted when fallback shares are claimed for a user without retrying the redeem.
    /// @param user        The controller receiving the fallback shares.
    /// @param basketToken The address of the basket token contract the fallback pertains to.
    /// @param shares      The amount of basket shares sent to the user.
    event FallbackSharesClaimedForUser(address indexed user, address indexed basketToken, uint256 shares);
    /// @notice Emitted when fallback shares are claimed and a new redeem request is submitted on behalf of the user.
    /// @param user        The controller whose fallback shares are being retried.
    /// @param basketToken The address of the basket token contract the fallback pertains to.
    /// @param shares      The amount of basket shares retried for redemption.
    event FallbackSharesRetriedForUser(address indexed user, address indexed basketToken, uint256 shares);
    /// @notice Emitted when a user updates their preference for automatically retrying failed deposits.
    /// @param user    The user updating the preference.
    /// @param enabled True if automatic retry for deposits is enabled, false otherwise.
    event DepositRetrySet(address indexed user, bool enabled);
    /// @notice Emitted when a user updates their preference for automatically retrying failed redeems.
    /// @param user    The user updating the preference.
    /// @param enabled True if automatic retry for redeems is enabled, false otherwise.
    event RedeemRetrySet(address indexed user, bool enabled);

    // bit-packed retry flags per user. bit0 => deposit, bit1 => redeem
    // by default, users are considered opted-in for retry paths.
    mapping(address user => uint8 flags) private _retryDisabledFlags;

    uint8 private constant _DEPOSIT_RETRY_DISABLED_FLAG = 1 << 0;
    uint8 private constant _REDEEM_RETRY_DISABLED_FLAG = 1 << 1;

    bytes32 public constant MANAGER_ROLE = keccak256("MANAGER_ROLE");

    /// @notice Constructor for the BasicRetryOperator.
    /// @param admin The address of the admin who can grant and revoke roles.
    /// @param manager The address of the manager who can change token approvals.
    // slither-disable-next-line locked-ether
    constructor(address admin, address manager) payable {
        _grantRole(DEFAULT_ADMIN_ROLE, admin);
        _grantRole(MANAGER_ROLE, manager);
    }

    /*//////////////////////////////////////////////////////////////
                        USER CONFIGURATION HELPERS
    //////////////////////////////////////////////////////////////*/

    /// @notice Enable / disable automatic fallback asset claims when deposits cannot be fulfilled.
    /// @dev    By default, users are considered opted-in for retry paths.
    function setDepositRetry(bool enabled) external {
        if (enabled) _retryDisabledFlags[msg.sender] &= ~_DEPOSIT_RETRY_DISABLED_FLAG;
        else _retryDisabledFlags[msg.sender] |= _DEPOSIT_RETRY_DISABLED_FLAG;
        emit DepositRetrySet(msg.sender, enabled);
    }

    /// @notice Enable / disable automatic fallback share claims when redeems cannot be fulfilled.
    /// @dev    By default, users are considered opted-in for retry paths.
    function setRedeemRetry(bool enabled) external {
        if (enabled) _retryDisabledFlags[msg.sender] &= ~_REDEEM_RETRY_DISABLED_FLAG;
        else _retryDisabledFlags[msg.sender] |= _REDEEM_RETRY_DISABLED_FLAG;
        emit RedeemRetrySet(msg.sender, enabled);
    }

    /// @notice Returns whether the deposit retry is enabled for `user`.
    /// @return true if the deposit retry is enabled for `user`, false otherwise.
    function isDepositRetryEnabled(address user) public view returns (bool) {
        return _retryDisabledFlags[user] & _DEPOSIT_RETRY_DISABLED_FLAG == 0;
    }

    /// @notice Returns whether the redeem retry is enabled for `user`.
    /// @return true if the redeem retry is enabled for `user`, false otherwise.
    function isRedeemRetryEnabled(address user) public view returns (bool) {
        return _retryDisabledFlags[user] & _REDEEM_RETRY_DISABLED_FLAG == 0;
    }

    /*//////////////////////////////////////////////////////////////
                           MAIN HANDLER LOGIC
    //////////////////////////////////////////////////////////////*/

    /// @notice Claims a fulfilled deposit for `user`. If nothing is fulfilled and the caller opted-in,
    ///         attempts to pull fallback assets instead.
    function handleDeposit(address user, address basketToken) external nonReentrant {
        if (user == address(0) || basketToken == address(0)) revert ZeroAddress();

        BasketToken bt = BasketToken(basketToken);
        uint256 assets = bt.maxDeposit(user);

        // If there are assets to claim, claim them and send it back to the user.
        if (assets != 0) {
            uint256 shares = bt.deposit(assets, user, user);
            emit DepositClaimedForUser(user, basketToken, assets, shares);
            return;
        }

        // If there are fallback assets to claim, claim them and send it back to the user.
        uint256 fallbackAssets = bt.claimableFallbackAssets(user);
        // slither-disable-start unused-return
        if (fallbackAssets != 0) {
            // If the user has disabled retry on failed deposits, claim the fallback assets and send it back to the
            // user.
            if (!isDepositRetryEnabled(user)) {
                fallbackAssets = bt.claimFallbackAssets(user, user);
                emit FallbackAssetsClaimedForUser(user, basketToken, fallbackAssets);
                return;
            } else {
                // Otherwise, claim the fallback assets and request a new deposit for the user.
                bt.claimFallbackAssets(address(this), user);
                // Use the balance of the operator to ensure we use the correct amount of assets.
                fallbackAssets = IERC20(bt.asset()).balanceOf(address(this));
                bt.requestDeposit(fallbackAssets, user, address(this));
                emit FallbackAssetsRetriedForUser(user, basketToken, fallbackAssets);
                return;
            }
        }
        // slither-disable-end unused-return
        revert NothingToClaim();
    }

    /// @notice Claims a fulfilled redeem for `user`. If nothing is fulfilled and the caller opted-in,
    ///         attempts to pull fallback shares instead.
    function handleRedeem(address user, address basketToken) external nonReentrant {
        if (user == address(0) || basketToken == address(0)) revert ZeroAddress();

        BasketToken bt = BasketToken(basketToken);
        uint256 shares = bt.maxRedeem(user);

        // If there are shares to claim, claim them and send it back to the user.
        if (shares != 0) {
            uint256 assets = bt.redeem(shares, user, user);
            emit RedeemClaimedForUser(user, basketToken, shares, assets);
            return;
        }

        uint256 fallbackShares = bt.claimableFallbackShares(user);
        // slither-disable-start unused-return
        if (fallbackShares != 0) {
            // If the user has disabled retry on failed redeems, claim the fallback shares and send it back to the user.
            if (!isRedeemRetryEnabled(user)) {
                fallbackShares = bt.claimFallbackShares(user, user);
                emit FallbackSharesClaimedForUser(user, basketToken, fallbackShares);
                return;
            } else {
                // Otherwise, claim the fallback shares and request a new redeem for the user.
                bt.claimFallbackShares(address(this), user);
                // Use the balance of the operator to ensure we use the correct amount of shares.
                fallbackShares = bt.balanceOf(address(this));
                bt.requestRedeem(fallbackShares, user, address(this));
                emit FallbackSharesRetriedForUser(user, basketToken, fallbackShares);
                return;
            }
        }
        // slither-disable-end unused-return
        revert NothingToClaim();
    }

    /*//////////////////////////////////////////////////////////////
                           EXTERNAL HELPERS
    //////////////////////////////////////////////////////////////*/

    /// @notice Approves the asset of `basketToken` to be spent by `basketToken`.
    /// @dev This is necessary to allow retrying deposits to work without approving the asset beforehand every time.
    ///      Call this function after the BasketToken is deployed to approve the asset to be spent by the operator.
    ///      In case the basket token misbehaves, the manager can revoke the approval to prevent the operator from
    ///      being used.
    function approveDeposits(BasketToken basketToken, uint256 amount) external onlyRole(MANAGER_ROLE) {
        IERC20(basketToken.asset()).forceApprove(address(basketToken), amount);
    }
}
</file>

<file path="src/BasketManager.sol">
// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.28;

import { AccessControlEnumerable } from "@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { SafeERC20 } from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import { Pausable } from "@openzeppelin/contracts/utils/Pausable.sol";
import { ReentrancyGuardTransient } from "@openzeppelin/contracts/utils/ReentrancyGuardTransient.sol";
import { EulerRouter } from "euler-price-oracle/src/EulerRouter.sol";

import { AssetRegistry } from "src/AssetRegistry.sol";
import { BasketToken } from "src/BasketToken.sol";
import { FeeCollector } from "src/FeeCollector.sol";
import { Rescuable } from "src/Rescuable.sol";
import { BasketManagerUtils } from "src/libraries/BasketManagerUtils.sol";
import { StrategyRegistry } from "src/strategies/StrategyRegistry.sol";
import { WeightStrategy } from "src/strategies/WeightStrategy.sol";
import { TokenSwapAdapter } from "src/swap_adapters/TokenSwapAdapter.sol";
import { BasketManagerStorage, RebalanceStatus, Status } from "src/types/BasketManagerStorage.sol";
import { ExternalTrade, InternalTrade } from "src/types/Trades.sol";

/// @title BasketManager
/// @notice Contract responsible for managing baskets and their tokens. The accounting for assets per basket is done
/// in the BasketManagerUtils contract.
contract BasketManager is ReentrancyGuardTransient, AccessControlEnumerable, Pausable, Rescuable {
    /// LIBRARIES ///
    using BasketManagerUtils for BasketManagerStorage;
    using SafeERC20 for IERC20;

    /// CONSTANTS ///
    /// @notice Manager role. Managers can create new baskets.
    bytes32 private constant _MANAGER_ROLE = keccak256("MANAGER_ROLE");
    /// @notice Pauser role.
    bytes32 private constant _PAUSER_ROLE = keccak256("PAUSER_ROLE");
    /// @notice Rebalance Proposer role. Rebalance proposers can propose a new rebalance.
    bytes32 private constant _REBALANCE_PROPOSER_ROLE = keccak256("REBALANCE_PROPOSER_ROLE");
    /// @notice TokenSwap Proposer role. Token swap proposers can propose a new token swap.
    bytes32 private constant _TOKENSWAP_PROPOSER_ROLE = keccak256("TOKENSWAP_PROPOSER_ROLE");
    /// @notice TokenSwap Executor role. Token swap executors can execute a token swap.
    bytes32 private constant _TOKENSWAP_EXECUTOR_ROLE = keccak256("TOKENSWAP_EXECUTOR_ROLE");
    /// @notice Basket token role. Given to the basket token contracts when they are created.
    bytes32 private constant _BASKET_TOKEN_ROLE = keccak256("BASKET_TOKEN_ROLE");
    /// @notice Role given to a timelock contract that can set critical parameters.
    bytes32 private constant _TIMELOCK_ROLE = keccak256("TIMELOCK_ROLE");
    /// @notice Maximum management fee (30%) in BPS denominated in 1e4.
    uint16 private constant _MAX_MANAGEMENT_FEE = 3000;
    /// @notice Maximum swap fee (5%) in BPS denominated in 1e4.
    uint16 private constant _MAX_SWAP_FEE = 500;
    /// @notice Minimum time between steps in a rebalance in seconds.
    uint40 private constant _MIN_STEP_DELAY = 1 minutes;
    /// @notice Maximum time between steps in a rebalance in seconds.
    uint40 private constant _MAX_STEP_DELAY = 60 minutes;
    /// @notice Maximum bound of retry count.
    uint8 private constant _MAX_RETRY_COUNT = 10;
    /// @notice Maximum bound of slippage
    uint256 private constant _MAX_SLIPPAGE_LIMIT = 0.5e18;
    /// @notice Maximum bound of weight deviation
    uint256 private constant _MAX_WEIGHT_DEVIATION_LIMIT = 0.5e18;

    /// STATE VARIABLES ///
    /// @notice Struct containing the BasketManagerUtils contract and other necessary data.
    BasketManagerStorage private _bmStorage;

    /// EVENTS ///
    /// @notice Emitted when the swap fee is set.
    event SwapFeeSet(uint16 oldFee, uint16 newFee);
    /// @notice Emitted when the management fee is set.
    event ManagementFeeSet(address indexed basket, uint16 oldFee, uint16 newFee);
    /// @notice Emitted when the TokenSwapAdapter contract is set.
    event TokenSwapAdapterSet(address oldAdapter, address newAdapter);
    /// @notice Emitted when a new basket is created.
    event BasketCreated(
        address indexed basket, string basketName, string symbol, address baseAsset, uint256 bitFlag, address strategy
    );
    /// @notice Emitted when the bitFlag of a basket is updated.
    event BasketBitFlagUpdated(
        address indexed basket, uint256 oldBitFlag, uint256 newBitFlag, bytes32 oldId, bytes32 newId
    );
    /// @notice Emitted when a token swap is proposed during a rebalance.
    event TokenSwapProposed(uint40 indexed epoch, InternalTrade[] internalTrades, ExternalTrade[] externalTrades);
    /// @notice Emitted when a token swap is executed during a rebalance.
    event TokenSwapExecuted(uint40 indexed epoch, ExternalTrade[] externalTrades);
    /// @notice Emitted when the step delay is set.
    event StepDelaySet(uint40 oldDelay, uint40 newDelay);
    /// @notice Emitted when the retry limit is set.
    event RetryLimitSet(uint8 oldLimit, uint8 newLimit);
    /// @notice Emitted when the max slippage is set.
    event SlippageLimitSet(uint256 oldSlippage, uint256 newSlippage);
    /// @notice Emitted when the max weight deviation is set
    event WeightDeviationLimitSet(uint256 oldDeviation, uint256 newDeviation);

    /// ERRORS ///
    /// @notice Thrown when the address is zero.
    error ZeroAddress();
    /// @notice Thrown when attempting to execute a token swap without first proposing it.
    error TokenSwapNotProposed();
    /// @notice Thrown when the call to `TokenSwapAdapter.executeTokenSwap` fails.
    error ExecuteTokenSwapFailed();
    /// @notice Thrown when the provided hash does not match the expected hash.
    /// @dev This error is used to validate the integrity of data passed between functions.
    error InvalidHash();
    /// @notice Thrown when the provided external trades do not match the hash stored during the token swap proposal.
    /// @dev This error prevents executing a token swap with different parameters than originally proposed.
    error ExternalTradesHashMismatch();
    /// @notice Thrown when attempting to perform an action that requires no active rebalance.
    /// @dev Certain actions, like setting the token swap adapter, are disallowed during an active rebalance.
    error MustWaitForRebalanceToComplete();
    /// @notice Thrown when a caller attempts to access a function without proper authorization.
    /// @dev This error is thrown when a caller lacks the required role to perform an action.
    error Unauthorized();
    /// @notice Thrown when attempting to set an invalid management fee.
    /// @dev The management fee must not exceed `_MAX_MANAGEMENT_FEE`.
    error InvalidManagementFee();
    /// @notice Thrown when attempting to set an invalid swap fee.
    /// @dev The swap fee must not exceed `_MAX_SWAP_FEE`.
    error InvalidSwapFee();
    /// @notice Thrown when attempting to perform an action on a non-existent basket token.
    /// @dev This error is thrown when the provided basket token is not in the `basketTokenToIndexPlusOne` mapping.
    error BasketTokenNotFound();
    /// @notice Thrown when attempting to update the bitFlag to the same value.
    error BitFlagMustBeDifferent();
    /// @notice Thrown when attempting to update the bitFlag without including the current bitFlag.
    error BitFlagMustIncludeCurrent();
    /// @notice Thrown when attempting to update the bitFlag to a value not supported by the strategy.
    error BitFlagUnsupportedByStrategy();
    /// @notice Thrown when attempting to create a basket with an ID that already exists.
    error BasketIdAlreadyExists();
    /// @notice Thrown when attempting to rescue an asset to a basket that already exists in the asset universe.
    error AssetExistsInUniverse();
    /// @notice Thrown when the low-level call in the `execute` function fails.
    /// @dev This error indicates that the target contract rejected the call or execution failed unexpectedly.
    error ExecutionFailed();
    /// @notice Thrown when attempting to set an invalid step delay outside the bounds of `_MIN_STEP_DELAY` and
    /// `_MAX_STEP_DELAY`.
    error InvalidStepDelay();
    /// @notice Thrown when attempting to set an invalid retry limit outside the bounds of 0 and `_MAX_RETRY_COUNT`.
    error InvalidRetryCount();
    /// @notice Thrown when attempting to set a slippage limit greater than `_MAX_SLIPPAGE_LIMIT`.
    error InvalidSlippageLimit();
    /// @notice Thrown when attempting to set a weight deviation greater than `_MAX_WEIGHT_DEVIATION_LIMIT`.
    error InvalidWeightDeviationLimit();
    /// @notice Thrown when attempting to execute a token swap with empty external trades array
    error EmptyExternalTrades();

    /// @notice Initializes the contract with the given parameters.
    /// @param basketTokenImplementation Address of the basket token implementation.
    /// @param eulerRouter_ Address of the oracle registry.
    /// @param strategyRegistry_ Address of the strategy registry.
    /// @param assetRegistry_ Address of the asset registry.
    /// @param admin Address of the admin.
    /// @param feeCollector_ Address of the fee collector.
    constructor(
        address basketTokenImplementation,
        address eulerRouter_,
        address strategyRegistry_,
        address assetRegistry_,
        address admin,
        address feeCollector_
    )
        payable
    {
        // Checks
        if (basketTokenImplementation == address(0)) revert ZeroAddress();
        if (eulerRouter_ == address(0)) revert ZeroAddress();
        if (strategyRegistry_ == address(0)) revert ZeroAddress();
        if (admin == address(0)) revert ZeroAddress();
        if (feeCollector_ == address(0)) revert ZeroAddress();
        if (assetRegistry_ == address(0)) revert ZeroAddress();

        // Effects
        _grantRole(DEFAULT_ADMIN_ROLE, admin);
        // Initialize the BasketManagerUtils struct
        _bmStorage.strategyRegistry = StrategyRegistry(strategyRegistry_);
        _bmStorage.eulerRouter = EulerRouter(eulerRouter_);
        _bmStorage.assetRegistry = assetRegistry_;
        _bmStorage.basketTokenImplementation = basketTokenImplementation;
        _bmStorage.feeCollector = feeCollector_;
        _bmStorage.retryLimit = 3;
        _bmStorage.stepDelay = 15 minutes;
        _bmStorage.slippageLimit = 0.05e18;
        _bmStorage.weightDeviationLimit = 0.05e18;
    }

    /// PUBLIC FUNCTIONS ///

    /// @notice Returns the index of the basket token in the basketTokens array.
    /// @dev Reverts if the basket token does not exist.
    /// @param basketToken Address of the basket token.
    /// @return Index of the basket token.
    function basketTokenToIndex(address basketToken) public view returns (uint256) {
        return _bmStorage.basketTokenToIndex(basketToken);
    }

    /// @notice Returns the index of the given asset in the basket.
    /// @dev Reverts if the basket asset does not exist.
    /// @param basketToken Address of the basket token.
    /// @param asset Address of the asset.
    /// @return Index of the asset in the basket.
    function getAssetIndexInBasket(address basketToken, address asset) public view returns (uint256) {
        return _bmStorage.getAssetIndexInBasket(basketToken, asset);
    }

    /// @notice Returns the index of the base asset in the given basket token
    /// @dev Reverts if the basket token does not exist
    /// @param basketToken Address of the basket token
    /// @return Index of the base asset in the basket token's assets array
    function basketTokenToBaseAssetIndex(address basketToken) public view returns (uint256) {
        uint256 index = _bmStorage.basketTokenToBaseAssetIndexPlusOne[basketToken];
        if (index == 0) {
            revert BasketTokenNotFound();
        }
        return index - 1;
    }

    /// @notice Returns the number of basket tokens.
    /// @return Number of basket tokens.
    function numOfBasketTokens() public view returns (uint256) {
        return _bmStorage.basketTokens.length;
    }

    /// @notice Returns all basket token addresses.
    /// @return Array of basket token addresses.
    function basketTokens() external view returns (address[] memory) {
        return _bmStorage.basketTokens;
    }

    /// @notice Returns the basket token address with the given basketId.
    /// @dev The basketId is the keccak256 hash of the bitFlag and strategy address.
    /// @param basketId Basket ID.
    function basketIdToAddress(bytes32 basketId) external view returns (address) {
        return _bmStorage.basketIdToAddress[basketId];
    }

    /// @notice Returns the balance of the given asset in the given basket.
    /// @param basketToken Address of the basket token.
    /// @param asset Address of the asset.
    /// @return Balance of the asset in the basket.
    function basketBalanceOf(address basketToken, address asset) external view returns (uint256) {
        return _bmStorage.basketBalanceOf[basketToken][asset];
    }

    /// @notice Returns the current rebalance status.
    /// @return Rebalance status struct with the following fields:
    ///   - basketHash: Hash of the baskets and target weights proposed for rebalance
    ///   - basketMask: Bitmask representing baskets currently being rebalanced
    ///   - epoch: Epoch of the rebalance
    ///   - timestamp: Timestamp of the last action
    ///   - retryCount: Number of retries for the current rebalance epoch
    ///   - status: Status enum of the rebalance
    function rebalanceStatus() external view returns (RebalanceStatus memory) {
        return _bmStorage.rebalanceStatus;
    }

    /// @notice Returns the hash of the external trades stored during proposeTokenSwap
    /// @return Hash of the external trades
    function externalTradesHash() external view returns (bytes32) {
        return _bmStorage.externalTradesHash;
    }

    /// @notice Returns the address of the basket token implementation.
    /// @return Address of the basket token implementation.
    function eulerRouter() external view returns (address) {
        return address(_bmStorage.eulerRouter);
    }

    /// @notice Returns the address of the feeCollector contract.
    /// @return Address of the feeCollector.
    function feeCollector() external view returns (address) {
        return address(_bmStorage.feeCollector);
    }

    /// @notice Returns the management fee of a basket in BPS denominated in 1e4.
    /// @param basket Address of the basket.
    /// @return Management fee.
    function managementFee(address basket) external view returns (uint16) {
        return _bmStorage.managementFees[basket];
    }

    /// @notice Returns the swap fee in BPS denominated in 1e4.
    /// @return Swap fee.
    function swapFee() external view returns (uint16) {
        return _bmStorage.swapFee;
    }

    /// @notice Returns the slippage limit for token swaps denominated in 1e18.
    /// @return Maximum slippage.
    function slippageLimit() external view returns (uint256) {
        return _bmStorage.slippageLimit;
    }

    /// @notice Returns the weight deviation limit for token swaps denominated in 1e18.
    /// @return Maximum weight deviation.
    function weightDeviationLimit() external view returns (uint256) {
        return _bmStorage.weightDeviationLimit;
    }

    /// @notice Returns the address of the asset registry.
    /// @return Address of the asset registry.
    function assetRegistry() external view returns (address) {
        return _bmStorage.assetRegistry;
    }

    /// @notice Returns the address of the strategy registry.
    /// @return Address of the strategy registry.
    function strategyRegistry() external view returns (address) {
        return address(_bmStorage.strategyRegistry);
    }

    /// @notice Returns the address of the token swap adapter.
    /// @return Address of the token swap adapter.
    function tokenSwapAdapter() external view returns (address) {
        return _bmStorage.tokenSwapAdapter;
    }

    /// @notice Returns the retry count for the current rebalance epoch.
    /// @return Retry count.
    function retryCount() external view returns (uint8) {
        return _bmStorage.rebalanceStatus.retryCount;
    }

    /// @notice Returns the maximum retry limit for the rebalance process.
    /// @return Retry limit.
    function retryLimit() external view returns (uint8) {
        return _bmStorage.retryLimit;
    }

    /// @notice Returns the step delay for the rebalance process.
    /// @dev The step delay defines the minimum time interval, in seconds, required between consecutive steps in a
    /// rebalance. This ensures sufficient time for external trades or other operations to settle before proceeding.
    /// @return Step delay duration in seconds.
    function stepDelay() external view returns (uint40) {
        return _bmStorage.stepDelay;
    }

    /// @notice Returns the addresses of all assets in the given basket.
    /// @param basket Address of the basket.
    /// @return Array of asset addresses.
    function basketAssets(address basket) external view returns (address[] memory) {
        return _bmStorage.basketAssets[basket];
    }

    /// @notice Returns the collected swap fees for the given asset.
    /// @param asset Address of the asset.
    /// @return Collected swap fees.
    function collectedSwapFees(address asset) external view returns (uint256) {
        return _bmStorage.collectedSwapFees[asset];
    }

    /// @notice Creates a new basket token with the given parameters.
    /// @param basketName Name of the basket.
    /// @param symbol Symbol of the basket.
    /// @param bitFlag Asset selection bitFlag for the basket.
    /// @param strategy Address of the strategy contract for the basket.
    function createNewBasket(
        string calldata basketName,
        string calldata symbol,
        address baseAsset,
        uint256 bitFlag,
        address strategy
    )
        external
        payable
        whenNotPaused
        onlyRole(_MANAGER_ROLE)
        returns (address basket)
    {
        basket = _bmStorage.createNewBasket(basketName, symbol, baseAsset, bitFlag, strategy);
        _grantRole(_BASKET_TOKEN_ROLE, basket);
        emit BasketCreated(basket, basketName, symbol, baseAsset, bitFlag, strategy);
    }

    /// @notice Proposes a rebalance for the given baskets. The rebalance is proposed if the difference between the
    /// target balance and the current balance of any asset in the basket is more than 500 USD.
    /// @param basketsToRebalance Array of basket addresses to rebalance.
    function proposeRebalance(address[] calldata basketsToRebalance)
        external
        onlyRole(_REBALANCE_PROPOSER_ROLE)
        nonReentrant
        whenNotPaused
    {
        _bmStorage.proposeRebalance(basketsToRebalance);
    }

    /// @notice Proposes a set of internal trades and external trades to rebalance the given baskets.
    /// If the proposed token swap results are not close to the target balances, this function will revert.
    /// @dev This function can only be called after proposeRebalance.
    /// @param internalTrades Array of internal trades to execute.
    /// @param externalTrades Array of external trades to execute.
    /// @param basketsToRebalance Array of basket addresses currently being rebalanced.
    /// @param targetWeights Array of target weights for the baskets.
    function proposeTokenSwap(
        InternalTrade[] calldata internalTrades,
        ExternalTrade[] calldata externalTrades,
        address[] calldata basketsToRebalance,
        uint64[][] calldata targetWeights,
        address[][] calldata basketAssets_
    )
        external
        onlyRole(_TOKENSWAP_PROPOSER_ROLE)
        nonReentrant
        whenNotPaused
    {
        _bmStorage.proposeTokenSwap(internalTrades, externalTrades, basketsToRebalance, targetWeights, basketAssets_);
        emit TokenSwapProposed(_bmStorage.rebalanceStatus.epoch, internalTrades, externalTrades);
    }

    /// @notice Executes the token swaps proposed in proposeTokenSwap and updates the basket balances.
    /// @param externalTrades Array of external trades to execute.
    /// @param data Encoded data for the token swap.
    /// @dev This function can only be called after proposeTokenSwap.
    // slither-disable-next-line controlled-delegatecall
    function executeTokenSwap(
        ExternalTrade[] calldata externalTrades,
        bytes calldata data
    )
        external
        onlyRole(_TOKENSWAP_EXECUTOR_ROLE)
        nonReentrant
        whenNotPaused
    {
        if (_bmStorage.rebalanceStatus.status != Status.TOKEN_SWAP_PROPOSED) {
            revert TokenSwapNotProposed();
        }
        address swapAdapter = _bmStorage.tokenSwapAdapter;
        if (swapAdapter == address(0)) {
            revert ZeroAddress();
        }
        if (externalTrades.length == 0) {
            revert EmptyExternalTrades();
        }
        // Check if the external trades match the hash from proposeTokenSwap
        if (keccak256(abi.encode(externalTrades)) != _bmStorage.externalTradesHash) {
            revert ExternalTradesHashMismatch();
        }
        _bmStorage.rebalanceStatus.status = Status.TOKEN_SWAP_EXECUTED;
        _bmStorage.rebalanceStatus.timestamp = uint40(block.timestamp);

        // solhint-disable avoid-low-level-calls
        // slither-disable-next-line low-level-calls
        (bool success,) =
            swapAdapter.delegatecall(abi.encodeCall(TokenSwapAdapter.executeTokenSwap, (externalTrades, data)));
        // solhint-enable avoid-low-level-calls
        if (!success) {
            revert ExecuteTokenSwapFailed();
        }

        emit TokenSwapExecuted(_bmStorage.rebalanceStatus.epoch, externalTrades);
    }

    /// @notice Sets the address of the TokenSwapAdapter contract used to execute token swaps.
    /// @param tokenSwapAdapter_ Address of the TokenSwapAdapter contract.
    /// @dev Only callable by the timelock.
    function setTokenSwapAdapter(address tokenSwapAdapter_) external onlyRole(_TIMELOCK_ROLE) {
        if (tokenSwapAdapter_ == address(0)) {
            revert ZeroAddress();
        }
        _revertIfCurrentlyRebalancing();
        address oldTokenSwapAdapter = _bmStorage.tokenSwapAdapter;
        _bmStorage.tokenSwapAdapter = tokenSwapAdapter_;
        emit TokenSwapAdapterSet(oldTokenSwapAdapter, tokenSwapAdapter_);
    }

    /// @notice Completes the rebalance for the given baskets. The rebalance can be completed if it has been more than
    /// 15 minutes since the last action.
    /// @param basketsToRebalance Array of basket addresses proposed for rebalance.
    /// @param targetWeights Array of target weights for the baskets.
    function completeRebalance(
        ExternalTrade[] calldata externalTrades,
        address[] calldata basketsToRebalance,
        uint64[][] calldata targetWeights,
        address[][] calldata basketAssets_
    )
        external
        nonReentrant
        whenNotPaused
    {
        _bmStorage.completeRebalance(externalTrades, basketsToRebalance, targetWeights, basketAssets_);
    }

    /// FALLBACK REDEEM LOGIC ///

    /// @notice Fallback redeem function to redeem shares when the rebalance is not in progress. Redeems the shares for
    /// each underlying asset in the basket pro-rata to the amount of shares redeemed.
    /// @dev This function can only be called by basket tokens.
    /// @param totalSupplyBefore Total supply of the basket token before the shares were burned.
    /// @param burnedShares Amount of shares burned.
    /// @param to Address to send the redeemed assets to.
    function proRataRedeem(
        uint256 totalSupplyBefore,
        uint256 burnedShares,
        address to
    )
        public
        nonReentrant
        whenNotPaused
        onlyRole(_BASKET_TOKEN_ROLE)
    {
        _bmStorage.proRataRedeem(totalSupplyBefore, burnedShares, to);
    }

    /// FEE FUNCTIONS ///

    /// @notice Set the management fee to be given to the treausry on rebalance.
    /// @param basket Address of the basket token.
    /// @param managementFee_ Management fee in BPS denominated in 1e4.
    /// @dev Only callable by the timelock.
    /// @dev Setting the management fee of the 0 address will set the default management fee for newly created baskets.
    function setManagementFee(address basket, uint16 managementFee_) external onlyRole(_TIMELOCK_ROLE) {
        if (managementFee_ > _MAX_MANAGEMENT_FEE) {
            revert InvalidManagementFee();
        }

        // Check if the basket is currently rebalancing
        if (basket != address(0)) {
            uint256 indexPlusOne = _bmStorage.basketTokenToIndexPlusOne[basket];
            if (indexPlusOne == 0) {
                revert BasketTokenNotFound();
            }
            if ((_bmStorage.rebalanceStatus.basketMask & (1 << indexPlusOne - 1)) != 0) {
                revert MustWaitForRebalanceToComplete();
            }
            // slither-disable-next-line reentrancy-no-eth
            BasketToken(basket).harvestManagementFee();
        }
        uint16 oldManagementFee = _bmStorage.managementFees[basket];
        _bmStorage.managementFees[basket] = managementFee_;
        // slither-disable-next-line reentrancy-events
        emit ManagementFeeSet(basket, oldManagementFee, managementFee_);
    }

    /// @notice Set the swap fee to be given to the treasury on rebalance.
    /// @param swapFee_ Swap fee in BPS denominated in 1e4.
    /// @dev Only callable by the timelock.
    function setSwapFee(uint16 swapFee_) external onlyRole(_TIMELOCK_ROLE) {
        if (swapFee_ > _MAX_SWAP_FEE) {
            revert InvalidSwapFee();
        }
        _revertIfCurrentlyRebalancing();
        uint16 oldSwapFee = _bmStorage.swapFee;
        _bmStorage.swapFee = swapFee_;
        emit SwapFeeSet(oldSwapFee, swapFee_);
    }

    /// @notice Updates the step delay for the rebalance process.
    /// @dev The step delay defines the minimum time interval, in seconds, required between consecutive steps in a
    /// rebalance. This ensures sufficient time for external trades or other operations to settle before proceeding.
    /// @param stepDelay_ The new step delay duration in seconds.
    function setStepDelay(uint40 stepDelay_) external onlyRole(_TIMELOCK_ROLE) {
        if (stepDelay_ < _MIN_STEP_DELAY || stepDelay_ > _MAX_STEP_DELAY) {
            revert InvalidStepDelay();
        }
        _revertIfCurrentlyRebalancing();
        uint40 oldStepDelay = _bmStorage.stepDelay;
        _bmStorage.stepDelay = stepDelay_;
        emit StepDelaySet(oldStepDelay, stepDelay_);
    }

    /// @notice Sets the retry limit for future rebalances.
    /// @param retryLimit_ New retry limit.
    function setRetryLimit(uint8 retryLimit_) external onlyRole(_TIMELOCK_ROLE) {
        if (retryLimit_ > _MAX_RETRY_COUNT) {
            revert InvalidRetryCount();
        }
        _revertIfCurrentlyRebalancing();
        uint8 oldRetryLimit = _bmStorage.retryLimit;
        _bmStorage.retryLimit = retryLimit_;
        emit RetryLimitSet(oldRetryLimit, retryLimit_);
    }

    /// @notice Sets the slippage multiplier for token swaps.
    /// @param slippageLimit_ New slippage limit.
    function setSlippageLimit(uint256 slippageLimit_) external onlyRole(_TIMELOCK_ROLE) {
        if (slippageLimit_ > _MAX_SLIPPAGE_LIMIT) {
            revert InvalidSlippageLimit();
        }
        _revertIfCurrentlyRebalancing();
        uint256 oldSlippageLimit = _bmStorage.slippageLimit;
        _bmStorage.slippageLimit = slippageLimit_;
        emit SlippageLimitSet(oldSlippageLimit, slippageLimit_);
    }

    /// @notice Sets the deviation multiplier to determine if a set of balances has reached the desired target.
    /// @param weightDeviationLimit_ New weight deviation limit.
    function setWeightDeviation(uint256 weightDeviationLimit_) external onlyRole(_TIMELOCK_ROLE) {
        if (weightDeviationLimit_ > _MAX_WEIGHT_DEVIATION_LIMIT) {
            revert InvalidWeightDeviationLimit();
        }
        _revertIfCurrentlyRebalancing();
        uint256 oldWeightDeviationLimit = _bmStorage.weightDeviationLimit;
        _bmStorage.weightDeviationLimit = weightDeviationLimit_;
        emit WeightDeviationLimitSet(oldWeightDeviationLimit, weightDeviationLimit_);
    }

    /// @notice Claims the swap fee for the given asset and sends it to protocol treasury defined in the FeeCollector.
    /// @param asset Address of the asset to collect the swap fee for.
    function collectSwapFee(address asset) external onlyRole(_MANAGER_ROLE) returns (uint256 collectedFees) {
        collectedFees = _bmStorage.collectedSwapFees[asset];
        if (collectedFees != 0) {
            _bmStorage.collectedSwapFees[asset] = 0;
            IERC20(asset).safeTransfer(FeeCollector(_bmStorage.feeCollector).protocolTreasury(), collectedFees);
        }
    }

    /// @notice Updates the bitFlag for the given basket.
    /// @param basket Address of the basket.
    /// @param bitFlag New bitFlag. It must be inclusive of the current bitFlag.
    // solhint-disable-next-line code-complexity
    function updateBitFlag(address basket, uint256 bitFlag) external onlyRole(_TIMELOCK_ROLE) {
        // Checks
        // Check if basket exists
        uint256 indexPlusOne = _bmStorage.basketTokenToIndexPlusOne[basket];
        if (indexPlusOne == 0) {
            revert BasketTokenNotFound();
        }
        uint256 currentBitFlag = BasketToken(basket).bitFlag();
        if (currentBitFlag == bitFlag) {
            revert BitFlagMustBeDifferent();
        }
        // Check if basket is currently rebalancing
        if ((_bmStorage.rebalanceStatus.basketMask & (1 << indexPlusOne - 1)) != 0) {
            revert MustWaitForRebalanceToComplete();
        }
        // Check if the new bitFlag is inclusive of the current bitFlag
        if ((currentBitFlag & bitFlag) != currentBitFlag) {
            revert BitFlagMustIncludeCurrent();
        }
        address strategy = BasketToken(basket).strategy();
        if (!WeightStrategy(strategy).supportsBitFlag(bitFlag)) {
            revert BitFlagUnsupportedByStrategy();
        }
        bytes32 newId = keccak256(abi.encodePacked(bitFlag, strategy));
        if (_bmStorage.basketIdToAddress[newId] != address(0)) {
            revert BasketIdAlreadyExists();
        }
        // Remove the old bitFlag mapping and add the new bitFlag mapping
        bytes32 oldId = keccak256(abi.encodePacked(currentBitFlag, strategy));
        _bmStorage.basketIdToAddress[oldId] = address(0);
        _bmStorage.basketIdToAddress[newId] = basket;
        // Update the basketAssets and the basketAssetToIndexPlusOne mapping
        address[] memory assets = AssetRegistry(_bmStorage.assetRegistry).getAssets(bitFlag);
        address baseAsset = _bmStorage.basketAssets[basket][_bmStorage.basketTokenToBaseAssetIndexPlusOne[basket] - 1];
        _bmStorage.basketAssets[basket] = assets;
        uint256 length = assets.length;
        for (uint256 i = 0; i < length;) {
            // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop
            _bmStorage.basketAssetToIndexPlusOne[basket][assets[i]] = i + 1;
            // Update the base asset index
            if (assets[i] == baseAsset) {
                // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop
                _bmStorage.basketTokenToBaseAssetIndexPlusOne[basket] = i + 1;
            }
            unchecked {
                // Overflow not possible: i is less than length
                ++i;
            }
        }
        emit BasketBitFlagUpdated(basket, currentBitFlag, bitFlag, oldId, newId);
        // Update the bitFlag in the BasketToken contract
        BasketToken(basket).setBitFlag(bitFlag);
    }

    /// @notice Reverts if a rebalance is currently in progress.
    function _revertIfCurrentlyRebalancing() private view {
        if (_bmStorage.rebalanceStatus.status != Status.NOT_STARTED) {
            revert MustWaitForRebalanceToComplete();
        }
    }

    /// PAUSING FUNCTIONS ///

    /// @notice Pauses the contract. Callable by DEFAULT_ADMIN_ROLE or PAUSER_ROLE.
    function pause() external {
        if (!(hasRole(_PAUSER_ROLE, msg.sender) || hasRole(DEFAULT_ADMIN_ROLE, msg.sender))) {
            revert Unauthorized();
        }
        _pause();
    }

    /// @notice Unpauses the contract. Only callable by DEFAULT_ADMIN_ROLE.
    function unpause() external onlyRole(DEFAULT_ADMIN_ROLE) {
        _unpause();
    }

    /// @notice Allows the timelock to execute an arbitrary function call on a target contract.
    /// @dev Can only be called by addresses with the timelock role. Reverts if the execution fails. Reverts if the
    /// target of the call is an asset that is active in the asset registry.
    /// @param target The address of the target contract.
    /// @param data The calldata to send to the target contract.
    /// @param value The amount of Ether (in wei) to send with the call.
    /// @return result The data returned from the function call.
    function execute(
        address target,
        bytes calldata data,
        uint256 value
    )
        external
        payable
        onlyRole(_TIMELOCK_ROLE)
        returns (bytes memory)
    {
        // Checks
        if (target == address(0)) revert ZeroAddress();
        AssetRegistry.AssetStatus status = AssetRegistry(_bmStorage.assetRegistry).getAssetStatus(address(target));
        if (status != AssetRegistry.AssetStatus.DISABLED) {
            revert AssetExistsInUniverse();
        }

        // Interactions
        // slither-disable-start arbitrary-send-eth
        // slither-disable-start low-level-calls
        // nosemgrep: solidity.security.arbitrary-low-level-call.arbitrary-low-level-call
        (bool success, bytes memory result) = target.call{ value: value }(data);
        // slither-disable-end arbitrary-send-eth
        // slither-disable-end low-level-calls
        if (!success) {
            revert ExecutionFailed();
        }
        return result;
    }

    /// @notice Allows the admin to rescue tokens mistakenly sent to the contract.
    /// @dev Can only be called by the admin. This function is intended for use in case of accidental token
    /// transfers into the contract. It will revert if the token is part of the enabled asset universe.
    /// @param token The ERC20 token to rescue, or address(0) for ETH.
    /// @param to The recipient address of the rescued tokens.
    /// @param balance The amount of tokens to rescue. If set to 0, the entire balance will be rescued.
    function rescue(IERC20 token, address to, uint256 balance) external onlyRole(DEFAULT_ADMIN_ROLE) {
        if (address(token) != address(0)) {
            AssetRegistry.AssetStatus status = AssetRegistry(_bmStorage.assetRegistry).getAssetStatus(address(token));
            if (status != AssetRegistry.AssetStatus.DISABLED) {
                revert AssetExistsInUniverse();
            }
        }

        _rescue(token, to, balance);
    }
}
</file>

<file path="src/BasketToken.sol">
// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.28;

import { ERC20Upgradeable } from "@openzeppelin-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol";
import { ERC20PermitUpgradeable } from
    "@openzeppelin-upgradeable/contracts/token/ERC20/extensions/ERC20PermitUpgradeable.sol";
import { ERC4626Upgradeable } from "@openzeppelin-upgradeable/contracts/token/ERC20/extensions/ERC4626Upgradeable.sol";
import { MulticallUpgradeable } from "@openzeppelin-upgradeable/contracts/utils/MulticallUpgradeable.sol";
import { ERC165Upgradeable } from "@openzeppelin-upgradeable/contracts/utils/introspection/ERC165Upgradeable.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { SafeERC20 } from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import { FixedPointMathLib } from "@solady/utils/FixedPointMathLib.sol";
import { EulerRouter } from "euler-price-oracle/src/EulerRouter.sol";
import { ERC20PluginsUpgradeable } from "token-plugins-upgradeable/contracts/ERC20PluginsUpgradeable.sol";

import { AssetRegistry } from "src/AssetRegistry.sol";
import { BasketManager } from "src/BasketManager.sol";
import { FeeCollector } from "src/FeeCollector.sol";
import { Permit2Lib } from "src/deps/permit2/Permit2Lib.sol";
import { IERC7540Deposit, IERC7540Operator, IERC7540Redeem } from "src/interfaces/IERC7540.sol";
import { WeightStrategy } from "src/strategies/WeightStrategy.sol";

/// @title BasketToken
/// @notice Manages user deposits and redemptions, which are processed asynchronously by the Basket Manager.
/// @dev Considerations for Integrators:
///
/// When users call `requestDeposit` or `requestRedeem`, the system ensures that the controller does not have any
/// pending or claimable deposits or redeems from the controller's `lastDepositRequestId`.
///
/// This behavior allows for a potential griefing attack: an attacker can call `requestDeposit` or `requestRedeem` with
/// a minimal dust amount and specify the target controller address. As a result, the target controller would then be
/// unable to make legitimate `requestDeposit` or `requestRedeem` requests until they first claim the pending request.
///
/// RECOMMENDATION FOR INTEGRATORS: When integrating `BasketToken` into other contracts, always check for any pending or
/// claimable tokens before requesting a deposit or redeem. This ensures that any pending deposits or redeems are
/// resolved, preventing such griefing attacks.
// slither-disable-next-line missing-inheritance
contract BasketToken is
    ERC20PluginsUpgradeable,
    ERC4626Upgradeable,
    ERC165Upgradeable,
    IERC7540Operator,
    IERC7540Deposit,
    IERC7540Redeem,
    MulticallUpgradeable,
    ERC20PermitUpgradeable
{
    /// LIBRARIES ///
    using SafeERC20 for IERC20;

    /// CONSTANTS ///
    /// @notice ISO 4217 numeric code for USD, used as a constant address representation
    address private constant _USD_ISO_4217_CODE = address(840);
    uint16 private constant _MANAGEMENT_FEE_DECIMALS = 1e4;
    /// @notice Maximum management fee (30%) in BPS denominated in 1e4.
    uint16 private constant _MAX_MANAGEMENT_FEE = 3000;
    string private constant _NAME_PREFIX = "Cove ";
    string private constant _SYMBOL_PREFIX = "cove";

    /// @notice Struct representing a deposit request.
    struct DepositRequestStruct {
        // Mapping of controller addresses to their deposited asset amounts.
        mapping(address controller => uint256 assets) depositAssets;
        // Total amount of assets deposited in this request.
        uint256 totalDepositAssets;
        // Number of shares fulfilled for this deposit request.
        uint256 fulfilledShares;
        // Flag indicating if the fallback redemption process has been triggered.
        bool fallbackTriggered;
    }

    /// @notice Typed tuple for externally viewing DepositRequestStruct without the mapping.
    struct DepositRequestView {
        // Total amount of assets deposited in this request.
        uint256 totalDepositAssets;
        // Number of shares fulfilled for this deposit request.
        uint256 fulfilledShares;
        // Flag indicating if the fallback redemption process has been triggered.
        bool fallbackTriggered;
    }

    /// @notice Struct representing a redeem request.
    struct RedeemRequestStruct {
        // Mapping of controller addresses to their shares to be redeemed.
        mapping(address controller => uint256 shares) redeemShares;
        // Total number of shares to be redeemed in this request.
        uint256 totalRedeemShares;
        // Amount of assets fulfilled for this redeem request.
        uint256 fulfilledAssets;
        // Flag indicating if the fallback redemption process has been triggered.
        bool fallbackTriggered;
    }

    /// @notice Typed tuple for externally viewing RedeemRequestStruct without the mapping.
    struct RedeemRequestView {
        // Total number of shares to be redeemed in this request.
        uint256 totalRedeemShares;
        // Amount of assets fulfilled for this redeem request.
        uint256 fulfilledAssets;
        // Flag indicating if the fallback redemption process has been triggered.
        bool fallbackTriggered;
    }

    /// STATE VARIABLES ///
    /// @notice Operator approval status per controller.
    mapping(address controller => mapping(address operator => bool)) public isOperator;
    /// @notice Last deposit request ID per controller.
    mapping(address controller => uint256 requestId) public lastDepositRequestId;
    /// @notice Last redemption request ID per controller.
    mapping(address controller => uint256 requestId) public lastRedeemRequestId;
    /// @dev Deposit requests mapped by request ID. Even IDs are for deposits.
    mapping(uint256 requestId => DepositRequestStruct) internal _depositRequests;
    /// @dev Redemption requests mapped by request ID. Odd IDs are for redemptions.
    mapping(uint256 requestId => RedeemRequestStruct) internal _redeemRequests;
    /// @notice Address of the BasketManager contract handling deposits and redemptions.
    address public basketManager;
    /// @notice Upcoming deposit request ID.
    uint256 public nextDepositRequestId;
    /// @notice Upcoming redemption request ID.
    uint256 public nextRedeemRequestId;
    /// @notice Address of the AssetRegistry contract for asset status checks.
    address public assetRegistry;
    /// @notice Bitflag representing selected assets.
    uint256 public bitFlag;
    /// @notice Strategy contract address associated with this basket.
    address public strategy;
    /// @notice Timestamp of the last management fee harvest.
    uint40 public lastManagementFeeHarvestTimestamp;

    /// EVENTS ///
    /// @notice Emitted when the management fee is harvested.
    /// @param fee The amount of the management fee harvested.
    event ManagementFeeHarvested(uint256 fee);
    /// @notice Emitted when a deposit request is fulfilled and assets are transferred to the user.
    /// @param requestId The unique identifier of the deposit request.
    /// @param assets The amount of assets that were deposited.
    /// @param shares The number of shares minted for the deposit.
    event DepositFulfilled(uint256 indexed requestId, uint256 assets, uint256 shares);
    /// @notice Emitted when a redemption request is fulfilled and shares are burned.
    /// @param requestId The unique identifier of the redemption request.
    /// @param shares The number of shares redeemed.
    /// @param assets The amount of assets returned to the user.
    event RedeemFulfilled(uint256 indexed requestId, uint256 shares, uint256 assets);
    /// @notice Emitted when a deposit request is triggered in fallback mode.
    /// @param requestId The unique identifier of the deposit request.
    event DepositFallbackTriggered(uint256 indexed requestId);
    /// @notice Emitted when a redemption request is triggered in fallback mode.
    /// @param requestId The unique identifier of the redemption request.
    event RedeemFallbackTriggered(uint256 indexed requestId);
    /// @notice Emitted when the bitflag is updated to a new value.
    /// @param oldBitFlag The previous bitflag value.
    /// @param newBitFlag The new bitflag value.
    event BitFlagUpdated(uint256 oldBitFlag, uint256 newBitFlag);
    /// @notice Emitted when a deposit request is queued and awaiting fulfillment.
    /// @param depositRequestId The unique identifier of the deposit request.
    /// @param pendingDeposits The total amount of assets pending deposit.
    event DepositRequestQueued(uint256 depositRequestId, uint256 pendingDeposits);
    /// @notice Emitted when a redeem request is queued and awaiting fulfillment.
    /// @param redeemRequestId The unique identifier of the redeem request.
    /// @param pendingShares The total amount of shares pending redemption.
    event RedeemRequestQueued(uint256 redeemRequestId, uint256 pendingShares);

    /// ERRORS ///
    /// @notice Thrown when the asset address is zero.
    error ZeroAddress();
    /// @notice Thrown when the amount is zero.
    error ZeroAmount();
    /// @notice Thrown when there are no pending deposits to fulfill.
    error ZeroPendingDeposits();
    /// @notice Thrown when there are no pending redeems to fulfill.
    error ZeroPendingRedeems();
    /// @notice Thrown when attempting to request a deposit or redeem while one or more of the basket's assets are
    /// paused in the AssetRegistry.
    error AssetPaused();
    /// @notice Thrown when attempting to request a new deposit while the user has an outstanding claimable deposit from
    /// a previous request. The user must first claim the outstanding deposit.
    error MustClaimOutstandingDeposit();
    /// @notice Thrown when attempting to request a new redeem while the user has an outstanding claimable redeem from a
    /// previous request. The user must first claim the outstanding redeem.
    error MustClaimOutstandingRedeem();
    /// @notice Thrown when attempting to claim a partial amount of an outstanding deposit or redeem. The user must
    /// claim the full claimable amount.
    error MustClaimFullAmount();
    /// @notice Thrown when the basket manager attempts to fulfill a deposit request with zero shares.
    error CannotFulfillWithZeroShares();
    /// @notice Thrown when the basket manager attempts to fulfill a redeem request with zero assets.
    error CannotFulfillWithZeroAssets();
    /// @notice Thrown when attempting to claim fallback assets when none are available.
    error ZeroClaimableFallbackAssets();
    /// @notice Thrown when attempting to claim fallback shares when none are available.
    error ZeroClaimableFallbackShares();
    /// @notice Thrown when a non-authorized address attempts to request a deposit or redeem on behalf of another user
    /// who has not approved them as an operator.
    error NotAuthorizedOperator();
    /// @notice Thrown when an address other than the basket manager attempts to call a basket manager only function.
    error NotBasketManager();
    /// @notice Thrown when an address other than the feeCollector attempts to harvest management fees.
    error NotFeeCollector();
    /// @notice Thrown when attempting to set an invalid management fee percentage greater than the maximum allowed.
    error InvalidManagementFee();
    /// @notice Thrown when the basket manager attempts to fulfill a deposit request that has already been fulfilled.
    error DepositRequestAlreadyFulfilled();
    /// @notice Thrown when the basket manager attempts to fulfill a redeem request that has already been fulfilled.
    error RedeemRequestAlreadyFulfilled();
    /// @notice Thrown when attempting to prepare for a new rebalance before the previous epoch's deposit request has
    /// been fulfilled.
    error PreviousDepositRequestNotFulfilled();
    /// @notice Thrown when attempting to prepare for a new rebalance before the previous epoch's redeem request has
    /// been fulfilled or put in fallback state.
    error PreviousRedeemRequestNotFulfilled();

    /// @notice Disables initializer functions.
    constructor() payable {
        _disableInitializers();
    }

    /// @notice Initializes the contract.
    /// @param asset_ Address of the underlying asset.
    /// @param name_ Name of the token, prefixed with "CoveBasket-".
    /// @param symbol_ Symbol of the token, prefixed with "cb".
    /// @param bitFlag_ Bitflag representing selected assets.
    /// @param strategy_ Strategy contract address.
    function initialize(
        IERC20 asset_,
        string memory name_,
        string memory symbol_,
        uint256 bitFlag_,
        address strategy_,
        address assetRegistry_
    )
        public
        initializer
    {
        if (strategy_ == address(0) || assetRegistry_ == address(0)) {
            revert ZeroAddress();
        }
        basketManager = msg.sender;
        bitFlag = bitFlag_;
        strategy = strategy_;
        assetRegistry = assetRegistry_;
        nextDepositRequestId = 2;
        nextRedeemRequestId = 3;
        __ERC4626_init(asset_);
        string memory tokenName = string.concat(_NAME_PREFIX, name_);
        __ERC20_init(tokenName, string.concat(_SYMBOL_PREFIX, symbol_));
        __ERC20Permit_init(tokenName);
        __ERC20Plugins_init(8, 2_000_000);
    }

    /// @notice Returns the value of the basket in assets. This will be an estimate as it does not account for other
    /// factors that may affect the swap rates.
    /// @return The total value of the basket in assets.
    function totalAssets() public view override returns (uint256) {
        address[] memory assets = getAssets();
        uint256 usdAmount = 0;
        uint256 assetsLength = assets.length;

        BasketManager bm = BasketManager(basketManager);
        EulerRouter eulerRouter = EulerRouter(bm.eulerRouter());
        address baseAsset = asset();

        for (uint256 i = 0; i < assetsLength;) {
            if (assets[i] != baseAsset) {
                // slither-disable-start calls-loop
                uint256 assetBalance = bm.basketBalanceOf(address(this), assets[i]);
                if (assetBalance > 0) {
                    // Rounding direction: down
                    usdAmount += eulerRouter.getQuote(assetBalance, assets[i], _USD_ISO_4217_CODE);
                }
                // slither-disable-end calls-loop
            }

            unchecked {
                // Overflow not possible: i is less than assetsLength
                ++i;
            }
        }
        uint256 totalBaseAssetBalance = bm.basketBalanceOf(address(this), baseAsset);
        if (usdAmount > 0) {
            totalBaseAssetBalance += eulerRouter.getQuote(usdAmount, _USD_ISO_4217_CODE, baseAsset);
        }
        return totalBaseAssetBalance;
    }

    /// @notice Returns the target weights for the given epoch.
    /// @return The target weights for the basket.
    function getTargetWeights() public view returns (uint64[] memory) {
        return WeightStrategy(strategy).getTargetWeights(bitFlag);
    }

    /// @notice Returns all assets that are eligible to be included in this basket based on the bitFlag
    /// @dev This returns the complete list of eligible assets from the AssetRegistry, filtered by this basket's
    /// bitFlag.
    ///      The list includes all assets that could potentially be part of the basket, regardless of:
    ///      - Their current balance in the basket
    ///      - Their current target weight
    ///      - Whether they are paused
    /// @return Array of asset token addresses that are eligible for this basket
    function getAssets() public view returns (address[] memory) {
        return AssetRegistry(assetRegistry).getAssets(bitFlag);
    }

    /// ERC7540 LOGIC ///

    /// @notice Transfers assets from owner and submits a request for an asynchronous deposit.
    /// @param assets The amount of assets to deposit.
    /// @param controller The address of the controller of the position being created.
    /// @param owner The address of the owner of the assets being deposited.
    /// @dev Reverts on 0 assets or if the caller is not the owner or operator of the assets being deposited.
    function requestDeposit(uint256 assets, address controller, address owner) public returns (uint256 requestId) {
        // Checks
        if (msg.sender != owner) {
            if (!isOperator[owner][msg.sender]) {
                revert NotAuthorizedOperator();
            }
        }
        if (assets == 0) {
            revert ZeroAmount();
        }
        requestId = nextDepositRequestId;
        uint256 userLastDepositRequestId = lastDepositRequestId[controller];
        // If the user has a pending deposit request in the past, they must wait for it to be fulfilled before making a
        // new one
        if (userLastDepositRequestId != requestId) {
            if (pendingDepositRequest(userLastDepositRequestId, controller) > 0) {
                revert MustClaimOutstandingDeposit();
            }
        }
        // If the user has a claimable deposit request, they must claim it before making a new one
        if (
            claimableDepositRequest(userLastDepositRequestId, controller) > 0 || claimableFallbackAssets(controller) > 0
        ) {
            revert MustClaimOutstandingDeposit();
        }
        if (AssetRegistry(assetRegistry).hasPausedAssets(bitFlag)) {
            revert AssetPaused();
        }
        // Effects
        DepositRequestStruct storage depositRequest = _depositRequests[requestId];
        // update controllers balance of assets pending deposit
        depositRequest.depositAssets[controller] += assets;
        // update total pending deposits for the current requestId
        depositRequest.totalDepositAssets += assets;
        // update controllers latest deposit request id
        lastDepositRequestId[controller] = requestId;
        emit DepositRequest(controller, owner, requestId, msg.sender, assets);
        // Interactions
        // Assets are immediately transferred to here to await the basketManager to pull them
        // slither-disable-next-line arbitrary-send-erc20
        Permit2Lib.transferFrom2(IERC20(asset()), owner, address(this), assets);
    }

    /// @notice Returns the pending deposit request amount for a controller.
    /// @dev If the epoch has been advanced then the request has been fulfilled and is no longer pending.
    /// @param requestId The id of the request.
    /// @param controller The address of the controller of the deposit request.
    /// @return assets The amount of assets pending deposit.
    function pendingDepositRequest(uint256 requestId, address controller) public view returns (uint256 assets) {
        DepositRequestStruct storage depositRequest = _depositRequests[requestId];
        assets = depositRequest.fulfilledShares == 0 && !depositRequest.fallbackTriggered
            ? depositRequest.depositAssets[controller]
            : 0;
    }

    /// @notice Returns the amount of requested assets in Claimable state for the controller with the given requestId.
    /// @param requestId The id of the request.
    /// @param controller The address of the controller.
    function claimableDepositRequest(uint256 requestId, address controller) public view returns (uint256 assets) {
        DepositRequestStruct storage depositRequest = _depositRequests[requestId];
        assets = _claimableDepositRequest(depositRequest.fulfilledShares, depositRequest.depositAssets[controller]);
    }

    function _claimableDepositRequest(
        uint256 fulfilledShares,
        uint256 depositAssets
    )
        internal
        pure
        returns (uint256 assets)
    {
        return fulfilledShares != 0 ? depositAssets : 0;
    }

    /// @notice Requests a redemption of shares from the basket.
    /// @param shares The amount of shares to redeem.
    /// @param controller The address of the controller of the redeemed shares.
    /// @param owner The address of the request owner.
    function requestRedeem(uint256 shares, address controller, address owner) public returns (uint256 requestId) {
        // Checks
        if (shares == 0) {
            revert ZeroAmount();
        }
        requestId = nextRedeemRequestId;
        // If the user has a pending redeem request in the past, they must wait for it to be fulfilled before making a
        // new one
        uint256 userLastRedeemRequestId = lastRedeemRequestId[controller];
        if (userLastRedeemRequestId != requestId) {
            if (pendingRedeemRequest(userLastRedeemRequestId, controller) > 0) {
                revert MustClaimOutstandingRedeem();
            }
        }
        // If the user has a claimable redeem request, they must claim it before making a new one
        if (claimableRedeemRequest(userLastRedeemRequestId, controller) > 0 || claimableFallbackShares(controller) > 0)
        {
            revert MustClaimOutstandingRedeem();
        }
        if (msg.sender != owner) {
            if (!isOperator[owner][msg.sender]) {
                _spendAllowance(owner, msg.sender, shares);
            }
        }
        if (AssetRegistry(assetRegistry).hasPausedAssets(bitFlag)) {
            revert AssetPaused();
        }

        // Effects
        RedeemRequestStruct storage redeemRequest = _redeemRequests[requestId];
        // update total pending redemptions for the current requestId
        redeemRequest.totalRedeemShares += shares;
        // update controllers latest redeem request id
        lastRedeemRequestId[controller] = requestId;
        // update controllers balance of assets pending deposit
        redeemRequest.redeemShares[controller] += shares;
        _transfer(owner, address(this), shares);
        emit RedeemRequest(controller, owner, requestId, msg.sender, shares);
    }

    /// @notice Returns the pending redeem request amount for a user.
    /// @param requestId The id of the request.
    /// @param controller The address of the controller of the redemption request.
    /// @return shares The amount of shares pending redemption.
    function pendingRedeemRequest(uint256 requestId, address controller) public view returns (uint256 shares) {
        RedeemRequestStruct storage redeemRequest = _redeemRequests[requestId];
        shares = redeemRequest.fulfilledAssets == 0 && !redeemRequest.fallbackTriggered
            ? redeemRequest.redeemShares[controller]
            : 0;
    }

    /// @notice Returns the amount of requested shares in Claimable state for the controller with the given requestId.
    /// @param requestId The id of the request.
    /// @param controller The address of the controller of the redemption request.
    /// @return shares The amount of shares claimable.
    // solhint-disable-next-line no-unused-vars
    function claimableRedeemRequest(uint256 requestId, address controller) public view returns (uint256 shares) {
        RedeemRequestStruct storage redeemRequest = _redeemRequests[requestId];
        shares = _claimableRedeemRequest(redeemRequest.fulfilledAssets, redeemRequest.redeemShares[controller]);
    }

    function _claimableRedeemRequest(
        uint256 fulfilledAssets,
        uint256 redeemShares
    )
        internal
        pure
        returns (uint256 shares)
    {
        return fulfilledAssets != 0 ? redeemShares : 0;
    }

    /// @notice Fulfills all pending deposit requests. Only callable by the basket manager. Assets are held by the
    /// basket manager. Locks in the rate at which users can claim their shares for deposited assets.
    /// @param shares The amount of shares the deposit was fulfilled with.
    function fulfillDeposit(uint256 shares) public {
        // Checks
        _onlyBasketManager();
        // currentRequestId was advanced by 2 to prepare for rebalance
        uint256 currentRequestId = nextDepositRequestId - 2;
        DepositRequestStruct storage depositRequest = _depositRequests[currentRequestId];
        uint256 assets = depositRequest.totalDepositAssets;

        if (assets == 0) {
            revert ZeroPendingDeposits();
        }

        if (depositRequest.fulfilledShares > 0 || depositRequest.fallbackTriggered) {
            revert DepositRequestAlreadyFulfilled();
        }

        // Effects
        // If shares is zero, trigger fallback internally instead of reverting
        if (shares == 0) {
            depositRequest.fallbackTriggered = true;
            emit DepositFallbackTriggered(currentRequestId);
            return;
        }

        // Normal path - fulfill with shares
        depositRequest.fulfilledShares = shares;
        emit DepositFulfilled(currentRequestId, assets, shares);
        _mint(address(this), shares);
        // Interactions
        // transfer the assets to the basket manager
        IERC20(asset()).safeTransfer(msg.sender, assets);
    }

    /// @notice Sets the new bitflag for the basket.
    /// @dev This can only be called by the Basket Manager therefore we assume that the new bitflag is valid.
    /// @param bitFlag_ The new bitflag.
    function setBitFlag(uint256 bitFlag_) public {
        _onlyBasketManager();
        uint256 oldBitFlag = bitFlag;
        bitFlag = bitFlag_;
        emit BitFlagUpdated(oldBitFlag, bitFlag_);
    }

    /// @notice Prepares the basket token for rebalancing by processing pending deposits and redemptions.
    /// @dev This function:
    /// - Verifies previous deposit/redeem requests were fulfilled
    /// - Advances deposit/redeem epochs if there are pending requests
    /// - Harvests management fees
    /// - Can only be called by the basket manager
    /// - Called at the start of rebalancing regardless of pending requests
    /// - Does not advance epochs if there are no pending requests
    /// @param feeBps The management fee in basis points to be harvested.
    /// @param feeCollector The address that will receive the harvested management fee.
    /// @return pendingDeposits The total amount of base assets pending deposit.
    /// @return pendingShares The total amount of shares pending redemption.
    // solhint-disable-next-line code-complexity
    function prepareForRebalance(
        uint16 feeBps,
        address feeCollector
    )
        external
        returns (uint256 pendingDeposits, uint256 pendingShares)
    {
        _onlyBasketManager();
        uint256 nextDepositRequestId_ = nextDepositRequestId;
        uint256 nextRedeemRequestId_ = nextRedeemRequestId;

        // Check if previous deposit request has been fulfilled
        DepositRequestStruct storage previousDepositRequest = _depositRequests[nextDepositRequestId_ - 2];
        if (previousDepositRequest.totalDepositAssets > 0) {
            if (previousDepositRequest.fulfilledShares == 0) {
                if (!previousDepositRequest.fallbackTriggered) {
                    revert PreviousDepositRequestNotFulfilled();
                }
            }
        }

        // Check if previous redeem request has been fulfilled or fallbacked
        RedeemRequestStruct storage previousRedeemRequest = _redeemRequests[nextRedeemRequestId_ - 2];
        if (previousRedeemRequest.totalRedeemShares > 0) {
            if (previousRedeemRequest.fulfilledAssets == 0) {
                if (!previousRedeemRequest.fallbackTriggered) {
                    revert PreviousRedeemRequestNotFulfilled();
                }
            }
        }

        // Get current pending deposits
        pendingDeposits = _depositRequests[nextDepositRequestId_].totalDepositAssets;
        if (pendingDeposits > 0) {
            nextDepositRequestId = nextDepositRequestId_ + 2;
            emit DepositRequestQueued(nextDepositRequestId_, pendingDeposits);
        }

        pendingShares = _redeemRequests[nextRedeemRequestId_].totalRedeemShares;
        if (pendingShares > 0) {
            nextRedeemRequestId = nextRedeemRequestId_ + 2;
            emit RedeemRequestQueued(nextRedeemRequestId_, pendingShares);
        }

        _harvestManagementFee(feeBps, feeCollector);
    }

    /// @notice Fulfills all pending redeem requests. Only callable by the basket manager. Burns the shares which are
    /// pending redemption. Locks in the rate at which users can claim their assets for redeemed shares.
    /// @dev prepareForRebalance must be called before this function.
    /// @param assets The amount of assets the redemption was fulfilled with.
    function fulfillRedeem(uint256 assets) public {
        // Checks
        _onlyBasketManager();
        uint256 currentRequestId = nextRedeemRequestId - 2;
        RedeemRequestStruct storage redeemRequest = _redeemRequests[currentRequestId];
        uint256 shares = redeemRequest.totalRedeemShares;

        if (shares == 0) {
            revert ZeroPendingRedeems();
        }

        if (redeemRequest.fulfilledAssets > 0 || redeemRequest.fallbackTriggered) {
            revert RedeemRequestAlreadyFulfilled();
        }

        // Effects
        // If assets is zero, trigger fallback internally and return
        if (assets == 0) {
            redeemRequest.fallbackTriggered = true;
            emit RedeemFallbackTriggered(currentRequestId);
            return;
        }

        // Normal path - redeem request is fulfilled
        redeemRequest.fulfilledAssets = assets;
        emit RedeemFulfilled(currentRequestId, shares, assets);
        _burn(address(this), shares);
        // Interactions
        // slither-disable-next-line arbitrary-send-erc20
        IERC20(asset()).safeTransferFrom(msg.sender, address(this), assets);
    }

    /// @notice Retrieves the total amount of assets currently pending deposit.
    /// @dev Once a rebalance is proposed, any pending deposits are processed and this function will return the pending
    /// deposits of the next epoch.
    /// @return The total pending deposit amount.
    function totalPendingDeposits() public view returns (uint256) {
        return _depositRequests[nextDepositRequestId].totalDepositAssets;
    }

    /// @notice Returns the total number of shares pending redemption.
    /// @dev Once a rebalance is proposed, any pending redemptions are processed and this function will return the
    /// pending redemptions of the next epoch.
    /// @return The total pending redeem amount.
    function totalPendingRedemptions() public view returns (uint256) {
        return _redeemRequests[nextRedeemRequestId].totalRedeemShares;
    }

    /// @notice Cancels a pending deposit request.
    function cancelDepositRequest() public {
        // Checks
        uint256 nextDepositRequestId_ = nextDepositRequestId;
        uint256 pendingDeposit = pendingDepositRequest(nextDepositRequestId_, msg.sender);
        if (pendingDeposit == 0) {
            revert ZeroPendingDeposits();
        }
        // Effects
        DepositRequestStruct storage depositRequest = _depositRequests[nextDepositRequestId_];
        depositRequest.depositAssets[msg.sender] = 0;
        depositRequest.totalDepositAssets -= pendingDeposit;
        // Interactions
        IERC20(asset()).safeTransfer(msg.sender, pendingDeposit);
    }

    /// @notice Cancels a pending redeem request.
    function cancelRedeemRequest() public {
        // Checks
        uint256 nextRedeemRequestId_ = nextRedeemRequestId;
        uint256 pendingRedeem = pendingRedeemRequest(nextRedeemRequestId_, msg.sender);
        if (pendingRedeem == 0) {
            revert ZeroPendingRedeems();
        }
        // Effects
        RedeemRequestStruct storage redeemRequest = _redeemRequests[nextRedeemRequestId_];
        redeemRequest.redeemShares[msg.sender] = 0;
        redeemRequest.totalRedeemShares -= pendingRedeem;
        _transfer(address(this), msg.sender, pendingRedeem);
    }

    /// @notice Sets a status for an operator's ability to act on behalf of a controller.
    /// @param operator The address of the operator.
    /// @param approved The status of the operator.
    /// @return success True if the operator status was set, false otherwise.
    function setOperator(address operator, bool approved) public returns (bool success) {
        isOperator[msg.sender][operator] = approved;
        emit OperatorSet(msg.sender, operator, approved);
        return true;
    }

    /// @dev Reverts if the controller is not the caller or the operator of the caller.
    function _onlySelfOrOperator(address controller) internal view {
        if (msg.sender != controller) {
            if (!isOperator[controller][msg.sender]) {
                revert NotAuthorizedOperator();
            }
        }
    }

    /// @dev Reverts if the caller is not the Basket Manager.
    function _onlyBasketManager() internal view {
        if (basketManager != msg.sender) {
            revert NotBasketManager();
        }
    }

    /// @notice Returns the address of the share token as per ERC-7575.
    /// @return shareTokenAddress The address of the share token.
    /// @dev For non-multi asset vaults this should always return address(this).
    function share() public view returns (address shareTokenAddress) {
        shareTokenAddress = address(this);
    }

    /// FALLBACK REDEEM LOGIC ///

    /// @notice Claims shares given for a previous redemption request in the event a redemption fulfillment for a
    /// given epoch fails.
    /// @param receiver The address to receive the shares.
    /// @param controller The address of the controller of the redemption request.
    /// @return shares The amount of shares claimed.
    function claimFallbackShares(address receiver, address controller) public returns (uint256 shares) {
        // Checks
        _onlySelfOrOperator(controller);
        shares = claimableFallbackShares(controller);
        if (shares == 0) {
            revert ZeroClaimableFallbackShares();
        }
        // Effects
        _redeemRequests[lastRedeemRequestId[controller]].redeemShares[controller] = 0;
        _transfer(address(this), receiver, shares);
    }

    /// @notice Claims assets given for a previous deposit request in the event a deposit fulfillment for a
    /// given epoch fails.
    /// @param receiver The address to receive the assets.
    /// @param controller The address of the controller of the deposit request.
    /// @return assets The amount of assets claimed.
    function claimFallbackAssets(address receiver, address controller) public returns (uint256 assets) {
        // Checks
        _onlySelfOrOperator(controller);
        assets = claimableFallbackAssets(controller);
        if (assets == 0) {
            revert ZeroClaimableFallbackAssets();
        }
        // Effects
        _depositRequests[lastDepositRequestId[controller]].depositAssets[controller] = 0;
        IERC20(asset()).safeTransfer(receiver, assets);
    }

    /// @notice Returns the amount of shares claimable for a given user in the event of a failed redemption
    /// fulfillment.
    /// @param controller The address of the controller.
    /// @return shares The amount of shares claimable by the controller.
    function claimableFallbackShares(address controller) public view returns (uint256 shares) {
        RedeemRequestStruct storage redeemRequest = _redeemRequests[lastRedeemRequestId[controller]];
        if (redeemRequest.fallbackTriggered) {
            return redeemRequest.redeemShares[controller];
        }
        return 0;
    }

    /// @notice Returns the amount of assets claimable for a given user in the event of a failed deposit fulfillment.
    /// @param controller The address of the controller.
    /// @return assets The amount of assets claimable by the controller.
    function claimableFallbackAssets(address controller) public view returns (uint256 assets) {
        DepositRequestStruct storage depositRequest = _depositRequests[lastDepositRequestId[controller]];
        if (depositRequest.fallbackTriggered) {
            return depositRequest.depositAssets[controller];
        }
        return 0;
    }

    /// @notice Synchronously redeems basket shares for underlying assets at current proportions.
    /// @dev Bypasses rebalance process, transferring assets immediately. Requires basket to be out of rebalance cycle.
    /// Can be used to exit baskets with paused assets. See {BasketManager-proRataRedeem} and
    /// {AssetRegistry-setAssetStatus}.
    /// @param shares Number of shares to redeem.
    /// @param to Address to receive the assets.
    /// @param from Address to redeem shares from.
    function proRataRedeem(uint256 shares, address to, address from) public {
        // Checks and effects
        if (msg.sender != from) {
            if (!isOperator[from][msg.sender]) {
                _spendAllowance(from, msg.sender, shares);
            }
        }

        // Interactions
        BasketManager bm = BasketManager(basketManager);
        _harvestManagementFee(bm.managementFee(address(this)), bm.feeCollector());
        bm.proRataRedeem(totalSupply(), shares, to);

        // We intentionally defer the `_burn()` operation until after the external call to
        // `BasketManager.proRataRedeem()` to prevent potential price manipulation via read-only reentrancy attacks. By
        // performing the external interaction before updating balances, we ensure that total supply and user balances
        // cannot be manipulated if a malicious contract attempts to reenter during the ERC20 transfer (e.g., through
        // ERC777 tokens or plugins with callbacks).
        _burn(from, shares);
    }

    /// @notice Harvests management fees owed to the fee collector.
    function harvestManagementFee() external {
        BasketManager bm = BasketManager(basketManager);
        address feeCollector = bm.feeCollector();
        if (msg.sender != feeCollector) {
            if (msg.sender != address(bm)) {
                revert NotFeeCollector();
            }
        }
        uint16 feeBps = bm.managementFee(address(this));
        _harvestManagementFee(feeBps, feeCollector);
    }

    /// @notice Internal function to harvest management fees. Updates the timestamp of the last management fee harvest
    /// if a non zero fee is collected. Mints the fee to the fee collector and notifies the basket manager.
    /// @param feeBps The management fee in basis points to be harvested.
    /// @param feeCollector The address that will receive the harvested management fee.
    // slither-disable-next-line timestamp
    function _harvestManagementFee(uint16 feeBps, address feeCollector) internal {
        // Checks
        if (feeBps > _MAX_MANAGEMENT_FEE) {
            revert InvalidManagementFee();
        }
        uint256 timeSinceLastHarvest = block.timestamp - lastManagementFeeHarvestTimestamp;

        // Effects
        if (feeBps != 0) {
            if (timeSinceLastHarvest != 0) {
                // remove shares held by the treasury
                uint256 currentTotalSupply = totalSupply() - balanceOf(feeCollector);
                if (currentTotalSupply > 0) {
                    uint256 fee = FixedPointMathLib.fullMulDiv(
                        currentTotalSupply,
                        feeBps * timeSinceLastHarvest,
                        ((_MANAGEMENT_FEE_DECIMALS - feeBps) * uint256(365 days))
                    );
                    if (fee != 0) {
                        lastManagementFeeHarvestTimestamp = uint40(block.timestamp);
                        emit ManagementFeeHarvested(fee);
                        _mint(feeCollector, fee);
                        // Interactions
                        FeeCollector(feeCollector).notifyHarvestFee(fee);
                    }
                } else {
                    lastManagementFeeHarvestTimestamp = uint40(block.timestamp);
                }
            }
        } else {
            lastManagementFeeHarvestTimestamp = uint40(block.timestamp);
        }
    }

    /// ERC4626 OVERRIDDEN LOGIC ///

    /// @notice Transfers a user's shares owed for a previously fulfillled deposit request.
    /// @param assets The amount of assets previously requested for deposit.
    /// @param receiver The address to receive the shares.
    /// @param controller The address of the controller of the deposit request.
    /// @return shares The amount of shares minted.
    function deposit(uint256 assets, address receiver, address controller) public returns (uint256 shares) {
        // Checks
        if (assets == 0) {
            revert ZeroAmount();
        }
        _onlySelfOrOperator(controller);
        DepositRequestStruct storage depositRequest = _depositRequests[lastDepositRequestId[controller]];
        uint256 fulfilledShares = depositRequest.fulfilledShares;
        uint256 depositAssets = depositRequest.depositAssets[controller];
        if (assets != _claimableDepositRequest(fulfilledShares, depositAssets)) {
            revert MustClaimFullAmount();
        }
        shares = _maxMint(fulfilledShares, depositAssets, depositRequest.totalDepositAssets);
        // Effects
        _claimDeposit(depositRequest, assets, shares, receiver, controller);
    }

    /// @notice Transfers a user's shares owed for a previously fulfillled deposit request.
    /// @param assets The amount of assets to be claimed.
    /// @param receiver The address to receive the assets.
    /// @return shares The amount of shares previously requested for redemption.
    function deposit(uint256 assets, address receiver) public override returns (uint256 shares) {
        return deposit(assets, receiver, msg.sender);
    }

    /// @notice Transfers a user's shares owed for a previously fulfillled deposit request.
    /// @dev Deposit should be used in all instances instead.
    /// @param shares The amount of shares to receive.
    /// @param receiver The address to receive the shares.
    /// @param controller The address of the controller of the deposit request.
    /// @return assets The amount of assets previously requested for deposit.
    function mint(uint256 shares, address receiver, address controller) public returns (uint256 assets) {
        // Checks
        _onlySelfOrOperator(controller);
        DepositRequestStruct storage depositRequest = _depositRequests[lastDepositRequestId[controller]];
        uint256 fulfilledShares = depositRequest.fulfilledShares;
        uint256 depositAssets = depositRequest.depositAssets[controller];
        if (shares != _maxMint(fulfilledShares, depositAssets, depositRequest.totalDepositAssets)) {
            revert MustClaimFullAmount();
        }
        // Effects
        assets = _claimableDepositRequest(fulfilledShares, depositAssets);
        _claimDeposit(depositRequest, assets, shares, receiver, controller);
    }

    /// @notice Transfers a user's shares owed for a previously fulfillled deposit request.
    /// @param shares The amount of shares to receive.
    /// @param receiver The address to receive the shares.
    /// @return assets The amount of assets previously requested for deposit.
    function mint(uint256 shares, address receiver) public override returns (uint256 assets) {
        return mint(shares, receiver, msg.sender);
    }

    /// @notice Internal function to claim deposit for a given amount of assets and shares.
    /// @param assets The amount of assets to claim.
    /// @param shares The amount of shares to claim.
    /// @param receiver The address of the receiver of the claimed assets.
    /// @param controller The address of the controller of the deposit request.
    function _claimDeposit(
        DepositRequestStruct storage depositRequest,
        uint256 assets,
        uint256 shares,
        address receiver,
        address controller
    )
        internal
    {
        // Effects
        depositRequest.depositAssets[controller] = 0;
        emit Deposit(controller, receiver, assets, shares);
        // Interactions
        _transfer(address(this), receiver, shares);
    }

    /// @notice Transfers a user's assets owed for a previously fulfillled redemption request.
    /// @dev Redeem should be used in all instances instead.
    /// @param assets The amount of assets to be claimed.
    /// @param receiver The address to receive the assets.
    /// @param controller The address of the controller of the redeem request.
    /// @return shares The amount of shares previously requested for redemption.
    function withdraw(uint256 assets, address receiver, address controller) public override returns (uint256 shares) {
        // Checks
        _onlySelfOrOperator(controller);
        RedeemRequestStruct storage redeemRequest = _redeemRequests[lastRedeemRequestId[controller]];
        uint256 fulfilledAssets = redeemRequest.fulfilledAssets;
        uint256 redeemShares = redeemRequest.redeemShares[controller];
        if (assets != _maxWithdraw(fulfilledAssets, redeemShares, redeemRequest.totalRedeemShares)) {
            revert MustClaimFullAmount();
        }
        shares = _claimableRedeemRequest(fulfilledAssets, redeemShares);
        // Effects
        _claimRedemption(redeemRequest, assets, shares, receiver, controller);
    }

    /// @notice Transfers the receiver assets owed for a fulfilled redeem request.
    /// @param shares The amount of shares to be claimed.
    /// @param receiver The address to receive the assets.
    /// @param controller The address of the controller of the redeem request.
    /// @return assets The amount of assets previously requested for redemption.
    function redeem(uint256 shares, address receiver, address controller) public override returns (uint256 assets) {
        // Checks
        if (shares == 0) {
            revert ZeroAmount();
        }
        _onlySelfOrOperator(controller);
        RedeemRequestStruct storage redeemRequest = _redeemRequests[lastRedeemRequestId[controller]];
        uint256 fulfilledAssets = redeemRequest.fulfilledAssets;
        uint256 redeemShares = redeemRequest.redeemShares[controller];
        if (shares != _claimableRedeemRequest(fulfilledAssets, redeemShares)) {
            revert MustClaimFullAmount();
        }
        assets = _maxWithdraw(fulfilledAssets, redeemShares, redeemRequest.totalRedeemShares);
        // Effects & Interactions
        _claimRedemption(redeemRequest, assets, shares, receiver, controller);
    }

    /// @notice Internal function to claim redemption for a given amount of assets and shares.
    /// @param assets The amount of assets to claim.
    /// @param shares The amount of shares to claim.
    /// @param receiver The address of the receiver of the claimed assets.
    /// @param controller The address of the controller of the redemption request.
    function _claimRedemption(
        RedeemRequestStruct storage redeemRequest,
        uint256 assets,
        uint256 shares,
        address receiver,
        address controller
    )
        internal
    {
        // Effects
        redeemRequest.redeemShares[controller] = 0;
        emit Withdraw(msg.sender, receiver, controller, assets, shares);
        // Interactions
        IERC20(asset()).safeTransfer(receiver, assets);
    }

    /// @notice Returns an controller's amount of assets fulfilled for redemption.
    /// @dev For requests yet to be fulfilled, this will return 0.
    /// @param controller The address of the controller.
    /// @return The amount of assets that can be withdrawn.
    function maxWithdraw(address controller) public view override returns (uint256) {
        RedeemRequestStruct storage redeemRequest = _redeemRequests[lastRedeemRequestId[controller]];
        return _maxWithdraw(
            redeemRequest.fulfilledAssets, redeemRequest.redeemShares[controller], redeemRequest.totalRedeemShares
        );
    }

    function _maxWithdraw(
        uint256 fulfilledAssets,
        uint256 redeemShares,
        uint256 totalRedeemShares
    )
        internal
        pure
        returns (uint256)
    {
        return
            totalRedeemShares == 0 ? 0 : FixedPointMathLib.fullMulDiv(fulfilledAssets, redeemShares, totalRedeemShares);
    }

    /// @notice Returns an controller's amount of shares fulfilled for redemption.
    /// @dev For requests yet to be fulfilled, this will return 0.
    /// @param controller The address of the controller.
    /// @return The amount of shares that can be redeemed.
    function maxRedeem(address controller) public view override returns (uint256) {
        return claimableRedeemRequest(lastRedeemRequestId[controller], controller);
    }

    /// @notice Returns an controller's amount of assets fulfilled for deposit.
    /// @dev For requests yet to be fulfilled, this will return 0.
    /// @param controller The address of the controller.
    /// @return The amount of assets that can be deposited.
    function maxDeposit(address controller) public view override returns (uint256) {
        return claimableDepositRequest(lastDepositRequestId[controller], controller);
    }

    /// @notice Returns an controller's amount of shares fulfilled for deposit.
    /// @dev For requests yet to be fulfilled, this will return 0.
    /// @param controller The address of the controller.
    /// @return The amount of shares that can be minted.
    function maxMint(address controller) public view override returns (uint256) {
        DepositRequestStruct storage depositRequest = _depositRequests[lastDepositRequestId[controller]];
        return _maxMint(
            depositRequest.fulfilledShares, depositRequest.depositAssets[controller], depositRequest.totalDepositAssets
        );
    }

    function _maxMint(
        uint256 fulfilledShares,
        uint256 depositAssets,
        uint256 totalDepositAssets
    )
        internal
        pure
        returns (uint256)
    {
        return totalDepositAssets == 0
            ? 0
            : FixedPointMathLib.fullMulDiv(fulfilledShares, depositAssets, totalDepositAssets);
    }

    // solhint-disable custom-errors,gas-custom-errors,reason-string
    // Preview functions always revert for async flows
    function previewDeposit(uint256) public pure override returns (uint256) {
        revert();
    }

    // Preview functions always revert for async flows
    function previewMint(uint256) public pure override returns (uint256) {
        revert();
    }

    // Preview functions always revert for async flows
    function previewWithdraw(uint256) public pure override returns (uint256) {
        revert();
    }

    // Preview functions always revert for async flows
    function previewRedeem(uint256) public pure override returns (uint256) {
        revert();
    }
    // solhint-enable custom-errors,gas-custom-errors,reason-string

    /// @notice Returns true if the redemption request's fallback has been triggered.
    /// @param requestId The id of the request.
    /// @return True if the fallback has been triggered, false otherwise.
    function fallbackRedeemTriggered(uint256 requestId) public view returns (bool) {
        return _redeemRequests[requestId].fallbackTriggered;
    }

    /// @notice Returns true if the deposit request's fallback has been triggered.
    /// @param requestId The id of the request.
    /// @return True if the fallback has been triggered, false otherwise.
    function fallbackDepositTriggered(uint256 requestId) public view returns (bool) {
        return _depositRequests[requestId].fallbackTriggered;
    }

    /// @notice Returns the deposit request data for a given requestId without the internal mapping.
    /// @param requestId The id of the deposit request.
    /// @return A DepositRequestView struct containing the deposit request data.
    function getDepositRequest(uint256 requestId) external view returns (DepositRequestView memory) {
        DepositRequestStruct storage depositRequest = _depositRequests[requestId];
        return DepositRequestView({
            totalDepositAssets: depositRequest.totalDepositAssets,
            fulfilledShares: depositRequest.fulfilledShares,
            fallbackTriggered: depositRequest.fallbackTriggered
        });
    }

    /// @notice Returns the redeem request data for a given requestId without the internal mapping.
    /// @param requestId The id of the redeem request.
    /// @return A RedeemRequestView struct containing the redeem request data.
    function getRedeemRequest(uint256 requestId) external view returns (RedeemRequestView memory) {
        RedeemRequestStruct storage redeemRequest = _redeemRequests[requestId];
        return RedeemRequestView({
            totalRedeemShares: redeemRequest.totalRedeemShares,
            fulfilledAssets: redeemRequest.fulfilledAssets,
            fallbackTriggered: redeemRequest.fallbackTriggered
        });
    }

    //// ERC165 OVERRIDDEN LOGIC ///
    /// @notice Checks if the contract supports the given interface.
    /// @param interfaceID The interface ID.
    /// @return True if the contract supports the interface, false otherwise.
    function supportsInterface(bytes4 interfaceID) public view virtual override returns (bool) {
        return interfaceID == 0x2f0a18c5 || interfaceID == 0xf815c03d
            || interfaceID == type(IERC7540Operator).interfaceId || interfaceID == type(IERC7540Deposit).interfaceId
            || interfaceID == type(IERC7540Redeem).interfaceId || super.supportsInterface(interfaceID);
    }

    /// @dev Override to call the ERC20PluginsUpgradeable's _update function.
    function _update(
        address from,
        address to,
        uint256 amount
    )
        internal
        override(ERC20PluginsUpgradeable, ERC20Upgradeable)
    {
        ERC20PluginsUpgradeable._update(from, to, amount);
    }

    /// @dev Override to call the ERC20PluginsUpgradeable's balanceOf function.
    /// See {IERC20-balanceOf}.
    function balanceOf(address account)
        public
        view
        override(ERC20PluginsUpgradeable, ERC20Upgradeable, IERC20)
        returns (uint256)
    {
        return ERC20PluginsUpgradeable.balanceOf(account);
    }

    /// @dev Override to return 18 decimals.
    /// See {IERC20Metadata-decimals}.
    function decimals() public pure override(ERC20Upgradeable, ERC4626Upgradeable) returns (uint8) {
        return 18;
    }

    /// @notice External wrapper around Permit2Lib's permit2 function to handle ERC20 permit signatures.
    /// @dev Supports both Permit2 and ERC20Permit (ERC-2612) signatures. Will try ERC-2612 first,
    /// then fall back to Permit2 if the token doesn't support ERC-2612 or if the permit call fails.
    /// @param token The token to permit
    /// @param owner The owner of the tokens
    /// @param spender The spender to approve
    /// @param value The amount to approve
    /// @param deadline The deadline for the permit
    /// @param v The v component of the signature
    /// @param r The r component of the signature
    /// @param s The s component of the signature
    function permit2(
        IERC20 token,
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    )
        external
    {
        Permit2Lib.permit2(token, owner, spender, value, deadline, v, r, s);
    }
}
</file>

<file path="src/libraries/BasketManagerUtils.sol">
// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.28;

import { Clones } from "@openzeppelin/contracts/proxy/Clones.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { SafeERC20 } from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import { FixedPointMathLib } from "@solady/utils/FixedPointMathLib.sol";
import { EulerRouter } from "euler-price-oracle/src/EulerRouter.sol";

import { AssetRegistry } from "src/AssetRegistry.sol";
import { BasketToken } from "src/BasketToken.sol";
import { MathUtils } from "src/libraries/MathUtils.sol";
import { TokenSwapAdapter } from "src/swap_adapters/TokenSwapAdapter.sol";
import { BasketManagerStorage, RebalanceStatus, Status } from "src/types/BasketManagerStorage.sol";
import { BasketTradeOwnership, ExternalTrade, InternalTrade } from "src/types/Trades.sol";

/// @title BasketManagerUtils
/// @notice Library containing utility functions for managing storage related to baskets, including creating new
/// baskets, proposing and executing rebalances, and settling internal and external token trades.
library BasketManagerUtils {
    using SafeERC20 for IERC20;

    /// STRUCTS ///
    /// @notice Struct containing data for an internal trade.
    struct InternalTradeInfo {
        // Index of the basket that is selling.
        uint256 fromBasketIndex;
        // Index of the basket that is buying.
        uint256 toBasketIndex;
        // Index of the token to sell.
        uint256 sellTokenAssetIndex;
        // Index of the token to buy.
        uint256 buyTokenAssetIndex;
        // Index of the buy token in the buying basket.
        uint256 toBasketBuyTokenIndex;
        // Index of the sell token in the buying basket.
        uint256 toBasketSellTokenIndex;
        // Amount of the buy token that is traded.
        uint256 netBuyAmount;
        // Amount of the sell token that is traded.
        uint256 netSellAmount;
        // Fee charged on the buy token on the trade.
        uint256 feeOnBuy;
        // Fee charged on the sell token on the trade.
        uint256 feeOnSell;
        // USD value of the sell token amount
        uint256 sellValue;
        // USD value of the fees charged on the trade
        uint256 feeValue;
    }

    /// @dev Outsource vars to resolve stack too deep during coverage runs
    struct BasketContext {
        uint256[][] basketBalances;
        uint256[] totalValues;
    }

    /// CONSTANTS ///
    /// @notice ISO 4217 numeric code for USD, used as a constant address representation
    address private constant _USD_ISO_4217_CODE = address(840);
    /// @notice Maximum number of basket tokens allowed to be created.
    uint256 private constant _MAX_NUM_OF_BASKET_TOKENS = 256;
    /// @notice Precision used for weight calculations and slippage calculations.
    uint256 private constant _WEIGHT_PRECISION = 1e18;
    /// @notice Minimum time between rebalances in seconds.
    uint40 private constant _REBALANCE_COOLDOWN_SEC = 1 hours;

    /// EVENTS ///
    /// @notice Emitted when an internal trade is settled.
    /// @param internalTrade Internal trade that was settled.
    /// @param buyAmount Amount of the the from token that is traded.
    event InternalTradeSettled(InternalTrade internalTrade, uint256 buyAmount);
    /// @notice Emitted when swap fees are charged on an internal trade.
    /// @param asset Asset that the swap fee was charged in.
    /// @param amount Amount of the asset that was charged.
    event SwapFeeCharged(address indexed asset, uint256 amount);
    /// @notice Emitted when a rebalance is proposed for a set of baskets
    /// @param epoch Unique identifier for the rebalance, incremented each time a rebalance is proposed
    /// @param baskets Array of basket addresses to rebalance
    /// @param proposedTargetWeights Array of target weights for each basket
    /// @param basketAssets Array of assets in each basket
    /// @param basketHash Hash of the basket addresses and target weights for the rebalance
    event RebalanceProposed(
        uint40 indexed epoch,
        address[] baskets,
        uint64[][] proposedTargetWeights,
        address[][] basketAssets,
        bytes32 basketHash
    );
    /// @notice Emitted when a rebalance is completed.
    /// @param epoch Unique identifier for the rebalance, incremented each time a rebalance is completed
    event RebalanceCompleted(uint40 indexed epoch);
    /// @notice Emitted when a rebalance is retried.
    /// @param epoch Unique identifier for the rebalance, incremented each time a rebalance is completed
    /// @param retryCount Number of retries for the current rebalance epoch. On the first retry, this will be 1.
    event RebalanceRetried(uint40 indexed epoch, uint256 retryCount);

    /// ERRORS ///
    /// @notice Reverts when the address is zero.
    error ZeroAddress();
    /// @notice Reverts when the amount is zero.
    error ZeroAmount();
    /// @notice Reverts when the total supply of a basket token is zero.
    error ZeroTotalSupply();
    /// @notice Reverts when the amount of burned shares is zero.
    error ZeroBurnedShares();
    /// @notice Reverts when trying to burn more shares than the total supply.
    error CannotBurnMoreSharesThanTotalSupply();
    /// @notice Reverts when the requested basket token is not found.
    error BasketTokenNotFound();
    /// @notice Reverts when the requested asset is not found in the basket.
    error AssetNotFoundInBasket();
    /// @notice Reverts when trying to create a basket token that already exists.
    error BasketTokenAlreadyExists();
    /// @notice Reverts when the maximum number of basket tokens has been reached.
    error BasketTokenMaxExceeded();
    /// @notice Reverts when the requested element index is not found.
    error ElementIndexNotFound();
    /// @notice Reverts when the strategy registry does not support the given strategy.
    error StrategyRegistryDoesNotSupportStrategy();
    /// @notice Reverts when the baskets or target weights do not match the proposed rebalance.
    error BasketsMismatch();
    /// @notice Reverts when the base asset does not match the given asset.
    error BaseAssetMismatch();
    /// @notice Reverts when the asset is not found in the asset registry.
    error AssetListEmpty();
    /// @notice Reverts when a rebalance is in progress and the caller must wait for it to complete.
    error MustWaitForRebalanceToComplete();
    /// @notice Reverts when there is no rebalance in progress.
    error NoRebalanceInProgress();
    /// @notice Reverts when it is too early to complete the rebalance.
    error TooEarlyToCompleteRebalance();
    /// @notice Reverts when it is too early to propose a rebalance.
    error TooEarlyToProposeRebalance();
    /// @notice Reverts when a rebalance is not required.
    error RebalanceNotRequired();
    /// @notice Reverts when the external trade slippage exceeds the allowed limit.
    error ExternalTradeSlippage();
    /// @notice Reverts when the target weights are not met.
    error TargetWeightsNotMet();
    /// @notice Reverts when the minimum or maximum amount is not reached for an internal trade.
    error InternalTradeMinMaxAmountNotReached();
    /// @notice Reverts when the trade token amount is incorrect.
    error IncorrectTradeTokenAmount();
    /// @notice Reverts when given external trades do not match.
    error ExternalTradeMismatch();
    /// @notice Reverts when the delegatecall to the tokenswap adapter fails.
    error CompleteTokenSwapFailed();
    /// @notice Reverts when an asset included in a bit flag is not enabled in the asset registry.
    error AssetNotEnabled();
    /// @notice Reverts when no internal or external trades are provided for a rebalance.
    error CannotProposeEmptyTrades();
    /// @notice Reverts when the sum of tradeOwnerships do not match the _WEIGHT_PRECISION
    error OwnershipSumMismatch();
    /// @dev Reverts when the sell amount of an internal trade is zero.
    error InternalTradeSellAmountZero();
    /// @dev Reverts when the sell amount of an external trade is zero.
    error ExternalTradeSellAmountZero();

    /// @notice Creates a new basket token with the given parameters.
    /// @param self BasketManagerStorage struct containing strategy data.
    /// @param basketName Name of the basket.
    /// @param symbol Symbol of the basket.
    /// @param bitFlag Asset selection bitFlag for the basket.
    /// @param strategy Address of the strategy contract for the basket.
    /// @return basket Address of the newly created basket token.
    function createNewBasket(
        BasketManagerStorage storage self,
        string calldata basketName,
        string calldata symbol,
        address baseAsset,
        uint256 bitFlag,
        address strategy
    )
        external
        returns (address basket)
    {
        // Checks
        if (baseAsset == address(0)) {
            revert ZeroAddress();
        }
        uint256 basketTokensLength = self.basketTokens.length;
        if (basketTokensLength >= _MAX_NUM_OF_BASKET_TOKENS) {
            revert BasketTokenMaxExceeded();
        }
        bytes32 basketId = keccak256(abi.encodePacked(bitFlag, strategy));
        if (self.basketIdToAddress[basketId] != address(0)) {
            revert BasketTokenAlreadyExists();
        }
        // Checks with external view calls
        if (!self.strategyRegistry.supportsBitFlag(bitFlag, strategy)) {
            revert StrategyRegistryDoesNotSupportStrategy();
        }
        AssetRegistry assetRegistry = AssetRegistry(self.assetRegistry);
        if (assetRegistry.hasPausedAssets(bitFlag)) {
            revert AssetNotEnabled();
        }
        address[] memory assets = assetRegistry.getAssets(bitFlag);
        if (assets.length == 0) {
            revert AssetListEmpty();
        }
        basket = Clones.clone(self.basketTokenImplementation);
        _setBaseAssetIndex(self, basket, assets, baseAsset);
        self.basketTokens.push(basket);
        self.basketAssets[basket] = assets;
        self.basketIdToAddress[basketId] = basket;
        // The set default management fee will given to the zero address
        self.managementFees[basket] = self.managementFees[address(0)];
        uint256 assetsLength = assets.length;
        for (uint256 j = 0; j < assetsLength;) {
            // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop
            self.basketAssetToIndexPlusOne[basket][assets[j]] = j + 1;
            unchecked {
                // Overflow not possible: j is bounded by assets.length
                ++j;
            }
        }
        unchecked {
            // Overflow not possible: basketTokensLength is less than the constant _MAX_NUM_OF_BASKET_TOKENS
            self.basketTokenToIndexPlusOne[basket] = basketTokensLength + 1;
        }
        // Interactions
        BasketToken(basket).initialize(IERC20(baseAsset), basketName, symbol, bitFlag, strategy, address(assetRegistry));
    }

    /// @notice Proposes a rebalance for the given baskets. The rebalance is proposed if the difference between the
    /// target balance and the current balance of any asset in the basket is more than 500 USD.
    /// @param baskets Array of basket addresses to rebalance.
    // solhint-disable code-complexity
    // slither-disable-next-line cyclomatic-complexity
    function proposeRebalance(BasketManagerStorage storage self, address[] calldata baskets) external {
        // Checks
        // Revert if a rebalance is already in progress
        if (self.rebalanceStatus.status != Status.NOT_STARTED) {
            revert MustWaitForRebalanceToComplete();
        }
        // slither-disable-next-line timestamp
        if (block.timestamp - self.rebalanceStatus.timestamp < _REBALANCE_COOLDOWN_SEC) {
            revert TooEarlyToProposeRebalance();
        }

        // Effects
        self.rebalanceStatus.basketMask = _createRebalanceBitMask(self, baskets);
        self.rebalanceStatus.proposalTimestamp = uint40(block.timestamp);
        self.rebalanceStatus.timestamp = uint40(block.timestamp);
        self.rebalanceStatus.status = Status.REBALANCE_PROPOSED;

        address assetRegistry = self.assetRegistry;
        address feeCollector = self.feeCollector;
        EulerRouter eulerRouter = self.eulerRouter;
        uint64[][] memory basketTargetWeights = new uint64[][](baskets.length);
        address[][] memory basketAssets = new address[][](baskets.length);

        // Interactions
        for (uint256 i = 0; i < baskets.length;) {
            // slither-disable-start calls-loop
            address basket = baskets[i];
            // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop
            address[] memory assets = basketAssets[i] = self.basketAssets[basket];
            basketTargetWeights[i] = BasketToken(basket).getTargetWeights();
            // nosemgrep: solidity.performance.array-length-outside-loop.array-length-outside-loop
            if (assets.length == 0) {
                revert BasketTokenNotFound();
            }
            if (AssetRegistry(assetRegistry).hasPausedAssets(BasketToken(basket).bitFlag())) {
                revert AssetNotEnabled();
            }
            // Calculate current basket value
            (uint256[] memory balances, uint256 basketValue) = _calculateBasketValue(self, eulerRouter, basket, assets);
            // Notify Basket Token of rebalance:
            (uint256 pendingDeposits, uint256 pendingRedeems) =
                BasketToken(basket).prepareForRebalance(self.managementFees[basket], feeCollector);
            // Cache total supply for later use
            uint256 totalSupply = BasketToken(basket).totalSupply();
            // Process pending deposits
            if (pendingDeposits > 0) {
                // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop
                uint256 baseAssetIndex = self.basketTokenToBaseAssetIndexPlusOne[basket] - 1;
                // Process pending deposits and fulfill them
                (uint256 newShares, uint256 pendingDepositValue) = _processPendingDeposits(
                    self,
                    eulerRouter,
                    basket,
                    totalSupply,
                    basketValue,
                    balances[baseAssetIndex],
                    pendingDeposits,
                    assets[baseAssetIndex]
                );
                // If no new shares are minted, no deposit will be added to the basket
                if (newShares > 0) {
                    balances[baseAssetIndex] += pendingDeposits;
                    totalSupply += newShares;
                    basketValue += pendingDepositValue;
                }
            }
            // No need to rebalance if the total supply is 0 even after processing pending deposits
            if (totalSupply == 0) {
                revert ZeroTotalSupply();
            }
            uint256 requiredWithdrawValue = 0;
            // Pre-process pending redemptions
            if (pendingRedeems > 0) {
                if (totalSupply > 0) {
                    // totalSupply cannot be 0 when pendingRedeems is greater than 0, as redemptions
                    // can only occur if there are issued shares (i.e., totalSupply > 0).
                    // Division-by-zero is not possible: totalSupply is greater than 0
                    requiredWithdrawValue = FixedPointMathLib.fullMulDiv(basketValue, pendingRedeems, totalSupply);
                    if (requiredWithdrawValue > basketValue) {
                        // This should never happen, but if it does, withdraw the entire basket value
                        requiredWithdrawValue = basketValue;
                    }
                    unchecked {
                        // Overflow not possible: requiredWithdrawValue is less than or equal to basketValue
                        basketValue -= requiredWithdrawValue;
                    }
                }
                // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop
                self.pendingRedeems[basket] = pendingRedeems;
            }
            // slither-disable-end calls-loop
            unchecked {
                // Overflow not possible: i is less than baskets.length
                ++i;
            }
        }

        // Effects after Interactions. Target weights require external view calls to respective strategies.
        bytes32 basketHash = keccak256(abi.encode(baskets, basketTargetWeights, basketAssets));
        self.rebalanceStatus.basketHash = basketHash;

        // slither-disable-next-line reentrancy-events
        emit RebalanceProposed(self.rebalanceStatus.epoch, baskets, basketTargetWeights, basketAssets, basketHash);
    }
    // solhint-enable code-complexity

    // @notice Proposes a set of internal trades and external trades to rebalance the given baskets.
    /// If the proposed token swap results are not close to the target balances, this function will revert.
    /// @dev This function can only be called after proposeRebalance.
    /// @param self BasketManagerStorage struct containing strategy data.
    /// @param internalTrades Array of internal trades to execute.
    /// @param externalTrades Array of external trades to execute.
    /// @param baskets Array of basket addresses currently being rebalanced.
    /// @param basketTargetWeights Array of target weights for each basket.
    /// @param basketAssets Array of assets in each basket.
    // slither-disable-next-line cyclomatic-complexity
    function proposeTokenSwap(
        BasketManagerStorage storage self,
        InternalTrade[] calldata internalTrades,
        ExternalTrade[] calldata externalTrades,
        address[] calldata baskets,
        uint64[][] calldata basketTargetWeights,
        address[][] calldata basketAssets
    )
        external
    {
        // Checks
        RebalanceStatus memory status = self.rebalanceStatus;
        if (status.status != Status.REBALANCE_PROPOSED) {
            revert MustWaitForRebalanceToComplete();
        }
        _validateBasketHash(self, baskets, basketTargetWeights, basketAssets);
        if (internalTrades.length == 0) {
            if (externalTrades.length == 0) {
                revert CannotProposeEmptyTrades();
            }
        }
        // Effects
        status.timestamp = uint40(block.timestamp);
        status.status = Status.TOKEN_SWAP_PROPOSED;
        self.rebalanceStatus = status;
        self.externalTradesHash = keccak256(abi.encode(externalTrades));

        EulerRouter eulerRouter = self.eulerRouter;
        BasketContext memory slot = BasketContext({
            basketBalances: new uint256[][](baskets.length),
            totalValues: new uint256[](baskets.length)
        });
        _initializeBasketData(self, eulerRouter, baskets, basketAssets, slot);
        // NOTE: for rebalance retries the internal trades must be updated as well
        _processInternalTrades(self, eulerRouter, internalTrades, baskets, slot);
        _validateExternalTrades(self, eulerRouter, externalTrades, baskets, slot);
        if (!_isTargetWeightMet(self, eulerRouter, baskets, basketTargetWeights, basketAssets, slot)) {
            revert TargetWeightsNotMet();
        }
    }

    /// @notice Completes the rebalance for the given baskets. The rebalance can be completed if it has been more than
    /// 15 minutes since the last action.
    /// @param self BasketManagerStorage struct containing strategy data.
    /// @param externalTrades Array of external trades matching those proposed for rebalance.
    /// @param baskets Array of basket addresses proposed for rebalance.
    /// @param basketTargetWeights Array of target weights for each basket.
    // slither-disable-next-line cyclomatic-complexity
    function completeRebalance(
        BasketManagerStorage storage self,
        ExternalTrade[] calldata externalTrades,
        address[] calldata baskets,
        uint64[][] calldata basketTargetWeights,
        address[][] calldata basketAssets
    )
        external
    {
        // Revert if there is no rebalance in progress
        // slither-disable-next-line incorrect-equality
        if (self.rebalanceStatus.status == Status.NOT_STARTED) {
            revert NoRebalanceInProgress();
        }
        _validateBasketHash(self, baskets, basketTargetWeights, basketAssets);
        // Check if the rebalance was proposed more than 15 minutes ago
        // slither-disable-next-line timestamp
        if (block.timestamp - self.rebalanceStatus.timestamp < self.stepDelay) {
            revert TooEarlyToCompleteRebalance();
        }
        // if external trades are proposed and executed, finalize them and claim results from the trades
        if (self.rebalanceStatus.status == Status.TOKEN_SWAP_EXECUTED) {
            if (keccak256(abi.encode(externalTrades)) != self.externalTradesHash) {
                revert ExternalTradeMismatch();
            }
            _processExternalTrades(self, externalTrades);
        }

        EulerRouter eulerRouter = self.eulerRouter;
        BasketContext memory slot = BasketContext({
            basketBalances: new uint256[][](baskets.length),
            totalValues: new uint256[](baskets.length)
        });
        _initializeBasketData(self, eulerRouter, baskets, basketAssets, slot);
        // Confirm that target weights have been met, if max retries is reached continue regardless
        uint8 currentRetryCount = self.rebalanceStatus.retryCount;
        if (currentRetryCount < self.retryLimit) {
            if (!_isTargetWeightMet(self, eulerRouter, baskets, basketTargetWeights, basketAssets, slot)) {
                // If target weights are not met and we have not reached max retries, revert to beginning of rebalance
                // to allow for additional token swaps to be proposed and increment retryCount.
                self.rebalanceStatus.retryCount = ++currentRetryCount;
                self.rebalanceStatus.timestamp = uint40(block.timestamp);
                self.externalTradesHash = bytes32(0);
                self.rebalanceStatus.status = Status.REBALANCE_PROPOSED;
                // slither-disable-next-line reentrancy-events
                emit RebalanceRetried(self.rebalanceStatus.epoch, currentRetryCount);
                return;
            }
        }
        _finalizeRebalance(self, eulerRouter, baskets, basketAssets);
    }

    /// FALLBACK REDEEM LOGIC ///

    /// @notice Fallback redeem function to redeem shares when the rebalance is not in progress. Redeems the shares for
    /// each underlying asset in the basket pro-rata to the amount of shares redeemed.
    /// @param totalSupplyBefore Total supply of the basket token before the shares were burned.
    /// @param burnedShares Amount of shares burned.
    /// @param to Address to send the redeemed assets to.
    // solhint-disable-next-line code-complexity
    function proRataRedeem(
        BasketManagerStorage storage self,
        uint256 totalSupplyBefore,
        uint256 burnedShares,
        address to
    )
        external
    {
        // Checks
        if (totalSupplyBefore == 0) {
            revert ZeroTotalSupply();
        }
        if (burnedShares == 0) {
            revert ZeroBurnedShares();
        }
        if (burnedShares > totalSupplyBefore) {
            revert CannotBurnMoreSharesThanTotalSupply();
        }
        if (to == address(0)) {
            revert ZeroAddress();
        }
        // Revert if the basket is currently rebalancing
        if ((self.rebalanceStatus.basketMask & (1 << self.basketTokenToIndexPlusOne[msg.sender] - 1)) != 0) {
            revert MustWaitForRebalanceToComplete();
        }

        address basket = msg.sender;
        address[] memory assets = self.basketAssets[basket];
        uint256 assetsLength = assets.length;
        uint256[] memory amountToWithdraws = new uint256[](assetsLength);

        // Interactions
        // First loop: compute amountToWithdraw for each asset and update balances
        for (uint256 i = 0; i < assetsLength;) {
            address asset = assets[i];
            // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop
            uint256 balance = self.basketBalanceOf[basket][asset];
            // Rounding direction: down
            // Division-by-zero is not possible: totalSupplyBefore is greater than 0
            uint256 amountToWithdraw = FixedPointMathLib.fullMulDiv(burnedShares, balance, totalSupplyBefore);
            amountToWithdraws[i] = amountToWithdraw;
            if (amountToWithdraw > 0) {
                // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop
                self.basketBalanceOf[basket][asset] = balance - amountToWithdraw;
            }
            unchecked {
                // Overflow not possible: i is less than assetsLength
                ++i;
            }
        }

        // Second loop: perform safeTransfer for each asset
        for (uint256 i = 0; i < assetsLength;) {
            uint256 amountToWithdraw = amountToWithdraws[i];
            if (amountToWithdraw > 0) {
                // Asset is an allowlisted ERC20 with no reentrancy problem in transfer
                // slither-disable-next-line reentrancy-no-eth
                IERC20(assets[i]).safeTransfer(to, amountToWithdraw);
            }
            unchecked {
                // Overflow not possible: i is less than assetsLength
                ++i;
            }
        }
    }

    /// @notice Returns the index of the asset in a given basket
    /// @param self BasketManagerStorage struct containing strategy data.
    /// @param basketToken Basket token address.
    /// @param asset Asset address.
    /// @return index Index of the asset in the basket.
    function getAssetIndexInBasket(
        BasketManagerStorage storage self,
        address basketToken,
        address asset
    )
        public
        view
        returns (uint256 index)
    {
        index = self.basketAssetToIndexPlusOne[basketToken][asset];
        if (index == 0) {
            revert AssetNotFoundInBasket();
        }
        unchecked {
            // Overflow not possible: index is not 0
            return index - 1;
        }
    }

    /// @notice Returns the index of the basket token.
    /// @param self BasketManagerStorage struct containing strategy data.
    /// @param basketToken Basket token address.
    /// @return index Index of the basket token.
    function basketTokenToIndex(
        BasketManagerStorage storage self,
        address basketToken
    )
        public
        view
        returns (uint256 index)
    {
        index = self.basketTokenToIndexPlusOne[basketToken];
        if (index == 0) {
            revert BasketTokenNotFound();
        }
        unchecked {
            // Overflow not possible: index is not 0
            return index - 1;
        }
    }

    /// INTERNAL FUNCTIONS ///

    /// @notice Returns the index of the element in the array.
    /// @dev Reverts if the element does not exist in the array.
    /// @param array Array to find the element in.
    /// @param element Element to find in the array.
    /// @return index Index of the element in the array.
    function _indexOf(address[] calldata array, address element) internal pure returns (uint256 index) {
        uint256 length = array.length;
        for (uint256 i = 0; i < length;) {
            if (array[i] == element) {
                return i;
            }
            unchecked {
                // Overflow not possible: index is not 0
                ++i;
            }
        }
        revert ElementIndexNotFound();
    }

    /// PRIVATE FUNCTIONS ///

    /// @notice Internal function to finalize the state changes for the current rebalance. Resets rebalance status and
    /// attempts to process pending redeems. If all pending redeems cannot be fulfilled notifies basket token of a
    /// failed rebalance.
    /// @param self BasketManagerStorage struct containing strategy data.
    /// @param baskets Array of basket addresses currently being rebalanced.
    function _finalizeRebalance(
        BasketManagerStorage storage self,
        EulerRouter eulerRouter,
        address[] calldata baskets,
        address[][] calldata basketAssets
    )
        private
    {
        // Advance the rebalance epoch and reset the status
        uint40 epoch = self.rebalanceStatus.epoch;
        self.rebalanceStatus.basketHash = bytes32(0);
        self.rebalanceStatus.basketMask = 0;
        self.rebalanceStatus.epoch = epoch + 1;
        self.rebalanceStatus.proposalTimestamp = uint40(0);
        self.rebalanceStatus.timestamp = uint40(block.timestamp);
        self.rebalanceStatus.status = Status.NOT_STARTED;
        self.externalTradesHash = bytes32(0);
        self.rebalanceStatus.retryCount = 0;
        // slither-disable-next-line reentrancy-events
        emit RebalanceCompleted(epoch);

        // Process the redeems for the given baskets
        uint256 len = baskets.length;
        // slither-disable-start calls-loop
        for (uint256 i = 0; i < len;) {
            // NOTE: Can be optimized by using calldata for the `baskets` parameter or by moving the
            // redemption processing logic to a ZK coprocessor like Axiom for improved efficiency and scalability.
            address basket = baskets[i];
            address[] calldata assets = basketAssets[i];
            // nosemgrep: solidity.performance.array-length-outside-loop.array-length-outside-loop
            uint256 assetsLength = assets.length;
            uint256[] memory balances = new uint256[](assetsLength);
            uint256 basketValue = 0;

            // Harvest management fee
            BasketToken(basket).harvestManagementFee();

            // Calculate current basket value
            for (uint256 j = 0; j < assetsLength;) {
                // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop
                balances[j] = self.basketBalanceOf[basket][assets[j]];
                if (balances[j] > 0) {
                    // Rounding direction: down
                    // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop
                    basketValue += eulerRouter.getQuote(balances[j], assets[j], _USD_ISO_4217_CODE);
                }
                unchecked {
                    // Overflow not possible: j is less than assetsLength
                    ++j;
                }
            }

            // If there are pending redeems, process them
            // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop
            uint256 pendingRedeems = self.pendingRedeems[basket];
            if (pendingRedeems > 0) {
                // slither-disable-next-line costly-loop
                self.pendingRedeems[basket] = 0; // nosemgrep
                uint256 baseAssetIndex = self.basketTokenToBaseAssetIndexPlusOne[basket] - 1;
                address baseAsset = assets[baseAssetIndex];
                uint256 baseAssetBalance = balances[baseAssetIndex];
                // Rounding direction: down
                // Division-by-zero is not possible: totalSupply is greater than 0 when pendingRedeems is greater than 0
                // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop
                uint256 withdrawAmount = eulerRouter.getQuote(
                    FixedPointMathLib.fullMulDiv(basketValue, pendingRedeems, BasketToken(basket).totalSupply()),
                    _USD_ISO_4217_CODE,
                    baseAsset
                );
                // Set withdrawAmount to zero if it exceeds baseAssetBalance, otherwise keep it unchanged
                withdrawAmount = withdrawAmount <= baseAssetBalance ? withdrawAmount : 0;
                if (withdrawAmount > 0) {
                    unchecked {
                        // Overflow not possible: withdrawAmount is less than or equal to balances[baseAssetIndex]
                        // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop
                        self.basketBalanceOf[basket][baseAsset] = baseAssetBalance - withdrawAmount;
                    }
                    // slither-disable-next-line reentrancy-no-eth
                    IERC20(baseAsset).forceApprove(basket, withdrawAmount);
                }
                // ERC20.transferFrom is called in BasketToken.fulfillRedeem
                // slither-disable-next-line reentrancy-no-eth
                BasketToken(basket).fulfillRedeem(withdrawAmount);
            }
            unchecked {
                // Overflow not possible: i is less than baskets.length
                ++i;
            }
        }
        // slither-disable-end calls-loop
    }

    /// @notice Internal function to complete proposed token swaps.
    /// @param self BasketManagerStorage struct containing strategy data.
    /// @param externalTrades Array of external trades to be completed.
    /// @return claimedAmounts amounts claimed from the completed token swaps
    function _completeTokenSwap(
        BasketManagerStorage storage self,
        ExternalTrade[] calldata externalTrades
    )
        private
        returns (uint256[2][] memory claimedAmounts)
    {
        // solhint-disable avoid-low-level-calls
        // slither-disable-next-line low-level-calls
        (bool success, bytes memory data) =
            self.tokenSwapAdapter.delegatecall(abi.encodeCall(TokenSwapAdapter.completeTokenSwap, (externalTrades)));
        // solhint-enable avoid-low-level-calls
        if (!success) {
            // assume this low-level call never fails
            revert CompleteTokenSwapFailed();
        }
        claimedAmounts = abi.decode(data, (uint256[2][]));
    }

    /// @notice Internal function to update internal accounting with result of completed token swaps.
    /// @param self BasketManagerStorage struct containing strategy data.
    /// @param externalTrades Array of external trades to be completed.
    function _processExternalTrades(
        BasketManagerStorage storage self,
        ExternalTrade[] calldata externalTrades
    )
        private
    {
        uint256 externalTradesLength = externalTrades.length;
        uint256[2][] memory claimedAmounts = _completeTokenSwap(self, externalTrades);
        // Update basketBalanceOf with amounts gained from swaps
        for (uint256 i = 0; i < externalTradesLength;) {
            ExternalTrade calldata trade = externalTrades[i];
            // nosemgrep: solidity.performance.array-length-outside-loop.array-length-outside-loop
            uint256 tradeOwnershipLength = trade.basketTradeOwnership.length;
            uint256 remainingSellTokenAmount = claimedAmounts[i][0];
            uint256 remainingBuyTokenAmount = claimedAmounts[i][1];
            uint256 remainingSellAmount = trade.sellAmount;

            for (uint256 j; j < tradeOwnershipLength;) {
                BasketTradeOwnership calldata ownership = trade.basketTradeOwnership[j];

                // Get basket balances mapping for this ownership
                mapping(address => uint256) storage basketBalanceOf = self.basketBalanceOf[ownership.basket];

                if (j == tradeOwnershipLength - 1) {
                    // Last ownership gets remaining amounts
                    basketBalanceOf[trade.buyToken] += remainingBuyTokenAmount;
                    basketBalanceOf[trade.sellToken] =
                        basketBalanceOf[trade.sellToken] + remainingSellTokenAmount - remainingSellAmount;
                } else {
                    // Calculate ownership portions
                    uint256 buyTokenAmount =
                        FixedPointMathLib.fullMulDiv(claimedAmounts[i][1], ownership.tradeOwnership, _WEIGHT_PRECISION);
                    uint256 sellTokenAmount =
                        FixedPointMathLib.fullMulDiv(claimedAmounts[i][0], ownership.tradeOwnership, _WEIGHT_PRECISION);
                    uint256 sellAmount =
                        FixedPointMathLib.fullMulDiv(trade.sellAmount, ownership.tradeOwnership, _WEIGHT_PRECISION);

                    // Update balances
                    basketBalanceOf[trade.buyToken] += buyTokenAmount;
                    basketBalanceOf[trade.sellToken] = basketBalanceOf[trade.sellToken] + sellTokenAmount - sellAmount;

                    // Track remaining amounts
                    remainingBuyTokenAmount -= buyTokenAmount;
                    remainingSellTokenAmount -= sellTokenAmount;
                    remainingSellAmount -= sellAmount;
                }
                unchecked {
                    // Overflow not possible: i is less than tradeOwnerShipLength.length
                    ++j;
                }
            }
            unchecked {
                // Overflow not possible: i is less than externalTradesLength.length
                ++i;
            }
        }
    }

    /// @notice Internal function to initialize basket data.
    /// @param self BasketManagerStorage struct containing strategy data.
    /// @param baskets Array of basket addresses currently being rebalanced.
    /// @param basketAssets An array of arrays of basket assets.
    /// @param slot A Slot struct containing the basket balances and total values.
    function _initializeBasketData(
        BasketManagerStorage storage self,
        EulerRouter eulerRouter,
        address[] calldata baskets,
        address[][] calldata basketAssets,
        BasketContext memory slot
    )
        private
        view
    {
        uint256 numBaskets = baskets.length;
        for (uint256 i = 0; i < numBaskets;) {
            address[] calldata assets = basketAssets[i];
            // nosemgrep: solidity.performance.array-length-outside-loop.array-length-outside-loop
            uint256 assetsLength = assets.length;
            slot.basketBalances[i] = new uint256[](assetsLength);
            // Create a storage mapping reference for the current basket's balances
            mapping(address => uint256) storage basketBalanceOf = self.basketBalanceOf[baskets[i]];
            for (uint256 j = 0; j < assetsLength;) {
                address asset = assets[j];
                // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop
                uint256 currentAssetAmount = basketBalanceOf[asset];
                slot.basketBalances[i][j] = currentAssetAmount;
                if (currentAssetAmount > 0) {
                    // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop
                    // slither-disable-next-line calls-loop
                    slot.totalValues[i] += eulerRouter.getQuote(currentAssetAmount, asset, _USD_ISO_4217_CODE);
                }
                unchecked {
                    // Overflow not possible: j is less than assetsLength
                    ++j;
                }
            }
            unchecked {
                // Overflow not possible: i is less than numBaskets
                ++i;
            }
        }
    }

    /// @notice Internal function to settle internal trades.
    /// @param self BasketManagerStorage struct containing strategy data.
    /// @param internalTrades Array of internal trades to execute.
    /// @param baskets Array of basket addresses currently being rebalanced.
    /// @param slot A Slot struct containing the basket balances and total values.
    /// @dev If the result of an internal trade is not within the provided minAmount or maxAmount, this function will
    /// revert.
    function _processInternalTrades(
        BasketManagerStorage storage self,
        EulerRouter eulerRouter,
        InternalTrade[] calldata internalTrades,
        address[] calldata baskets,
        BasketContext memory slot
    )
        private
    {
        uint256 swapFee = self.swapFee; // Fetch swapFee once for gas optimization
        uint256 internalTradesLength = internalTrades.length;
        for (uint256 i = 0; i < internalTradesLength;) {
            InternalTrade calldata trade = internalTrades[i];
            if (trade.sellAmount == 0) {
                revert InternalTradeSellAmountZero();
            }
            // slither-disable-next-line calls-loop
            InternalTradeInfo memory info = InternalTradeInfo({
                fromBasketIndex: _indexOf(baskets, trade.fromBasket),
                toBasketIndex: _indexOf(baskets, trade.toBasket),
                sellTokenAssetIndex: getAssetIndexInBasket(self, trade.fromBasket, trade.sellToken),
                buyTokenAssetIndex: getAssetIndexInBasket(self, trade.fromBasket, trade.buyToken),
                toBasketBuyTokenIndex: getAssetIndexInBasket(self, trade.toBasket, trade.buyToken),
                toBasketSellTokenIndex: getAssetIndexInBasket(self, trade.toBasket, trade.sellToken),
                netBuyAmount: 0,
                netSellAmount: 0,
                feeOnBuy: 0,
                feeOnSell: 0,
                sellValue: eulerRouter.getQuote(trade.sellAmount, trade.sellToken, _USD_ISO_4217_CODE),
                feeValue: 0
            });
            uint256 initialBuyAmount = 0;
            // slither-disable-next-line timestamp
            if (info.sellValue > 0) {
                // slither-disable-next-line calls-loop
                initialBuyAmount = eulerRouter.getQuote(info.sellValue, _USD_ISO_4217_CODE, trade.buyToken);
            }
            // Calculate fee on sellAmount
            if (swapFee > 0) {
                info.feeOnSell = FixedPointMathLib.fullMulDiv(trade.sellAmount, swapFee, 20_000);
                info.feeValue = FixedPointMathLib.fullMulDiv(info.sellValue, swapFee, 20_000);
                slot.totalValues[info.fromBasketIndex] -= info.feeValue;
                self.collectedSwapFees[trade.sellToken] += info.feeOnSell;
                emit SwapFeeCharged(trade.sellToken, info.feeOnSell);

                info.feeOnBuy = FixedPointMathLib.fullMulDiv(initialBuyAmount, swapFee, 20_000);
                slot.totalValues[info.toBasketIndex] -= info.feeValue;
                self.collectedSwapFees[trade.buyToken] += info.feeOnBuy;
                emit SwapFeeCharged(trade.buyToken, info.feeOnBuy);
            }
            info.netSellAmount = trade.sellAmount - info.feeOnSell;
            info.netBuyAmount = initialBuyAmount - info.feeOnBuy;

            // slither-disable-next-line timestamp
            if (info.netBuyAmount < trade.minAmount || trade.maxAmount < initialBuyAmount) {
                revert InternalTradeMinMaxAmountNotReached();
            }
            if (trade.sellAmount > slot.basketBalances[info.fromBasketIndex][info.sellTokenAssetIndex]) {
                revert IncorrectTradeTokenAmount();
            }
            // slither-disable-next-line timestamp
            if (initialBuyAmount > slot.basketBalances[info.toBasketIndex][info.toBasketBuyTokenIndex]) {
                revert IncorrectTradeTokenAmount();
            }
            // Settle the internal trades and track the balance changes.
            // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop
            self.basketBalanceOf[trade.fromBasket][trade.sellToken] =
                slot.basketBalances[info.fromBasketIndex][info.sellTokenAssetIndex] -= trade.sellAmount; // nosemgrep
            // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop
            self.basketBalanceOf[trade.fromBasket][trade.buyToken] =
                slot.basketBalances[info.fromBasketIndex][info.buyTokenAssetIndex] += info.netBuyAmount; // nosemgrep
            // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop
            self.basketBalanceOf[trade.toBasket][trade.buyToken] =
                slot.basketBalances[info.toBasketIndex][info.toBasketBuyTokenIndex] -= initialBuyAmount; // nosemgrep
            // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop
            self.basketBalanceOf[trade.toBasket][trade.sellToken] =
                slot.basketBalances[info.toBasketIndex][info.toBasketSellTokenIndex] += info.netSellAmount; // nosemgrep
            unchecked {
                // Overflow not possible: i is less than internalTradesLength and internalTradesLength cannot be near
                // the maximum value of uint256 due to gas limits
                ++i;
            }
            emit InternalTradeSettled(trade, info.netBuyAmount);
        }
    }

    /// @notice Internal function to validate the results of external trades.
    /// @param self BasketManagerStorage struct containing strategy data.
    /// @param externalTrades Array of external trades to be validated.
    /// @param baskets Array of basket addresses currently being rebalanced.
    /// @param slot A Slot struct containing the basket balances and total values.
    /// @dev If the result of an external trade is not within the slippageLimit threshold of the minAmount, this
    /// function will revert. If the sum of the trade ownerships is not equal to _WEIGHT_PRECISION, this function will
    /// revert.
    function _validateExternalTrades(
        BasketManagerStorage storage self,
        EulerRouter eulerRouter,
        ExternalTrade[] calldata externalTrades,
        address[] calldata baskets,
        BasketContext memory slot
    )
        private
        view
    {
        uint256 slippageLimit = self.slippageLimit;
        for (uint256 i = 0; i < externalTrades.length;) {
            ExternalTrade calldata trade = externalTrades[i];
            if (trade.sellAmount == 0) {
                revert ExternalTradeSellAmountZero();
            }
            uint256 ownershipSum = 0;
            // nosemgrep: solidity.performance.array-length-outside-loop.array-length-outside-loop
            for (uint256 j = 0; j < trade.basketTradeOwnership.length;) {
                BasketTradeOwnership calldata ownership = trade.basketTradeOwnership[j];
                ownershipSum += ownership.tradeOwnership;
                uint256 basketIndex = _indexOf(baskets, ownership.basket);
                uint256 buyTokenAssetIndex = getAssetIndexInBasket(self, ownership.basket, trade.buyToken);
                uint256 sellTokenAssetIndex = getAssetIndexInBasket(self, ownership.basket, trade.sellToken);
                uint256 ownershipSellAmount =
                    FixedPointMathLib.fullMulDiv(trade.sellAmount, ownership.tradeOwnership, _WEIGHT_PRECISION);
                uint256 ownershipBuyAmount =
                    FixedPointMathLib.fullMulDiv(trade.minAmount, ownership.tradeOwnership, _WEIGHT_PRECISION);
                // Record changes in basket asset holdings due to the external trade
                if (ownershipSellAmount > slot.basketBalances[basketIndex][sellTokenAssetIndex]) {
                    revert IncorrectTradeTokenAmount();
                }
                slot.basketBalances[basketIndex][sellTokenAssetIndex] =
                    slot.basketBalances[basketIndex][sellTokenAssetIndex] - ownershipSellAmount;
                slot.basketBalances[basketIndex][buyTokenAssetIndex] =
                    slot.basketBalances[basketIndex][buyTokenAssetIndex] + ownershipBuyAmount;
                // Update total basket value
                // slither-disable-next-line calls-loop
                slot.totalValues[basketIndex] = slot.totalValues[basketIndex]
                // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop
                - eulerRouter.getQuote(ownershipSellAmount, trade.sellToken, _USD_ISO_4217_CODE)
                // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop
                + eulerRouter.getQuote(ownershipBuyAmount, trade.buyToken, _USD_ISO_4217_CODE);
                unchecked {
                    // Overflow not possible: j is bounded by trade.basketTradeOwnership.length
                    ++j;
                }
            }
            if (ownershipSum != _WEIGHT_PRECISION) {
                revert OwnershipSumMismatch();
            }
            // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop
            // slither-disable-next-line calls-loop
            uint256 internalMinAmount = eulerRouter.getQuote(
                eulerRouter.getQuote(trade.sellAmount, trade.sellToken, _USD_ISO_4217_CODE),
                _USD_ISO_4217_CODE,
                trade.buyToken
            );

            // Check if the given minAmount is within the slippageLimit threshold of internalMinAmount
            // slither-disable-start timestamp
            if (
                FixedPointMathLib.fullMulDiv(
                    MathUtils.diff(internalMinAmount, trade.minAmount), _WEIGHT_PRECISION, internalMinAmount
                ) > slippageLimit
            ) {
                revert ExternalTradeSlippage();
            }
            // slither-disable-end timestamp
            unchecked {
                // Overflow not possible: i is bounded by baskets.length
                ++i;
            }
        }
    }

    /// @notice Validate the basket hash based on the given baskets and target weights.
    function _validateBasketHash(
        BasketManagerStorage storage self,
        address[] calldata baskets,
        uint64[][] calldata basketsTargetWeights,
        address[][] calldata basketAssets
    )
        private
        view
    {
        // Validate the calldata hashes
        bytes32 basketHash = keccak256(abi.encode(baskets, basketsTargetWeights, basketAssets));
        if (self.rebalanceStatus.basketHash != basketHash) {
            revert BasketsMismatch();
        }
        // Check that the length matches
        if (baskets.length != basketsTargetWeights.length || baskets.length != basketAssets.length) {
            revert BasketsMismatch();
        }
    }

    /// @notice Checks if weight deviations after trades are within the acceptable weightDeviationLimit threshold.
    /// Returns true if all deviations are within bounds for each asset in every basket.
    /// @param self BasketManagerStorage struct containing strategy data.
    /// @param baskets Array of basket addresses currently being rebalanced.
    /// @param basketsTargetWeights Array of target weights for each basket.
    /// @param basketAssets Array of assets in each basket.
    /// @param slot A Slot struct containing the basket balances and total values.
    // solhint-disable-next-line code-complexity
    function _isTargetWeightMet(
        BasketManagerStorage storage self,
        EulerRouter eulerRouter,
        address[] calldata baskets,
        uint64[][] calldata basketsTargetWeights,
        address[][] calldata basketAssets,
        BasketContext memory slot
    )
        private
        view
        returns (bool)
    {
        // Check if total weight change due to all trades is within the weightDeviationLimit threshold
        uint256 len = baskets.length;
        uint256 weightDeviationLimit = self.weightDeviationLimit;
        for (uint256 i = 0; i < len;) {
            // slither-disable-next-line calls-loop
            uint64[] calldata proposedTargetWeights = basketsTargetWeights[i];
            // nosemgrep: solidity.performance.array-length-outside-loop.array-length-outside-loop
            uint256 numOfAssets = proposedTargetWeights.length;
            uint64[] memory adjustedTargetWeights = new uint64[](numOfAssets);

            // Calculate adjusted target weights accounting for pending redeems
            uint256 pendingRedeems = self.pendingRedeems[baskets[i]];
            if (pendingRedeems > 0) {
                // slither-disable-next-line calls-loop
                uint256 totalSupply = BasketToken(baskets[i]).totalSupply();
                uint256 remainingSupply = totalSupply - pendingRedeems;

                // Get base asset index
                uint256 baseAssetIndex = self.basketTokenToBaseAssetIndexPlusOne[baskets[i]] - 1;

                // Track running sum for all weights except the last one
                uint256 runningSum = 0;
                uint256 lastIndex = numOfAssets - 1;

                // Adjust weights while maintaining 1e18 sum
                for (uint256 j = 0; j < numOfAssets;) {
                    if (j == lastIndex) {
                        // Use remainder for the last weight to ensure exact 1e18 sum
                        adjustedTargetWeights[j] = uint64(_WEIGHT_PRECISION - runningSum);
                    } else {
                        if (j == baseAssetIndex) {
                            // Increase base asset weight by adding extra weight from pending redeems
                            adjustedTargetWeights[j] = uint64(
                                FixedPointMathLib.fullMulDiv(
                                    FixedPointMathLib.fullMulDiv(
                                        remainingSupply, proposedTargetWeights[j], _WEIGHT_PRECISION
                                    ) + pendingRedeems,
                                    _WEIGHT_PRECISION,
                                    totalSupply
                                )
                            );
                            runningSum += adjustedTargetWeights[j];
                        } else {
                            // Scale down other weights proportionally
                            adjustedTargetWeights[j] = uint64(
                                FixedPointMathLib.fullMulDiv(remainingSupply, proposedTargetWeights[j], totalSupply)
                            );
                            runningSum += adjustedTargetWeights[j];
                        }
                    }
                    unchecked {
                        ++j;
                    }
                }
            } else {
                // If no pending redeems, use original target weights
                adjustedTargetWeights = proposedTargetWeights;
            }
            // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop
            address[] calldata assets = basketAssets[i];
            // nosemgrep: solidity.performance.array-length-outside-loop.array-length-outside-loop
            uint256 proposedTargetWeightsLength = proposedTargetWeights.length;
            for (uint256 j = 0; j < proposedTargetWeightsLength;) {
                // If the total value of the basket is 0, we can't calculate the weight.
                // So we assume the target weight is met.
                if (slot.totalValues[i] != 0) {
                    uint256 assetValueInUSD = 0;
                    if (slot.basketBalances[i][j] > 0) {
                        // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop
                        // slither-disable-next-line calls-loop
                        assetValueInUSD = eulerRouter.getQuote(slot.basketBalances[i][j], assets[j], _USD_ISO_4217_CODE);
                    }
                    // Rounding direction: down
                    uint256 afterTradeWeight =
                        FixedPointMathLib.fullMulDiv(assetValueInUSD, _WEIGHT_PRECISION, slot.totalValues[i]);
                    // slither-disable-next-line timestamp
                    if (MathUtils.diff(adjustedTargetWeights[j], afterTradeWeight) > weightDeviationLimit) {
                        return false;
                    }
                }
                unchecked {
                    // Overflow not possible: j is bounded by proposedTargetWeightsLength
                    ++j;
                }
            }
            unchecked {
                // Overflow not possible: i is bounded by len
                ++i;
            }
        }
        return true;
    }

    /// @notice Internal function to process pending deposits and fulfill them.
    /// @dev Assumes pendingDeposit is not 0.
    /// @param self BasketManagerStorage struct containing strategy data.
    /// @param basket Basket token address.
    /// @param basketValue Current value of the basket in USD.
    /// @param baseAssetBalance Current balance of the base asset in the basket.
    /// @param pendingDeposit Current assets pending deposit in the given basket.
    /// @return newShares Amount of new shares minted.
    /// @return pendingDepositValue Value of the pending deposits in USD.
    // slither-disable-next-line calls-loop
    function _processPendingDeposits(
        BasketManagerStorage storage self,
        EulerRouter eulerRouter,
        address basket,
        uint256 totalSupply,
        uint256 basketValue,
        uint256 baseAssetBalance,
        uint256 pendingDeposit,
        address baseAssetAddress
    )
        private
        returns (uint256 newShares, uint256 pendingDepositValue)
    {
        // Assume the first asset listed in the basket is the base asset
        // Round direction: down
        // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop
        pendingDepositValue = eulerRouter.getQuote(pendingDeposit, baseAssetAddress, _USD_ISO_4217_CODE);
        // Rounding direction: down
        // Division-by-zero is not possible: basketValue is greater than 0
        newShares = basketValue > 0
            ? FixedPointMathLib.fullMulDiv(pendingDepositValue, totalSupply, basketValue)
            : pendingDepositValue;
        if (newShares > 0) {
            // Add the deposit to the basket balance if newShares is positive
            // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop
            self.basketBalanceOf[basket][baseAssetAddress] = baseAssetBalance + pendingDeposit;
        } else {
            // If newShares is 0, set pendingDepositValue to 0 to indicate rejected deposit, no deposit is minted
            pendingDepositValue = 0;
        }
        // slither-disable-next-line reentrancy-no-eth,reentrancy-benign
        BasketToken(basket).fulfillDeposit(newShares);
    }

    /// @notice Internal function to calculate the current value of all assets in a given basket.
    /// @param self BasketManagerStorage struct containing strategy data.
    /// @param basket Basket token address.
    /// @param assets Array of asset addresses in the basket.
    /// @return balances Array of balances of each asset in the basket.
    /// @return basketValue Current value of the basket in USD.
    // slither-disable-next-line calls-loop
    function _calculateBasketValue(
        BasketManagerStorage storage self,
        EulerRouter eulerRouter,
        address basket,
        address[] memory assets
    )
        private
        view
        returns (uint256[] memory balances, uint256 basketValue)
    {
        uint256 assetsLength = assets.length;
        balances = new uint256[](assetsLength);
        for (uint256 j = 0; j < assetsLength;) {
            // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop
            balances[j] = self.basketBalanceOf[basket][assets[j]];
            // Rounding direction: down
            // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop
            if (balances[j] > 0) {
                // nosemgrep: solidity.performance.state-variable-read-in-a-loop.state-variable-read-in-a-loop
                basketValue += eulerRouter.getQuote(balances[j], assets[j], _USD_ISO_4217_CODE);
            }
            unchecked {
                // Overflow not possible: j is less than assetsLength
                ++j;
            }
        }
    }

    /// @notice Internal function to store the index of the base asset for a given basket. Reverts if the base asset is
    /// not present in the basket's assets.
    /// @param self BasketManagerStorage struct containing strategy data.
    /// @param basket Basket token address.
    /// @param assets Array of asset addresses in the basket.
    /// @param baseAsset Base asset address.
    /// @dev If the base asset is not present in the basket, this function will revert.
    function _setBaseAssetIndex(
        BasketManagerStorage storage self,
        address basket,
        address[] memory assets,
        address baseAsset
    )
        private
    {
        uint256 len = assets.length;
        for (uint256 i = 0; i < len;) {
            if (assets[i] == baseAsset) {
                self.basketTokenToBaseAssetIndexPlusOne[basket] = i + 1;
                return;
            }
            unchecked {
                // Overflow not possible: i is less than len
                ++i;
            }
        }
        revert BaseAssetMismatch();
    }

    /// @notice Internal function to create a bitmask for baskets being rebalanced.
    /// @param self BasketManagerStorage struct containing strategy data.
    /// @param baskets Array of basket addresses currently being rebalanced.
    /// @return basketMask Bitmask for baskets being rebalanced.
    /// @dev A bitmask like 00000011 indicates that the first two baskets are being rebalanced.
    function _createRebalanceBitMask(
        BasketManagerStorage storage self,
        address[] memory baskets
    )
        private
        view
        returns (uint256 basketMask)
    {
        // Create the bitmask for baskets being rebalanced
        basketMask = 0;
        uint256 len = baskets.length;
        for (uint256 i = 0; i < len;) {
            uint256 indexPlusOne = self.basketTokenToIndexPlusOne[baskets[i]];
            if (indexPlusOne == 0) {
                revert BasketTokenNotFound();
            }
            basketMask |= (1 << indexPlusOne - 1);
            unchecked {
                // Overflow not possible: i is less than len
                ++i;
            }
        }
    }
}
</file>

</files>
